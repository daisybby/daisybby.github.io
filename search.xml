<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis注册为windows服务</title>
    <url>/2024/06/17/Redis%E6%B3%A8%E5%86%8C%E4%B8%BAwindows%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>安装完Redis需要用命令行启动，而且要保持这个窗口不关闭。</p>
<span id="more"></span>
<p>注册为windows服务后不再受控制台的影响。<br><strong>控制台输入：</strong><br><code>redis-server.exe --service-install redis.windows.conf </code><br><strong>开启Redis服务:</strong><br>控制台输入：<code>redis-server --service-start</code></p>
<blockquote>
<p>注意：在redis安装目录下进入cmd就能打开控制台。</p>
</blockquote>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
  </entry>
  <entry>
    <title>session、cookie和token</title>
    <url>/2024/06/18/session%E3%80%81cookie%E5%92%8Ctoken/</url>
    <content><![CDATA[<h1 id="session、cookie和token"><a href="#session、cookie和token" class="headerlink" title="session、cookie和token"></a>session、cookie和token</h1><ul>
<li>cookie：保存在客户端，用来解决客户端保存信息的问题。</li>
<li>session：保存在服务器端，每个客户端对应一个session。</li>
<li>token：无状态且跨域，能够有效防御CSRF，解决session依赖单个服务器的问题。</li>
</ul>
<span id="more"></span>
<h2 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h2><p>浏览器可以将服务器端发送的信息保存到cookie中，在浏览器之后每次发送请求时，可以将存活的cookie放到请求头一起发送给服务器端。</p>
<img src="/2024/06/18/session%E3%80%81cookie%E5%92%8Ctoken/cookie-and-session.png" class="" title="img1">
<h2 id="2-session"><a href="#2-session" class="headerlink" title="2.session"></a>2.session</h2><p>&ensp;&ensp;客户端向服务端发送请求，服务端为这个请求开辟一块内存空间，即session对象，保存方式为ConcurrentHashMap。<br>&ensp;&ensp;服务器端会为session设置过期时间，避免堆积大量session。（但在高并发场景下还是会有大量session，占据存储空间）<br>session和cookie协作的详细流程：</p>
<ul>
<li>step1:客户端发送http请求</li>
<li>step2:服务端创建session对象，将sessionID通过响应头的set-Cookie命令设置到cookie中。</li>
<li>step3:在浏览器会话期间，cookie都被保存到浏览器，之后每次浏览器发送请求都携带cookie。</li>
<li>step4:服务器通过请求携带的cookie解析出sessionID，找到对应的session。</li>
</ul>
<h2 id="3-token"><a href="#3-token" class="headerlink" title="3.token"></a>3.token</h2><p>出现token是因为cookie不支持跨域访问。<br><strong>token的工作原理：</strong></p>
<ul>
<li>客户端发送登录请求，将用户名和密码传递到服务器。</li>
<li>服务器验证用户信息通过，签发一个token，token中包含用户信息，token发送给客户端。</li>
<li>客户端接收到token保存到cookie或者Local Storage中，之后每次请求都携带token。</li>
<li>服务器受到请求后，解析验证token，验证通过即可放行。</li>
</ul>
<p>token模式下，服务器是不需要保存session的，因为token中包含有用户信息，解析出来利用即可。<br>更多内容等做到项目的权限管理模块，详细记录。</p>
]]></content>
      <categories>
        <category>基础概念和原理</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战项目笔记一：短信登录</title>
    <url>/2024/06/19/redis-1/</url>
    <content><![CDATA[<h1 id="笔记一：短信验证登录"><a href="#笔记一：短信验证登录" class="headerlink" title="笔记一：短信验证登录"></a>笔记一：短信验证登录</h1><p><strong>三个关键功能：</strong></p>
<span id="more"></span>
<p>1.用户提供手机号，获取6位数字验证码；</p>
<!--more-->
<p>2.用户提供手机号和验证码，进行登录；<br>3.对于用户请求，验证用户登录状态。</p>
<h2 id="一、业务逻辑"><a href="#一、业务逻辑" class="headerlink" title="一、业务逻辑"></a>一、业务逻辑</h2><h3 id="1-获取验证码"><a href="#1-获取验证码" class="headerlink" title="1.获取验证码"></a>1.获取验证码</h3><p>参数：用户手机号<br>返回：6位数字验证码<br>关键点就是要<strong>校验手机号格式</strong>、<strong>验证码保存到session</strong>中以备后续验证。</p>
<img src="/2024/06/19/redis-1/img1.png" class="" title="img1">

<h3 id="2-验证码登录"><a href="#2-验证码登录" class="headerlink" title="2.验证码登录"></a>2.验证码登录</h3><ol>
<li>用户提供手机号和验证码</li>
<li>信息校验：验证码匹配</li>
<li>校验手机号格式：虽然生成验证码时已经校验过，但用户在登陆时输入的手机号依然存在错误的可能性。</li>
<li>根据手机号查找用户信息，有则信息保存到session（便于后续登录验证）</li>
<li>用户不存在则创建新用户。</li>
</ol>
<img src="/2024/06/19/redis-1/img2.png" class="" title="img2">

<h3 id="3-登录状态检查"><a href="#3-登录状态检查" class="headerlink" title="3.登录状态检查"></a>3.登录状态检查</h3><p><strong>1.对于用户发来的请求，检查用户是否已经登录。</strong></p>
<ol>
<li>用户发来请求，请求携带cookie</li>
<li>根据cookie中的sessionID查找到对应的session（不需要后端程序员实现）</li>
<li>检查session中是否有用户信息，有则将用户信息保存到threadLocal（关键点）</li>
<li>session中没有用户信息，说明用户没有登录。</li>
</ol>
<img src="/2024/06/19/redis-1/img3.png" class="" title="img3">

<p><strong>2.什么时候验证用户登录状态？</strong><br>在请求到达服务器后，在调用对应的controller处理方法之前。那怎么实现？可以用过滤器和拦截器（详见<a href="https://zhuanlan.zhihu.com/p/697414738">过滤器和拦截器的区别与联系</a>）。<br><strong>3.验证后要做什么？为什么要用ThreadLocal，而不是将用户信息保持在session中？</strong><br>如果session中有用户信息，那这个信息就是登录时保存到session中的，说明已经登录过了。我们在从session中获取信息时，需要将HttpSession对象传递到方法中，如果在之后的service等多处还需要用户信息，会出现频繁传递session对象的问题，而且在高并发场景下，可能会出现session混乱。<br>在服务器端，每个请求对应一个线程，那么我们可以将用户信息保存成线程内部全局可见的，即ThreadLocal的形式。线程可以全局获取用户信息，提高开发效率。<br><strong>4.注意事项</strong><br>ThreadLocal也有缺点：</p>
<ul>
<li><strong>内存泄漏：</strong> ThreadLocal和线程是绑定的，线程一直存在，那么这部分内存一直占用，如果线程数量过多，可能会占据较大内存空间；如果不及时清理这部分空间，可能会导致内存泄漏。<blockquote>
<p>内存泄漏：内存因为一些原因没有释放或者无法释放，就是内存泄漏。</p>
</blockquote>
</li>
<li><strong>上下文切换问题：</strong> 每个线程可能都有自己的本地变量，当需要在线程间共享数据时，可能涉及到线程上下文切换，增加程序的复杂性和开销。</li>
</ul>
<blockquote>
<p><strong>一定要在请求处理完毕之后，将用户信息从threadLocal释放。</strong></p>
</blockquote>
<p><strong>5.拦截器和过滤器的区别是什么？</strong></p>
<img src="/2024/06/19/redis-1/img4.png" class="" title="img4">
<ul>
<li>Filter可以拦截一切请求，通常是筛选掉一些不和要求的请求；</li>
<li>Interceptor可以设置在请求被处理之前、被处理之后，或者是对请求到达controller之后，对返回的结果进行处理。可以调用业务逻辑！</li>
</ul>
<h2 id="二、session存在的问题"><a href="#二、session存在的问题" class="headerlink" title="二、session存在的问题"></a>二、session存在的问题</h2><ul>
<li>登录后用户信息暂存在session中，在高并发场景下需要较大的内存开销；</li>
<li>session是不能被多个tomcat服务器共享的，在分布式场景下session共享比较麻烦。<br><strong>session的作用是什么？</strong></li>
<li>基于内存的，访问速度快。</li>
<li>记录登录后的用户信息，保持登录状态。</li>
<li>需要多服务器都能够访问。<br>因此，可以用<strong>Redis</strong>来满足以上需求。</li>
</ul>
<h2 id="三、使用Redis优化登录验证"><a href="#三、使用Redis优化登录验证" class="headerlink" title="三、使用Redis优化登录验证"></a>三、使用Redis优化登录验证</h2><h3 id="1-生成验证码"><a href="#1-生成验证码" class="headerlink" title="1.生成验证码"></a>1.生成验证码</h3><ul>
<li>session下：验证码保存在session中，用sessionID标识唯一；</li>
<li>Redis下：验证码保存在Redis数据库，用Key标识，一个手机号对应一个验证码，故key用手机号。但是为了开发的便利性和直观性，需要在phone之前添加前缀（这是一种数据保存思想）。</li>
<li>更新后的流程图：<img src="/2024/06/19/redis-1/img5.png" class="" title="img5">
&ensp;&ensp;&ensp;&ensp;校验码需要设置<strong>过期时间</strong>，否则可能出现大量废弃校验码堆积，造成存储空间的浪费。</li>
</ul>
<h3 id="2-用户登录"><a href="#2-用户登录" class="headerlink" title="2.用户登录"></a>2.用户登录</h3><ul>
<li>session下：从session获取验证码-&gt;匹配验证码-&gt;用户信息保存到session；</li>
<li>Redis下：从Redis获取验证码-&gt;匹配验证码-&gt;用户信息保存到Redis<ul>
<li>校验码的Key是前缀+手机号</li>
<li>用户信息保存方式：String或者Hash类型，Hash类型可以修改用户某些信息，更灵活，用hash保存</li>
<li>用户信息的key是前缀+随机的token</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么需要随机的token？<br>答：因为用户发来请求，服务器需要识别这个请求是哪个用户的，sessionID类似的功能，但是我们又不能直接用手机号识别，对用户信息不安全。于是，可以用一个随机的token，登录成功后返回给客户端，之后每次请求都携带这个token即可。</p>
</blockquote>
<ul>
<li>流程图：<img src="/2024/06/19/redis-1/img6.png" class="" title="img6">
<strong>注意事项：</strong><br>&ensp;&ensp;&ensp;&ensp;登录成功后，用户信息保存在Redis中，但是需要设置过期时间，不然每次登录都会产生一个记录，造成存储空间的浪费。</li>
</ul>
<h3 id="3-验证登录状态"><a href="#3-验证登录状态" class="headerlink" title="3.验证登录状态"></a>3.验证登录状态</h3><ul>
<li>session下：用户传递来sessionID-&gt;session中获取用户信息-&gt;保存到ThreadLocal，便于这个请求处理期间使用；</li>
<li>Redis下：用户请求头携带token-&gt;根据token查找用户信息-&gt;保存到ThreadLocal。</li>
<li>流程图变化：<img src="/2024/06/19/redis-1/img7.png" class="" title="img7">
<strong>注意事项：</strong></li>
<li>验证登录状态是通过拦截器Interceptor实现的，这个实现并不属于Spring框架，是我们自己写的工具。</li>
<li>Interceptor中涉及到了StringRedisTemplate，这个不能用Autowire注解自动注入，需要在LoginInterceptor构造函数中手动注入。</li>
<li>但是LoginInterceptor是在MvcConfig中调用的，所以在MvcConfig中可以自动注入一个Redis工具类，然后传递到Interceptor就行。<blockquote>
<p>为什么需要刷新登录信息有效时间呢？<br>答：因为session的情况下，只要有访问，session的有效时间就是刷新的。但是Redis情况下，用expire设置用户信息过期时间，即使一直在访问，到了时间还是会自动过期，我们希望的是如果有访问，那么就不断刷新过期时间，30min完全没有操作再登录失效。</p>
</blockquote>
</li>
</ul>
<h2 id="四、存在的问题以及优化"><a href="#四、存在的问题以及优化" class="headerlink" title="四、存在的问题以及优化"></a>四、存在的问题以及优化</h2><h3 id="1-登录状态刷新优化"><a href="#1-登录状态刷新优化" class="headerlink" title="1.登录状态刷新优化"></a>1.登录状态刷新优化</h3><p><strong>问题：</strong> 用户登录后访问不被拦截的网页，超过了有效时间，然后再看个人信息，发现登录过期了。造成了不便。<br><strong>改进思路：</strong> 设置两个拦截器，第一个拦截器负责拦截所有请求，对于有登录状态的用户请求则刷新有效时间；第二个拦截器负责给第一个拦截器兜底，第一个拦截器放行了所有的请求，其中有些请求没有登录状态，那么有一些涉及到个人信息的请求还是需要拦截下来并拒绝的。<br><strong>实现效果：</strong> 对于任何请求，只要所属用户处于登录状态，就刷新登录信息的有效时间。</p>
<h3 id="2-将用户信息保存到Redis报错"><a href="#2-将用户信息保存到Redis报错" class="headerlink" title="2.将用户信息保存到Redis报错"></a>2.将用户信息保存到Redis报错</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDTO userDTO= BeanUtil.copyProperties(user,UserDTO.class);</span><br><span class="line">String token= UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//将user对象转换成hash</span></span><br><span class="line">Map&lt;String, Object&gt; hashMap=BeanUtil.beanToMap(userDTO);</span><br><span class="line"><span class="comment">//保存信息到Redis</span></span><br><span class="line">stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token,hashMap);</span><br><span class="line">stringRedisTemplate.expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在上面的代码中,直接将userDTO对象转换成HahMap，但是userDTO中部分字段并不是string类型，比如UID是Long类型，那么就会遇到转换成string类型的fieldValue报错。<br>解决方案是通过hutools提供的选择性拷贝工具copyOptions，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDTO userDTO= BeanUtil.copyProperties(user,UserDTO.class);</span><br><span class="line"><span class="comment">//用户信息保存到Redis中</span></span><br><span class="line"><span class="comment">//生成一个随机的token</span></span><br><span class="line">String token= UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//将user对象转换成hash</span></span><br><span class="line">Map&lt;String, Object&gt; hashMap=BeanUtil.beanToMap(userDTO,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create()</span><br><span class="line">        .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">        .setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line"><span class="comment">//保存信息到Redis</span></span><br><span class="line">stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token,hashMap);</span><br><span class="line">stringRedisTemplate.expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<h3 id="3-个人遇到的bug："><a href="#3-个人遇到的bug：" class="headerlink" title="3.个人遇到的bug："></a>3.个人遇到的bug：</h3><p>&ensp;&ensp;&ensp;&ensp;在编写userService实现类时，类有一个private成员变量stringRedisTemplate，但是我没有用@Resource注解修饰这个类，于是在之后使用这个类时出现了空指针异常。<br>&ensp;&ensp;&ensp;&ensp;原因：在类中注入bean有三种方式，一种是构造函数手动注入，一种是使用注解自动注入。<br><strong>1.</strong> 手动注入，我们在RefreshInterceptor中有用到，构造函数注入StringRedisTemplate对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate=stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong> 通过注解@Resource或者@Autowired注入。这里牵扯到一个八股文，Resource和Autowired的关系：<a href="https://daisybby.github.io/2024/06/20/Resource-and-Autowired/">Resource于Autowired的区别与联系</a></p>
<p>在这部分，似乎对Spring IOC容器对Bean管理的思想理解更加深刻了，相关的笔记待补充。</p>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Resource和Autowired之间的区别与联系</title>
    <url>/2024/06/20/Resource-and-Autowired/</url>
    <content><![CDATA[<h1 id="Resource和Autowired之间的关系"><a href="#Resource和Autowired之间的关系" class="headerlink" title="Resource和Autowired之间的关系"></a>Resource和Autowired之间的关系</h1><h2 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1.相同点"></a>1.相同点</h2><span id="more"></span>
<p>Resource和Autowired都是获取IOC容器中的bean对象。<br>在单例模式下，以下代码获取到的对象是相同的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> User user1;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> User user2;</span><br></pre></td></tr></table></figure>
<h2 id="2-不同点"><a href="#2-不同点" class="headerlink" title="2.不同点"></a>2.不同点</h2><h3 id="2-1-支持方不同"><a href="#2-1-支持方不同" class="headerlink" title="2.1.支持方不同"></a>2.1.支持方不同</h3><ul>
<li><strong>Resource:</strong> 属于JDK，支持更多的参数设置，比如可以设置name和type；所有的IOC容器都支持Resource注解，框架迁移时不需要修改。</li>
<li><strong>Autowired:</strong> 属于Spring框架，其他的框架可能不支持。</li>
</ul>
<h3 id="2-2-匹配顺序不同"><a href="#2-2-匹配顺序不同" class="headerlink" title="2.2.匹配顺序不同"></a>2.2.匹配顺序不同</h3><ul>
<li><strong>Resource:</strong> 名称-&gt;类型；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;BeanOne&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanOne</span> <span class="keyword">implements</span> <span class="title class_">Bean</span> &#123;&#125;</span><br><span class="line"><span class="meta">@Component(&quot;BeanTwo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTwo</span> <span class="keyword">implements</span> <span class="title class_">Bean</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">//1.会报错，先按照type同时匹配到BeanOne和BeanTwo，再按照名称匹配bean，没有name为bean的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.按照type同时匹配到BeanOne和BeanTwo，再按照名称匹配到BeanOne</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用type匹配到beanOne和beanTwo，Qualifier指定了要匹配的名称，匹配到beanOne</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;beanOne&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Autowired:</strong> 类型-&gt;名称；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">//1.先按照name匹配，没有，再按照type匹配到两个，无法确定，报错。</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.按照名称，一次匹配成功</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Bean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.指定匹配类型</span></span><br><span class="line">    <span class="meta">@Resource(type=BeanOne.class)</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论是Resource还是Autowired，匹配都是<strong>不区分大小写</strong>的。</p>
</blockquote>
</li>
</ul>
<h3 id="2-3-作用域不同"><a href="#2-3-作用域不同" class="headerlink" title="2.3.作用域不同"></a>2.3.作用域不同</h3><ul>
<li><strong>Autowired:</strong> 用于setter、构造器、属性。<blockquote>
<p>尽管用于setter时，setter函数有参数，但是并不需要我们显示调用这个setter。</p>
</blockquote>
</li>
<li><strong>Resource:</strong> setter和属性。</li>
</ul>
]]></content>
      <categories>
        <category>Spring基础</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>常用注解</tag>
      </tags>
  </entry>
  <entry>
    <title>setFieldValueEditor出现空指针异常</title>
    <url>/2024/06/21/setFieldValueEditor-bug/</url>
    <content><![CDATA[<h1 id="Hutool提供的BeanUtil-beanToMap出现空指针异常"><a href="#Hutool提供的BeanUtil-beanToMap出现空指针异常" class="headerlink" title="Hutool提供的BeanUtil.beanToMap出现空指针异常"></a>Hutool提供的BeanUtil.beanToMap出现空指针异常</h1><p>先看bug出现的位置：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = BeanUtil.beanToMap(shop, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>) <span class="comment">//忽略空值</span></span><br><span class="line">                .setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(CACHE_SHOP_KEY + id, map);</span><br><span class="line">stringRedisTemplate.expire(CACHE_SHOP_KEY + id, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>以上代码将shop对象以hash形式保存到Redis，但是实际运行时出现了空指针异常。<br>如果shop对象里面有属性值为null，就会出现如下空指针异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NullPointerException: <span class="literal">null</span></span><br><span class="line">	at com.hmdp.service.impl.ShopServiceImpl.lambda$queryById$<span class="number">0</span>(ShopServiceImpl.java:<span class="number">56</span>) ~[classes/:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.CopyOptions.editFieldValue(CopyOptions.java:<span class="number">258</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.BeanCopier.lambda$beanToMap$<span class="number">1</span>(BeanCopier.java:<span class="number">233</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at java.util.LinkedHashMap$LinkedValues.forEach(LinkedHashMap.java:<span class="number">608</span>) ~[na:<span class="number">1.8</span><span class="number">.0_401</span>]</span><br><span class="line">	at cn.hutool.core.bean.BeanUtil.descForEach(BeanUtil.java:<span class="number">182</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.BeanCopier.beanToMap(BeanCopier.java:<span class="number">195</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.BeanCopier.copy(BeanCopier.java:<span class="number">106</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.BeanUtil.beanToMap(BeanUtil.java:<span class="number">690</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br></pre></td></tr></table></figure>
<p><strong>已经设置了setIgnoreNullValue为true，忽略空值，为什么还会出现这个问题？</strong><br>准确来说，报错的地方时fieldValue.toString()，尽管设置了忽略空值，但是fieldValue.toString()还是会执行的，null当然有空指针异常。<br><strong>具体原因：</strong></p>
<ul>
<li>setFieldValueEditor的触发优先级高于setIgnoreNullValue，我们需要在setFieldValueEditor中进行判空;</li>
<li>可能shop部分属性是允许null的，我们希望给一个默认值，如果先执行setIgnoreNullValue，可能会导致这部分属性被过滤掉，不保存到Redis中去。</li>
</ul>
<p><strong>解决方案：</strong><br>我们在setFieldValueEditor中判空处理就行。</p>
<img src="/2024/06/21/setFieldValueEditor-bug/image.png" class="" title="img">
<p>可以看到distance的值是null，我们用默认属性0来替代就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = BeanUtil.beanToMap(shop, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>) <span class="comment">//忽略空值</span></span><br><span class="line">                .setFieldValueEditor((fieldName,fieldValue)-&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(fieldValue==<span class="literal">null</span>)&#123;</span><br><span class="line">                        fieldValue=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        fieldValue=fieldValue.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> fieldValue;</span><br><span class="line">                &#125;));</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(CACHE_SHOP_KEY + id, map);</span><br><span class="line">stringRedisTemplate.expire(CACHE_SHOP_KEY + id, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Bug实录</category>
      </categories>
      <tags>
        <tag>Hutool</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2024/06/22/Bloom-Filter/</url>
    <content><![CDATA[<h1 id="布隆过滤器的概念和原理"><a href="#布隆过滤器的概念和原理" class="headerlink" title="布隆过滤器的概念和原理"></a>布隆过滤器的概念和原理</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><span id="more"></span>
<p>布隆过滤器是一种数据结构，用于快速检索元素是否可能存在于一个集合中。<br>布隆过滤器的两个重要组成：K个hash函数和一个bit数组。</p>
<h2 id="3-布隆过滤器的工作过程"><a href="#3-布隆过滤器的工作过程" class="headerlink" title="3.布隆过滤器的工作过程"></a>3.布隆过滤器的工作过程</h2><p><strong>存储元素</strong><br>对于一个元素item，通过K个hash函数计算出多个hash索引，然后将这些索引对应的位都设置为1，如果这些位置已经为1，不需要再次设置。<br><strong>查询元素</strong><br>判断元素item是否存在，也是检查K个hash函数计算出来的位置是否都为1：</p>
<ul>
<li>如果有0，那这个元素一定不存在。</li>
<li>如果全为1，元素可能存在，也可能不存在。</li>
</ul>
<p>查询时间效率是O(K)，K表示hash函数个数。（可以，这很ok~)<br><strong>删除元素</strong><br>将item对应的hash位置都设置为0。但是这存在问题，如果发生了hash冲突，会误删其他元素。</p>
<img src="/2024/06/22/Bloom-Filter/img1.png" class="" title="img1">

<h2 id="3-布隆过滤器的误判"><a href="#3-布隆过滤器的误判" class="headerlink" title="3.布隆过滤器的误判"></a>3.布隆过滤器的误判</h2><p>为什么全1是“可能”存在，而不是“肯定”存在？<br>有可能根本就不存在”hello”这个单词，但是bit数组中这个单词对应的hash值位置都是1，已经表达了其他的单词，那按照“hash位置全为1则存在”的规则，得到的是”hello”存在的假象。<br>归根结底，布隆过滤器的误判是由hash冲突造成的。想要降低误判概率，主要的办法就是降低hash冲突发生的概率，增加hash算法个数或者扩大bit数组。</p>
<img src="/2024/06/22/Bloom-Filter/img2.png" class="" title="img2">
<p><strong>可以利用布隆过滤器判断不存在，解决缓存穿透恰好就是利用布隆过滤器判断不存在。</strong></p>
<h2 id="4-常见应用"><a href="#4-常见应用" class="headerlink" title="4.常见应用"></a>4.常见应用</h2><ul>
<li><strong>网页爬虫：</strong> 过滤掉已经爬取的网页，避免重复爬取，浪费资源。</li>
<li><strong>缓存系统：</strong> 判断一个查询是否存在于缓存中，减少缓存查询次数。更重要的是，布隆过滤器经常用来解决缓存穿透的问题（判断不存在）。</li>
<li><strong>分布式系统：</strong> 判断元素是否存在于分布式缓存中，避免在所有节点上进行查询，减少网络负载。</li>
<li><strong>垃圾邮件过滤：</strong> 判断邮件地址是否在垃圾邮件列表中。</li>
<li><strong>黑名单过滤：</strong> 判断IP地址或者手机号是否在黑名单中。</li>
</ul>
<h2 id="4-如何使用布隆过滤器"><a href="#4-如何使用布隆过滤器" class="headerlink" title="4.如何使用布隆过滤器"></a>4.如何使用布隆过滤器</h2><h3 id="1-通过Google-Guava库"><a href="#1-通过Google-Guava库" class="headerlink" title="1.通过Google Guava库"></a>1.通过Google Guava库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilterExample</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建布隆过滤器，预计插入100个元素，误判率为1%</span></span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter=BloomFilter.create(Funnels.stringFunnel(),<span class="number">100</span>,<span class="number">0.01</span>);</span><br><span class="line">        </span><br><span class="line">        bloomFilter.put(<span class="string">&quot;Daisybby&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断元素是否存在</span></span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;Daisybby&quot;</span>));</span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;what&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-通过Apache-Commons"><a href="#2-通过Apache-Commons" class="headerlink" title="2.通过Apache Commons"></a>2.通过Apache Commons</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.HashFunctionIdentity;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilterExample</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter=<span class="keyword">new</span> <span class="title class_">BloomFilter</span>&lt;&gt;(HashFunctionIdentity.hashFunction(StringUtils::hashCode),<span class="number">100</span>,<span class="number">0.01</span>);</span><br><span class="line">        </span><br><span class="line">        bloomFilter.put(<span class="string">&quot;Daisybby&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断元素是否存在</span></span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;Daisybby&quot;</span>));</span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;what&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-在Redis中可以通过Bloom模块来使用，使用Redisssion可以："><a href="#3-在Redis中可以通过Bloom模块来使用，使用Redisssion可以：" class="headerlink" title="3.在Redis中可以通过Bloom模块来使用，使用Redisssion可以："></a>3.在Redis中可以通过Bloom模块来使用，使用Redisssion可以：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Config config=<span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson=Redisson.create(config);</span><br><span class="line">RBloomFilter&lt;String&gt; bloomFilter=redisson.getBloomFilter(<span class="string">&quot;myFilter&quot;</span>);</span><br><span class="line">bloomFilter.tryInit(<span class="number">100</span>,<span class="number">0.01</span>);</span><br><span class="line">bloomFilter.add(<span class="string">&quot;Daisybby&quot;</span>);</span><br><span class="line">bloomFilter.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">bloomFilter.add(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(bloomFilter.contains(<span class="string">&quot;Daisybby&quot;</span>));</span><br><span class="line">System.out.println(bloomFilter.contains(<span class="string">&quot;what&quot;</span>));</span><br><span class="line">redisson.shutdown();</span><br></pre></td></tr></table></figure>
<p>Jedis也可以，不再赘述。</p>
]]></content>
      <categories>
        <category>基础概念和原理</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis保存对象为String还是hash？</title>
    <url>/2024/06/23/save-object-as-string-or-hash/</url>
    <content><![CDATA[<h1 id="1-对象序列化后保存到Redis"><a href="#1-对象序列化后保存到Redis" class="headerlink" title="1.对象序列化后保存到Redis"></a>1.对象序列化后保存到Redis</h1><p>保存的是序列化后的对象，这种方式在Redis中很难看出来对象的含义。</p>
<span id="more"></span>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁性：</strong> 直接序列化整个对象，不需要考虑字段的单独存储。</li>
<li><strong>原子性：</strong> 对整个对象进行存取。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>序列化依赖：</strong> 依赖于特定的序列化库，可能影响性能和跨语言使用。</li>
<li><strong>可读性：</strong> 二进制格式的字符串不易于阅读和调试。</li>
<li><strong>灵活性差：</strong> 如果对象结构发生变化，需要重新序列化。</li>
</ul>
<h1 id="2-将对象转换成Json格式"><a href="#2-将对象转换成Json格式" class="headerlink" title="2.将对象转换成Json格式"></a>2.将对象转换成Json格式</h1><p>Redis中保存的是JSON格式的字符串，可以清晰阅读对象的内容。<br><strong>优点：</strong> </p>
<ul>
<li><strong>跨语言性：</strong> JSON是一种跨语言的格式，易于在不同语言和系统之间交换数据。</li>
<li><strong>可读性：</strong> JSON格式的数据易于阅读。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>灵活性：</strong>不支持对象单个属性的存取，如果要修改对象属性只能整个对象读取修改重建。</li>
<li><strong>复杂结构存储：</strong>不适合存储复杂的对象结构，比如对象存在嵌套。</li>
</ul>
<h1 id="3-用hash存储对象"><a href="#3-用hash存储对象" class="headerlink" title="3.用hash存储对象"></a>3.用hash存储对象</h1><p>Redis的key作为整个hash结构在Redis中的索引；<br>fieldName是对象的属性名称；<br>fieldValue就是属性值。<br><strong>优点：</strong></p>
<ul>
<li><strong>可读性：</strong>hash保存对象结构清晰；</li>
<li><strong>灵活性：</strong>支持对单个属性的操作，只需要根据对应的fieldName来设置fieldValue即可。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>处理嵌套的对象比较麻烦。</li>
</ul>
<h1 id="4-怎么选取呢？"><a href="#4-怎么选取呢？" class="headerlink" title="4.怎么选取呢？"></a>4.怎么选取呢？</h1><p><strong>更新频繁的数据：</strong> 可以通过hash结构存储对象。<br><strong>读频繁的数据：</strong> 对于更新频率比较低，但是读取比较频繁的数据，选择string是比较好的方案。</p>
<blockquote>
<p>实际业务开发中，可以结合string和hash。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础概念和原理</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
