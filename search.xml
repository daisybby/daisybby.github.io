<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>first-blog</title>
    <url>/2024/06/16/first-blog/</url>
    <content><![CDATA[<h1 id="通过hexo、Node-js和igthub搭建个人博客"><a href="#通过hexo、Node-js和igthub搭建个人博客" class="headerlink" title="通过hexo、Node js和igthub搭建个人博客"></a>通过hexo、Node js和igthub搭建个人博客</h1><h2 id="01环境配置"><a href="#01环境配置" class="headerlink" title="01环境配置"></a>01环境配置</h2><h3 id="1-1安装git"><a href="#1-1安装git" class="headerlink" title="1.1安装git"></a>1.1安装git</h3><img src="/daisybby.github.io/2024/06/16/first-blog/06/16/first-blog/header.jpg" class title="header">]]></content>
      <categories>
        <category>-其他</category>
      </categories>
  </entry>
  <entry>
    <title>Redis注册为windows服务</title>
    <url>/2024/06/17/Redis%E6%B3%A8%E5%86%8C%E4%B8%BAwindows%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>安装完Redis需要用命令行启动，而且要保持这个窗口不关闭。</p>
<span id="more"></span>
<p>注册为windows服务后不再受控制台的影响。<br><strong>控制台输入：</strong><br><code>redis-server.exe --service-install redis.windows.conf </code><br><strong>开启Redis服务:</strong><br>控制台输入：<code>redis-server --service-start</code></p>
<blockquote>
<p>注意：在redis安装目录下进入cmd就能打开控制台。</p>
</blockquote>
]]></content>
      <categories>
        <category>-环境配置</category>
      </categories>
  </entry>
  <entry>
    <title>session、cookie和token</title>
    <url>/2024/06/18/session%E3%80%81cookie%E5%92%8Ctoken/</url>
    <content><![CDATA[<h1 id="session、cookie和token"><a href="#session、cookie和token" class="headerlink" title="session、cookie和token"></a>session、cookie和token</h1><ul>
<li>cookie：保存在客户端，用来解决客户端保存信息的问题。</li>
<li>session：保存在服务器端，每个客户端对应一个session。</li>
<li>token：无状态且跨域，能够有效防御CSRF，解决session依赖单个服务器的问题。</li>
</ul>
<span id="more"></span>
<h2 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h2><p>浏览器可以将服务器端发送的信息保存到cookie中，在浏览器之后每次发送请求时，可以将存活的cookie放到请求头一起发送给服务器端。</p>
<img src="/daisybby.github.io/2024/06/18/session%E3%80%81cookie%E5%92%8Ctoken/06/18/session%E3%80%81cookie%E5%92%8Ctoken/cookie%E5%92%8Csession%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="img1">
<h2 id="2-session"><a href="#2-session" class="headerlink" title="2.session"></a>2.session</h2><p>&ensp;&ensp;客户端向服务端发送请求，服务端为这个请求开辟一块内存空间，即session对象，保存方式为ConcurrentHashMap。<br>&ensp;&ensp;服务器端会为session设置过期时间，避免堆积大量session。（但在高并发场景下还是会有大量session，占据存储空间）<br>session和cookie协作的详细流程：</p>
<ul>
<li>step1:客户端发送http请求</li>
<li>step2:服务端创建session对象，将sessionID通过响应头的set-Cookie命令设置到cookie中。</li>
<li>step3:在浏览器会话期间，cookie都被保存到浏览器，之后每次浏览器发送请求都携带cookie。</li>
<li>step4:服务器通过请求携带的cookie解析出sessionID，找到对应的session。</li>
</ul>
<h2 id="3-token"><a href="#3-token" class="headerlink" title="3.token"></a>3.token</h2><p>出现token是因为cookie不支持跨域访问。<br><strong>token的工作原理：</strong></p>
<ul>
<li>客户端发送登录请求，将用户名和密码传递到服务器。</li>
<li>服务器验证用户信息通过，签发一个token，token中包含用户信息，token发送给客户端。</li>
<li>客户端接收到token保存到cookie或者Local Storage中，之后每次请求都携带token。</li>
<li>服务器受到请求后，解析验证token，验证通过即可放行。</li>
</ul>
<p>token模式下，服务器是不需要保存session的，因为token中包含有用户信息，解析出来利用即可。<br>更多内容等做到项目的权限管理模块，详细记录。</p>
]]></content>
      <categories>
        <category>-基础概念和原理</category>
      </categories>
      <tags>
        <tag>-Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>LC39组合总和</title>
    <url>/2024/06/18/LC39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>-刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Redis实战项目笔记一：短信登录</title>
    <url>/2024/06/19/Redis%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="笔记一：短信验证登录"><a href="#笔记一：短信验证登录" class="headerlink" title="笔记一：短信验证登录"></a>笔记一：短信验证登录</h1><p><strong>三个关键功能：</strong><br>1.用户提供手机号，获取6位数字验证码；</p>
<span id="more"></span>
<p>2.用户提供手机号和验证码，进行登录；<br>3.对于用户请求，验证用户登录状态。</p>
<h2 id="一、业务逻辑"><a href="#一、业务逻辑" class="headerlink" title="一、业务逻辑"></a>一、业务逻辑</h2><h3 id="1-获取验证码"><a href="#1-获取验证码" class="headerlink" title="1.获取验证码"></a>1.获取验证码</h3><p>参数：用户手机号<br>返回：6位数字验证码<br>关键点就是要<strong>校验手机号格式</strong>、<strong>验证码保存到session</strong>中以备后续验证。</p>
<img src="/daisybby.github.io/2024/06/19/Redis%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/06/19/Redis%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/img1.png" class title="img1">

<h3 id="2-验证码登录"><a href="#2-验证码登录" class="headerlink" title="2.验证码登录"></a>2.验证码登录</h3><ol>
<li>用户提供手机号和验证码</li>
<li>信息校验：验证码匹配</li>
<li>校验手机号格式：虽然生成验证码时已经校验过，但用户在登陆时输入的手机号依然存在错误的可能性。</li>
<li>根据手机号查找用户信息，有则信息保存到session（便于后续登录验证）</li>
<li>用户不存在则创建新用户。</li>
</ol>
<img src="/daisybby.github.io/2024/06/19/Redis%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/06/19/Redis%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/img2.png" class title="img2">

<h3 id="3-登录状态检查"><a href="#3-登录状态检查" class="headerlink" title="3.登录状态检查"></a>3.登录状态检查</h3><p><strong>1.对于用户发来的请求，检查用户是否已经登录。</strong></p>
<ol>
<li>用户发来请求，请求携带cookie</li>
<li>根据cookie中的sessionID查找到对应的session（不需要后端程序员实现）</li>
<li>检查session中是否有用户信息，有则将用户信息保存到threadLocal（关键点）</li>
<li>session中没有用户信息，说明用户没有登录。</li>
</ol>
<p><img src="/daisybby.github.io/2024/06/19/Redis%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/img1.png" alt="img3"></p>
<p><strong>2.什么时候验证用户登录状态？</strong><br>在请求到达服务器后，在调用对应的controller处理方法之前。那怎么实现？可以用过滤器和拦截器（详见<a href="https://zhuanlan.zhihu.com/p/697414738">过滤器和拦截器的区别与联系</a>）。<br><strong>3.验证后要做什么？为什么要用ThreadLocal，而不是将用户信息保持在session中？</strong><br>如果session中有用户信息，那这个信息就是登录时保存到session中的，说明已经登录过了。我们在从session中获取信息时，需要将HttpSession对象传递到方法中，如果在之后的service等多处还需要用户信息，会出现频繁传递session对象的问题，而且在高并发场景下，可能会出现session混乱。<br>在服务器端，每个请求对应一个线程，那么我们可以将用户信息保存成线程内部全局可见的，即ThreadLocal的形式。线程可以全局获取用户信息，提高开发效率。<br><strong>4.注意事项</strong><br>ThreadLocal也有缺点：</p>
<ul>
<li><strong>内存泄漏：</strong> ThreadLocal和线程是绑定的，线程一直存在，那么这部分内存一直占用，如果线程数量过多，可能会占据较大内存空间；如果不及时清理这部分空间，可能会导致内存泄漏。<blockquote>
<p>内存泄漏：内存因为一些原因没有释放或者无法释放，就是内存泄漏。</p>
</blockquote>
</li>
<li><strong>上下文切换问题：</strong> 每个线程可能都有自己的本地变量，当需要在线程间共享数据时，可能涉及到线程上下文切换，增加程序的复杂性和开销。</li>
</ul>
]]></content>
      <categories>
        <category>-Redis项目笔记</category>
      </categories>
  </entry>
</search>
