<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis注册为windows服务</title>
    <url>/2024/06/17/Redis%E6%B3%A8%E5%86%8C%E4%B8%BAwindows%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>安装完Redis需要用命令行启动，而且要保持这个窗口不关闭。</p>
<span id="more"></span>
<p>注册为windows服务后不再受控制台的影响。<br><strong>控制台输入：</strong><br><code>redis-server.exe --service-install redis.windows.conf </code><br><strong>开启Redis服务:</strong><br>控制台输入：<code>redis-server --service-start</code></p>
<blockquote>
<p>注意：在redis安装目录下进入cmd就能打开控制台。</p>
</blockquote>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
  </entry>
  <entry>
    <title>session、cookie和token</title>
    <url>/2024/06/18/session%E3%80%81cookie%E5%92%8Ctoken/</url>
    <content><![CDATA[<h1 id="session、cookie和token"><a href="#session、cookie和token" class="headerlink" title="session、cookie和token"></a>session、cookie和token</h1><ul>
<li>cookie：保存在客户端，用来解决客户端保存信息的问题。</li>
<li>session：保存在服务器端，每个客户端对应一个session。</li>
<li>token：无状态且跨域，能够有效防御CSRF，解决session依赖单个服务器的问题。</li>
</ul>
<span id="more"></span>
<h2 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h2><p>浏览器可以将服务器端发送的信息保存到cookie中，在浏览器之后每次发送请求时，可以将存活的cookie放到请求头一起发送给服务器端。</p>
<img src="/2024/06/18/session%E3%80%81cookie%E5%92%8Ctoken/cookie-and-session.png" class="" title="img1">
<h2 id="2-session"><a href="#2-session" class="headerlink" title="2.session"></a>2.session</h2><p>&ensp;&ensp;客户端向服务端发送请求，服务端为这个请求开辟一块内存空间，即session对象，保存方式为ConcurrentHashMap。<br>&ensp;&ensp;服务器端会为session设置过期时间，避免堆积大量session。（但在高并发场景下还是会有大量session，占据存储空间）<br>session和cookie协作的详细流程：</p>
<ul>
<li>step1:客户端发送http请求</li>
<li>step2:服务端创建session对象，将sessionID通过响应头的set-Cookie命令设置到cookie中。</li>
<li>step3:在浏览器会话期间，cookie都被保存到浏览器，之后每次浏览器发送请求都携带cookie。</li>
<li>step4:服务器通过请求携带的cookie解析出sessionID，找到对应的session。</li>
</ul>
<h2 id="3-token"><a href="#3-token" class="headerlink" title="3.token"></a>3.token</h2><p>出现token是因为cookie不支持跨域访问。<br><strong>token的工作原理：</strong></p>
<ul>
<li>客户端发送登录请求，将用户名和密码传递到服务器。</li>
<li>服务器验证用户信息通过，签发一个token，token中包含用户信息，token发送给客户端。</li>
<li>客户端接收到token保存到cookie或者Local Storage中，之后每次请求都携带token。</li>
<li>服务器受到请求后，解析验证token，验证通过即可放行。</li>
</ul>
<p>token模式下，服务器是不需要保存session的，因为token中包含有用户信息，解析出来利用即可。<br>更多内容等做到项目的权限管理模块，详细记录。</p>
]]></content>
      <categories>
        <category>基础概念和原理</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战项目笔记一：短信登录</title>
    <url>/2024/06/19/redis-1/</url>
    <content><![CDATA[<h1 id="笔记一：短信验证登录"><a href="#笔记一：短信验证登录" class="headerlink" title="笔记一：短信验证登录"></a>笔记一：短信验证登录</h1><p><strong>三个关键功能：</strong></p>
<span id="more"></span>
<p>1.用户提供手机号，获取6位数字验证码；</p>
<!--more-->
<p>2.用户提供手机号和验证码，进行登录；<br>3.对于用户请求，验证用户登录状态。</p>
<h2 id="一、业务逻辑"><a href="#一、业务逻辑" class="headerlink" title="一、业务逻辑"></a>一、业务逻辑</h2><h3 id="1-获取验证码"><a href="#1-获取验证码" class="headerlink" title="1.获取验证码"></a>1.获取验证码</h3><p>参数：用户手机号<br>返回：6位数字验证码<br>关键点就是要<strong>校验手机号格式</strong>、<strong>验证码保存到session</strong>中以备后续验证。</p>
<img src="/2024/06/19/redis-1/img1.png" class="" title="img1">

<h3 id="2-验证码登录"><a href="#2-验证码登录" class="headerlink" title="2.验证码登录"></a>2.验证码登录</h3><ol>
<li>用户提供手机号和验证码</li>
<li>信息校验：验证码匹配</li>
<li>校验手机号格式：虽然生成验证码时已经校验过，但用户在登陆时输入的手机号依然存在错误的可能性。</li>
<li>根据手机号查找用户信息，有则信息保存到session（便于后续登录验证）</li>
<li>用户不存在则创建新用户。</li>
</ol>
<img src="/2024/06/19/redis-1/img2.png" class="" title="img2">

<h3 id="3-登录状态检查"><a href="#3-登录状态检查" class="headerlink" title="3.登录状态检查"></a>3.登录状态检查</h3><p><strong>1.对于用户发来的请求，检查用户是否已经登录。</strong></p>
<ol>
<li>用户发来请求，请求携带cookie</li>
<li>根据cookie中的sessionID查找到对应的session（不需要后端程序员实现）</li>
<li>检查session中是否有用户信息，有则将用户信息保存到threadLocal（关键点）</li>
<li>session中没有用户信息，说明用户没有登录。</li>
</ol>
<img src="/2024/06/19/redis-1/img3.png" class="" title="img3">

<p><strong>2.什么时候验证用户登录状态？</strong><br>在请求到达服务器后，在调用对应的controller处理方法之前。那怎么实现？可以用过滤器和拦截器（详见<a href="https://zhuanlan.zhihu.com/p/697414738">过滤器和拦截器的区别与联系</a>）。<br><strong>3.验证后要做什么？为什么要用ThreadLocal，而不是将用户信息保持在session中？</strong><br>如果session中有用户信息，那这个信息就是登录时保存到session中的，说明已经登录过了。我们在从session中获取信息时，需要将HttpSession对象传递到方法中，如果在之后的service等多处还需要用户信息，会出现频繁传递session对象的问题，而且在高并发场景下，可能会出现session混乱。<br>在服务器端，每个请求对应一个线程，那么我们可以将用户信息保存成线程内部全局可见的，即ThreadLocal的形式。线程可以全局获取用户信息，提高开发效率。<br><strong>4.注意事项</strong><br>ThreadLocal也有缺点：</p>
<ul>
<li><strong>内存泄漏：</strong> ThreadLocal和线程是绑定的，线程一直存在，那么这部分内存一直占用，如果线程数量过多，可能会占据较大内存空间；如果不及时清理这部分空间，可能会导致内存泄漏。<blockquote>
<p>内存泄漏：内存因为一些原因没有释放或者无法释放，就是内存泄漏。</p>
</blockquote>
</li>
<li><strong>上下文切换问题：</strong> 每个线程可能都有自己的本地变量，当需要在线程间共享数据时，可能涉及到线程上下文切换，增加程序的复杂性和开销。</li>
</ul>
<blockquote>
<p><strong>一定要在请求处理完毕之后，将用户信息从threadLocal释放。</strong></p>
</blockquote>
<p><strong>5.拦截器和过滤器的区别是什么？</strong></p>
<img src="/2024/06/19/redis-1/img4.png" class="" title="img4">
<ul>
<li>Filter可以拦截一切请求，通常是筛选掉一些不和要求的请求；</li>
<li>Interceptor可以设置在请求被处理之前、被处理之后，或者是对请求到达controller之后，对返回的结果进行处理。可以调用业务逻辑！</li>
</ul>
<h2 id="二、session存在的问题"><a href="#二、session存在的问题" class="headerlink" title="二、session存在的问题"></a>二、session存在的问题</h2><ul>
<li>登录后用户信息暂存在session中，在高并发场景下需要较大的内存开销；</li>
<li>session是不能被多个tomcat服务器共享的，在分布式场景下session共享比较麻烦。<br><strong>session的作用是什么？</strong></li>
<li>基于内存的，访问速度快。</li>
<li>记录登录后的用户信息，保持登录状态。</li>
<li>需要多服务器都能够访问。<br>因此，可以用<strong>Redis</strong>来满足以上需求。</li>
</ul>
<h2 id="三、使用Redis优化登录验证"><a href="#三、使用Redis优化登录验证" class="headerlink" title="三、使用Redis优化登录验证"></a>三、使用Redis优化登录验证</h2><h3 id="1-生成验证码"><a href="#1-生成验证码" class="headerlink" title="1.生成验证码"></a>1.生成验证码</h3><ul>
<li>session下：验证码保存在session中，用sessionID标识唯一；</li>
<li>Redis下：验证码保存在Redis数据库，用Key标识，一个手机号对应一个验证码，故key用手机号。但是为了开发的便利性和直观性，需要在phone之前添加前缀（这是一种数据保存思想）。</li>
<li>更新后的流程图：<img src="/2024/06/19/redis-1/img5.png" class="" title="img5">
&ensp;&ensp;&ensp;&ensp;校验码需要设置<strong>过期时间</strong>，否则可能出现大量废弃校验码堆积，造成存储空间的浪费。</li>
</ul>
<h3 id="2-用户登录"><a href="#2-用户登录" class="headerlink" title="2.用户登录"></a>2.用户登录</h3><ul>
<li>session下：从session获取验证码-&gt;匹配验证码-&gt;用户信息保存到session；</li>
<li>Redis下：从Redis获取验证码-&gt;匹配验证码-&gt;用户信息保存到Redis<ul>
<li>校验码的Key是前缀+手机号</li>
<li>用户信息保存方式：String或者Hash类型，Hash类型可以修改用户某些信息，更灵活，用hash保存</li>
<li>用户信息的key是前缀+随机的token</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么需要随机的token？<br>答：因为用户发来请求，服务器需要识别这个请求是哪个用户的，sessionID类似的功能，但是我们又不能直接用手机号识别，对用户信息不安全。于是，可以用一个随机的token，登录成功后返回给客户端，之后每次请求都携带这个token即可。</p>
</blockquote>
<ul>
<li>流程图：<img src="/2024/06/19/redis-1/img6.png" class="" title="img6">
<strong>注意事项：</strong><br>&ensp;&ensp;&ensp;&ensp;登录成功后，用户信息保存在Redis中，但是需要设置过期时间，不然每次登录都会产生一个记录，造成存储空间的浪费。</li>
</ul>
<h3 id="3-验证登录状态"><a href="#3-验证登录状态" class="headerlink" title="3.验证登录状态"></a>3.验证登录状态</h3><ul>
<li>session下：用户传递来sessionID-&gt;session中获取用户信息-&gt;保存到ThreadLocal，便于这个请求处理期间使用；</li>
<li>Redis下：用户请求头携带token-&gt;根据token查找用户信息-&gt;保存到ThreadLocal。</li>
<li>流程图变化：<img src="/2024/06/19/redis-1/img7.png" class="" title="img7">
<strong>注意事项：</strong></li>
<li>验证登录状态是通过拦截器Interceptor实现的，这个实现并不属于Spring框架，是我们自己写的工具。</li>
<li>Interceptor中涉及到了StringRedisTemplate，这个不能用Autowire注解自动注入，需要在LoginInterceptor构造函数中手动注入。</li>
<li>但是LoginInterceptor是在MvcConfig中调用的，所以在MvcConfig中可以自动注入一个Redis工具类，然后传递到Interceptor就行。<blockquote>
<p>为什么需要刷新登录信息有效时间呢？<br>答：因为session的情况下，只要有访问，session的有效时间就是刷新的。但是Redis情况下，用expire设置用户信息过期时间，即使一直在访问，到了时间还是会自动过期，我们希望的是如果有访问，那么就不断刷新过期时间，30min完全没有操作再登录失效。</p>
</blockquote>
</li>
</ul>
<h2 id="四、存在的问题以及优化"><a href="#四、存在的问题以及优化" class="headerlink" title="四、存在的问题以及优化"></a>四、存在的问题以及优化</h2><h3 id="1-登录状态刷新优化"><a href="#1-登录状态刷新优化" class="headerlink" title="1.登录状态刷新优化"></a>1.登录状态刷新优化</h3><p><strong>问题：</strong> 用户登录后访问不被拦截的网页，超过了有效时间，然后再看个人信息，发现登录过期了。造成了不便。<br><strong>改进思路：</strong> 设置两个拦截器，第一个拦截器负责拦截所有请求，对于有登录状态的用户请求则刷新有效时间；第二个拦截器负责给第一个拦截器兜底，第一个拦截器放行了所有的请求，其中有些请求没有登录状态，那么有一些涉及到个人信息的请求还是需要拦截下来并拒绝的。<br><strong>实现效果：</strong> 对于任何请求，只要所属用户处于登录状态，就刷新登录信息的有效时间。</p>
<h3 id="2-将用户信息保存到Redis报错"><a href="#2-将用户信息保存到Redis报错" class="headerlink" title="2.将用户信息保存到Redis报错"></a>2.将用户信息保存到Redis报错</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDTO userDTO= BeanUtil.copyProperties(user,UserDTO.class);</span><br><span class="line">String token= UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//将user对象转换成hash</span></span><br><span class="line">Map&lt;String, Object&gt; hashMap=BeanUtil.beanToMap(userDTO);</span><br><span class="line"><span class="comment">//保存信息到Redis</span></span><br><span class="line">stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token,hashMap);</span><br><span class="line">stringRedisTemplate.expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在上面的代码中,直接将userDTO对象转换成HahMap，但是userDTO中部分字段并不是string类型，比如UID是Long类型，那么就会遇到转换成string类型的fieldValue报错。<br>解决方案是通过hutools提供的选择性拷贝工具copyOptions，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDTO userDTO= BeanUtil.copyProperties(user,UserDTO.class);</span><br><span class="line"><span class="comment">//用户信息保存到Redis中</span></span><br><span class="line"><span class="comment">//生成一个随机的token</span></span><br><span class="line">String token= UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//将user对象转换成hash</span></span><br><span class="line">Map&lt;String, Object&gt; hashMap=BeanUtil.beanToMap(userDTO,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create()</span><br><span class="line">        .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">        .setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line"><span class="comment">//保存信息到Redis</span></span><br><span class="line">stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token,hashMap);</span><br><span class="line">stringRedisTemplate.expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<h3 id="3-个人遇到的bug："><a href="#3-个人遇到的bug：" class="headerlink" title="3.个人遇到的bug："></a>3.个人遇到的bug：</h3><p>&ensp;&ensp;&ensp;&ensp;在编写userService实现类时，类有一个private成员变量stringRedisTemplate，但是我没有用@Resource注解修饰这个类，于是在之后使用这个类时出现了空指针异常。<br>&ensp;&ensp;&ensp;&ensp;原因：在类中注入bean有三种方式，一种是构造函数手动注入，一种是使用注解自动注入。<br><strong>1.</strong> 手动注入，我们在RefreshInterceptor中有用到，构造函数注入StringRedisTemplate对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate=stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong> 通过注解@Resource或者@Autowired注入。这里牵扯到一个八股文，Resource和Autowired的关系：<a href="https://daisybby.github.io/2024/06/20/Resource-and-Autowired/">Resource于Autowired的区别与联系</a></p>
<p>在这部分，似乎对Spring IOC容器对Bean管理的思想理解更加深刻了，相关的笔记待补充。</p>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Resource和Autowired之间的区别与联系</title>
    <url>/2024/06/20/Resource-and-Autowired/</url>
    <content><![CDATA[<h1 id="Resource和Autowired之间的关系"><a href="#Resource和Autowired之间的关系" class="headerlink" title="Resource和Autowired之间的关系"></a>Resource和Autowired之间的关系</h1><h2 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1.相同点"></a>1.相同点</h2><span id="more"></span>
<p>Resource和Autowired都是获取IOC容器中的bean对象。<br>在单例模式下，以下代码获取到的对象是相同的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> User user1;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> User user2;</span><br></pre></td></tr></table></figure>
<h2 id="2-不同点"><a href="#2-不同点" class="headerlink" title="2.不同点"></a>2.不同点</h2><h3 id="2-1-支持方不同"><a href="#2-1-支持方不同" class="headerlink" title="2.1.支持方不同"></a>2.1.支持方不同</h3><ul>
<li><strong>Resource:</strong> 属于JDK，支持更多的参数设置，比如可以设置name和type；所有的IOC容器都支持Resource注解，框架迁移时不需要修改。</li>
<li><strong>Autowired:</strong> 属于Spring框架，其他的框架可能不支持。</li>
</ul>
<h3 id="2-2-匹配顺序不同"><a href="#2-2-匹配顺序不同" class="headerlink" title="2.2.匹配顺序不同"></a>2.2.匹配顺序不同</h3><ul>
<li><strong>Resource:</strong> 名称-&gt;类型；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;BeanOne&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanOne</span> <span class="keyword">implements</span> <span class="title class_">Bean</span> &#123;&#125;</span><br><span class="line"><span class="meta">@Component(&quot;BeanTwo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTwo</span> <span class="keyword">implements</span> <span class="title class_">Bean</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">//1.会报错，先按照type同时匹配到BeanOne和BeanTwo，再按照名称匹配bean，没有name为bean的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.按照type同时匹配到BeanOne和BeanTwo，再按照名称匹配到BeanOne</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用type匹配到beanOne和beanTwo，Qualifier指定了要匹配的名称，匹配到beanOne</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;beanOne&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Autowired:</strong> 类型-&gt;名称；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">//1.先按照name匹配，没有，再按照type匹配到两个，无法确定，报错。</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.按照名称，一次匹配成功</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Bean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.指定匹配类型</span></span><br><span class="line">    <span class="meta">@Resource(type=BeanOne.class)</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论是Resource还是Autowired，匹配都是<strong>不区分大小写</strong>的。</p>
</blockquote>
</li>
</ul>
<h3 id="2-3-作用域不同"><a href="#2-3-作用域不同" class="headerlink" title="2.3.作用域不同"></a>2.3.作用域不同</h3><ul>
<li><strong>Autowired:</strong> 用于setter、构造器、属性。<blockquote>
<p>尽管用于setter时，setter函数有参数，但是并不需要我们显示调用这个setter。</p>
</blockquote>
</li>
<li><strong>Resource:</strong> setter和属性。</li>
</ul>
]]></content>
      <categories>
        <category>Spring基础</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>常用注解</tag>
      </tags>
  </entry>
  <entry>
    <title>setFieldValueEditor出现空指针异常</title>
    <url>/2024/06/21/setFieldValueEditor-bug/</url>
    <content><![CDATA[<h1 id="Hutool提供的BeanUtil-beanToMap出现空指针异常"><a href="#Hutool提供的BeanUtil-beanToMap出现空指针异常" class="headerlink" title="Hutool提供的BeanUtil.beanToMap出现空指针异常"></a>Hutool提供的BeanUtil.beanToMap出现空指针异常</h1><p>先看bug出现的位置：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = BeanUtil.beanToMap(shop, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>) <span class="comment">//忽略空值</span></span><br><span class="line">                .setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(CACHE_SHOP_KEY + id, map);</span><br><span class="line">stringRedisTemplate.expire(CACHE_SHOP_KEY + id, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>以上代码将shop对象以hash形式保存到Redis，但是实际运行时出现了空指针异常。<br>如果shop对象里面有属性值为null，就会出现如下空指针异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NullPointerException: <span class="literal">null</span></span><br><span class="line">	at com.hmdp.service.impl.ShopServiceImpl.lambda$queryById$<span class="number">0</span>(ShopServiceImpl.java:<span class="number">56</span>) ~[classes/:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.CopyOptions.editFieldValue(CopyOptions.java:<span class="number">258</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.BeanCopier.lambda$beanToMap$<span class="number">1</span>(BeanCopier.java:<span class="number">233</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at java.util.LinkedHashMap$LinkedValues.forEach(LinkedHashMap.java:<span class="number">608</span>) ~[na:<span class="number">1.8</span><span class="number">.0_401</span>]</span><br><span class="line">	at cn.hutool.core.bean.BeanUtil.descForEach(BeanUtil.java:<span class="number">182</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.BeanCopier.beanToMap(BeanCopier.java:<span class="number">195</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.BeanCopier.copy(BeanCopier.java:<span class="number">106</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.BeanUtil.beanToMap(BeanUtil.java:<span class="number">690</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br></pre></td></tr></table></figure>
<p><strong>已经设置了setIgnoreNullValue为true，忽略空值，为什么还会出现这个问题？</strong><br>准确来说，报错的地方时fieldValue.toString()，尽管设置了忽略空值，但是fieldValue.toString()还是会执行的，null当然有空指针异常。<br><strong>具体原因：</strong></p>
<ul>
<li>setFieldValueEditor的触发优先级高于setIgnoreNullValue，我们需要在setFieldValueEditor中进行判空;</li>
<li>可能shop部分属性是允许null的，我们希望给一个默认值，如果先执行setIgnoreNullValue，可能会导致这部分属性被过滤掉，不保存到Redis中去。</li>
</ul>
<p><strong>解决方案：</strong><br>我们在setFieldValueEditor中判空处理就行。</p>
<img src="/2024/06/21/setFieldValueEditor-bug/image.png" class="" title="img">
<p>可以看到distance的值是null，我们用默认属性0来替代就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = BeanUtil.beanToMap(shop, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>) <span class="comment">//忽略空值</span></span><br><span class="line">                .setFieldValueEditor((fieldName,fieldValue)-&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(fieldValue==<span class="literal">null</span>)&#123;</span><br><span class="line">                        fieldValue=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        fieldValue=fieldValue.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> fieldValue;</span><br><span class="line">                &#125;));</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(CACHE_SHOP_KEY + id, map);</span><br><span class="line">stringRedisTemplate.expire(CACHE_SHOP_KEY + id, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Bug实录</category>
      </categories>
      <tags>
        <tag>Hutool</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2024/06/22/Bloom-Filter/</url>
    <content><![CDATA[<h1 id="布隆过滤器的概念和原理"><a href="#布隆过滤器的概念和原理" class="headerlink" title="布隆过滤器的概念和原理"></a>布隆过滤器的概念和原理</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><span id="more"></span>
<p>布隆过滤器是一种数据结构，用于快速检索元素是否可能存在于一个集合中。<br>布隆过滤器的两个重要组成：K个hash函数和一个bit数组。</p>
<h2 id="3-布隆过滤器的工作过程"><a href="#3-布隆过滤器的工作过程" class="headerlink" title="3.布隆过滤器的工作过程"></a>3.布隆过滤器的工作过程</h2><p><strong>存储元素</strong><br>对于一个元素item，通过K个hash函数计算出多个hash索引，然后将这些索引对应的位都设置为1，如果这些位置已经为1，不需要再次设置。<br><strong>查询元素</strong><br>判断元素item是否存在，也是检查K个hash函数计算出来的位置是否都为1：</p>
<ul>
<li>如果有0，那这个元素一定不存在。</li>
<li>如果全为1，元素可能存在，也可能不存在。</li>
</ul>
<p>查询时间效率是O(K)，K表示hash函数个数。（可以，这很ok~)<br><strong>删除元素</strong><br>将item对应的hash位置都设置为0。但是这存在问题，如果发生了hash冲突，会误删其他元素。</p>
<img src="/2024/06/22/Bloom-Filter/img1.png" class="" title="img1">

<h2 id="3-布隆过滤器的误判"><a href="#3-布隆过滤器的误判" class="headerlink" title="3.布隆过滤器的误判"></a>3.布隆过滤器的误判</h2><p>为什么全1是“可能”存在，而不是“肯定”存在？<br>有可能根本就不存在”hello”这个单词，但是bit数组中这个单词对应的hash值位置都是1，已经表达了其他的单词，那按照“hash位置全为1则存在”的规则，得到的是”hello”存在的假象。<br>归根结底，布隆过滤器的误判是由hash冲突造成的。想要降低误判概率，主要的办法就是降低hash冲突发生的概率，增加hash算法个数或者扩大bit数组。</p>
<img src="/2024/06/22/Bloom-Filter/img2.png" class="" title="img2">
<p><strong>可以利用布隆过滤器判断不存在，解决缓存穿透恰好就是利用布隆过滤器判断不存在。</strong></p>
<h2 id="4-常见应用"><a href="#4-常见应用" class="headerlink" title="4.常见应用"></a>4.常见应用</h2><ul>
<li><strong>网页爬虫：</strong> 过滤掉已经爬取的网页，避免重复爬取，浪费资源。</li>
<li><strong>缓存系统：</strong> 判断一个查询是否存在于缓存中，减少缓存查询次数。更重要的是，布隆过滤器经常用来解决缓存穿透的问题（判断不存在）。</li>
<li><strong>分布式系统：</strong> 判断元素是否存在于分布式缓存中，避免在所有节点上进行查询，减少网络负载。</li>
<li><strong>垃圾邮件过滤：</strong> 判断邮件地址是否在垃圾邮件列表中。</li>
<li><strong>黑名单过滤：</strong> 判断IP地址或者手机号是否在黑名单中。</li>
</ul>
<h2 id="4-如何使用布隆过滤器"><a href="#4-如何使用布隆过滤器" class="headerlink" title="4.如何使用布隆过滤器"></a>4.如何使用布隆过滤器</h2><h3 id="1-通过Google-Guava库"><a href="#1-通过Google-Guava库" class="headerlink" title="1.通过Google Guava库"></a>1.通过Google Guava库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilterExample</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建布隆过滤器，预计插入100个元素，误判率为1%</span></span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter=BloomFilter.create(Funnels.stringFunnel(),<span class="number">100</span>,<span class="number">0.01</span>);</span><br><span class="line">        </span><br><span class="line">        bloomFilter.put(<span class="string">&quot;Daisybby&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断元素是否存在</span></span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;Daisybby&quot;</span>));</span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;what&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-通过Apache-Commons"><a href="#2-通过Apache-Commons" class="headerlink" title="2.通过Apache Commons"></a>2.通过Apache Commons</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.HashFunctionIdentity;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilterExample</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter=<span class="keyword">new</span> <span class="title class_">BloomFilter</span>&lt;&gt;(HashFunctionIdentity.hashFunction(StringUtils::hashCode),<span class="number">100</span>,<span class="number">0.01</span>);</span><br><span class="line">        </span><br><span class="line">        bloomFilter.put(<span class="string">&quot;Daisybby&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断元素是否存在</span></span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;Daisybby&quot;</span>));</span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;what&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-在Redis中可以通过Bloom模块来使用，使用Redisssion可以："><a href="#3-在Redis中可以通过Bloom模块来使用，使用Redisssion可以：" class="headerlink" title="3.在Redis中可以通过Bloom模块来使用，使用Redisssion可以："></a>3.在Redis中可以通过Bloom模块来使用，使用Redisssion可以：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Config config=<span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson=Redisson.create(config);</span><br><span class="line">RBloomFilter&lt;String&gt; bloomFilter=redisson.getBloomFilter(<span class="string">&quot;myFilter&quot;</span>);</span><br><span class="line">bloomFilter.tryInit(<span class="number">100</span>,<span class="number">0.01</span>);</span><br><span class="line">bloomFilter.add(<span class="string">&quot;Daisybby&quot;</span>);</span><br><span class="line">bloomFilter.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">bloomFilter.add(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(bloomFilter.contains(<span class="string">&quot;Daisybby&quot;</span>));</span><br><span class="line">System.out.println(bloomFilter.contains(<span class="string">&quot;what&quot;</span>));</span><br><span class="line">redisson.shutdown();</span><br></pre></td></tr></table></figure>
<p>Jedis也可以，不再赘述。</p>
]]></content>
      <categories>
        <category>基础概念和原理</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis保存对象为String还是hash？</title>
    <url>/2024/06/23/save-object-as-string-or-hash/</url>
    <content><![CDATA[<h1 id="1-对象序列化后保存到Redis"><a href="#1-对象序列化后保存到Redis" class="headerlink" title="1.对象序列化后保存到Redis"></a>1.对象序列化后保存到Redis</h1><p>保存的是序列化后的对象，这种方式在Redis中很难看出来对象的含义。</p>
<span id="more"></span>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁性：</strong> 直接序列化整个对象，不需要考虑字段的单独存储。</li>
<li><strong>原子性：</strong> 对整个对象进行存取。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>序列化依赖：</strong> 依赖于特定的序列化库，可能影响性能和跨语言使用。</li>
<li><strong>可读性：</strong> 二进制格式的字符串不易于阅读和调试。</li>
<li><strong>灵活性差：</strong> 如果对象结构发生变化，需要重新序列化。</li>
</ul>
<h1 id="2-将对象转换成Json格式"><a href="#2-将对象转换成Json格式" class="headerlink" title="2.将对象转换成Json格式"></a>2.将对象转换成Json格式</h1><p>Redis中保存的是JSON格式的字符串，可以清晰阅读对象的内容。<br><strong>优点：</strong> </p>
<ul>
<li><strong>跨语言性：</strong> JSON是一种跨语言的格式，易于在不同语言和系统之间交换数据。</li>
<li><strong>可读性：</strong> JSON格式的数据易于阅读。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>灵活性：</strong>不支持对象单个属性的存取，如果要修改对象属性只能整个对象读取修改重建。</li>
<li><strong>复杂结构存储：</strong>不适合存储复杂的对象结构，比如对象存在嵌套。</li>
</ul>
<h1 id="3-用hash存储对象"><a href="#3-用hash存储对象" class="headerlink" title="3.用hash存储对象"></a>3.用hash存储对象</h1><p>Redis的key作为整个hash结构在Redis中的索引；<br>fieldName是对象的属性名称；<br>fieldValue就是属性值。<br><strong>优点：</strong></p>
<ul>
<li><strong>可读性：</strong>hash保存对象结构清晰；</li>
<li><strong>灵活性：</strong>支持对单个属性的操作，只需要根据对应的fieldName来设置fieldValue即可。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>处理嵌套的对象比较麻烦。</li>
</ul>
<h1 id="4-怎么选取呢？"><a href="#4-怎么选取呢？" class="headerlink" title="4.怎么选取呢？"></a>4.怎么选取呢？</h1><p><strong>更新频繁的数据：</strong> 可以通过hash结构存储对象。<br><strong>读频繁的数据：</strong> 对于更新频率比较低，但是读取比较频繁的数据，选择string是比较好的方案。</p>
<blockquote>
<p>实际业务开发中，可以结合string和hash。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础概念和原理</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战项目笔记二：查询缓存</title>
    <url>/2024/06/23/redis-project-note2/</url>
    <content><![CDATA[<h1 id="一、添加商户缓存"><a href="#一、添加商户缓存" class="headerlink" title="一、添加商户缓存"></a>一、添加商户缓存</h1><p><strong>业务需求：</strong></p>
<span id="more"></span>
<p>客户端提供商户id，返回商户信息。<br><strong>技术关键点：</strong></p>
<img src="/2024/06/23/redis-project-note2/img1.png" class="" title="img1">
<p>对于查询业务，为了提高系统的查询性能，使用Redis加快查询。</p>
<blockquote>
<p>遇到了Bug：<br>bug描述：<br>以hash形式将商铺信息保存到Redis，在用Hutool提供的BeanUtil.beanToMap时遇到了空指针异常。<br>bug解决方式可见：<a href="https://daisybby.github.io/2024/06/21/setFieldValueEditor-bug/#more">Hutool提供的BeanUtil.beanToMap出现空指针异常</a></p>
</blockquote>
<h1 id="二、为商铺类型添加缓存"><a href="#二、为商铺类型添加缓存" class="headerlink" title="二、为商铺类型添加缓存"></a>二、为商铺类型添加缓存</h1><p><strong>业务需求：</strong>首页有多个商铺分类，为商铺分类信息的查询添加Redis作为缓存，提高查询效率。<br><strong>流程图：</strong></p>
<img src="/2024/06/23/redis-project-note2/img2.png" class="" title="img2">
<p><strong>用什么类型保存呢？</strong></p>
<ul>
<li>可以用list、set和zset三种数据类型实现。list的元素是可以重复的，但是set和zset要保证元素的唯一性。商铺类型是唯一的，所以我们可以用set和zset来实现。</li>
<li>商铺有自己的sort属性，我们希望按照sort属性升序排序，那么我们可以用zset有序集合来实现。</li>
</ul>
<blockquote>
<p>其实也可以用list和set来实现，因为shopType每次都是全部获取，读取出来再重新排序即可。</p>
</blockquote>
<p>不过我还是选择了比较复杂的zset来练练手，嘿嘿。<br>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryAllType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.从Redis查询所有商铺类型</span></span><br><span class="line">        Set&lt;String&gt; shopTypeList=stringRedisTemplate.opsForZSet().range(CACHE_SHOPTYPE_KEY,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//2.查询成功，返回</span></span><br><span class="line">        <span class="keyword">if</span>(shopTypeList!=<span class="literal">null</span> &amp;&amp; !shopTypeList.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将String字符串转换成对象</span></span><br><span class="line">            List&lt;ShopType&gt; shopTypes=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String shopType: shopTypeList)&#123;</span><br><span class="line">                shopTypes.add(JSONUtil.toBean(shopType,ShopType.class));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shopTypes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.查询失败，从数据库查询</span></span><br><span class="line">        List&lt;ShopType&gt; shopTypes=query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">        <span class="keyword">if</span>(shopTypes==<span class="literal">null</span> || shopTypes.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;没有商铺类型！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将商铺类型数据保存到Redis</span></span><br><span class="line">        <span class="keyword">for</span>(ShopType shopType:shopTypes)&#123;</span><br><span class="line">            stringRedisTemplate.opsForZSet().add(CACHE_SHOPTYPE_KEY,JSONUtil.toJsonStr(shopType),shopType.getSort());</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.expire(CACHE_SHOPTYPE_KEY,CACHE_SHOPTYPE_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//5.返回商铺类型信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shopTypes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将shopType转换为JSON字符串，保存到zset有序集合中。</li>
<li>zset的保存语法add有三个参数，key，value和分数，这里的分数是shopType的sort字段值。zset默认按照分数从小到大排序，如果要倒序读取，可以把第3行的range换成reverseRange。或者保存的时候，sort取负值倒序保存。</li>
</ul>
<h1 id="三、缓存更新策略"><a href="#三、缓存更新策略" class="headerlink" title="三、缓存更新策略"></a>三、缓存更新策略</h1><h2 id="3-1-三种缓存更新策略"><a href="#3-1-三种缓存更新策略" class="headerlink" title="3.1.三种缓存更新策略"></a>3.1.三种缓存更新策略</h2><img src="/2024/06/23/redis-project-note2/img3.png" class="" title="img3">
<blockquote>
<p><strong>怎么选择更新策略呢？</strong></p>
<ul>
<li><strong>低一致性需求：</strong> 使用<strong>内存淘汰机制</strong>。例如商铺类别信息，虽然也有数据修改的可能性，但可能性很低，而且数据就这么多，直接保存到缓存就行，每次登录都会需要读取这部分数据。这也解释了为什么没有给缓存中的shopType数据设置过期时间。</li>
<li><strong>高一致性需求：主动更新+超时删除（兜底）</strong> 。例如商铺详情信息的缓存。</li>
</ul>
</blockquote>
<h2 id="3-2-操作缓存和数据库需要考虑的问题"><a href="#3-2-操作缓存和数据库需要考虑的问题" class="headerlink" title="3.2.操作缓存和数据库需要考虑的问题"></a>3.2.操作缓存和数据库需要考虑的问题</h2><h3 id="1-删除缓存还是更新缓存？"><a href="#1-删除缓存还是更新缓存？" class="headerlink" title="1.删除缓存还是更新缓存？"></a>1.删除缓存还是更新缓存？</h3><p>当数据库中的数据进行了更新，我们有两种策略来保证数据一致性：</p>
<ul>
<li>更新缓存：缓存数据做相应的修改；</li>
<li>删除缓存：直接删除这部分的缓存数据，下次查询时缓存未命中-&gt;查询数据库-&gt;新数据存入缓存。</li>
</ul>
<p><strong>性能分析：</strong></p>
<ul>
<li>更新缓存：一些数据更新操作比较频繁，但是访问频率很低，这就导致了大量无效的写缓存操作，且占用了缓存空间还用不到。</li>
<li>删除缓存：对于访问频率很低数据，本来就不会访问，所以没什么影响；对于访问频繁的数据，首次访问缓存未命中，但是后续加入缓存，不会对访问速度造成太大影响，而且也不会出现大量无效写缓存操作，缓存空间开销都是有用的。<blockquote>
<p>综上，选择<strong>删除缓存</strong>比较合理。</p>
</blockquote>
</li>
</ul>
<h3 id="2-如何保证缓存与数据库操作的原子性？同时成功或失败"><a href="#2-如何保证缓存与数据库操作的原子性？同时成功或失败" class="headerlink" title="2.如何保证缓存与数据库操作的原子性？同时成功或失败"></a>2.如何保证缓存与数据库操作的原子性？同时成功或失败</h3><ul>
<li>单体系统：将数据库和缓存操作放在一个事务中完成。</li>
<li>分布式系统：利用TCC等分布式事务方案。<font color="red">（这部分涉及到了分布式，等后续学习SpringCloud时再补充）</font></li>
</ul>
<h3 id="3-先操作缓存还是先操作数据库？"><a href="#3-先操作缓存还是先操作数据库？" class="headerlink" title="3.先操作缓存还是先操作数据库？"></a>3.先操作缓存还是先操作数据库？</h3><p>在学习多线程时就搞不清楚线程安全发生的场景怎么分析，多线程工作怎么出现冲突，发现了画图法这个妙妙方法。</p>
<img src="/2024/06/23/redis-project-note2/img4.png" class="" title="img4">
<p><strong>先删除缓存，再更新数据库：</strong></p>
<ul>
<li>线程不安全，在线程1更新数据库期间，线程2缓存访问未命中，然后读取数据库中的旧数据，存入缓存，最终出现：数据库-新数据，缓存-旧数据。</li>
<li>异常发生概率分析：在数据库更新期间，发生了三件事（缓存读、数据库读、缓存写），因为更新数据库的时间通常是比这三操作发生时间长，所以异常发生概率是比较高的。</li>
</ul>
<img src="/2024/06/23/redis-project-note2/img5.png" class="" title="img5">
<p><strong>先操作数据库，再删除缓存：</strong></p>
<ul>
<li>也有极端情况。在线程1先读取了数据库旧数据之后，把旧数据写入缓存之间，线程2完成了更新数据库和删除缓存操作。删除缓存操作就不讨论，没太大影响，关键是写缓存操作时间远远短于更新数据库时间，这种情况是<strong>很难发生</strong>的。</li>
<li>异常发生概率很低，所以可以考虑这种方式。<blockquote>
<p>综上：<strong>先更新数据库，再删除缓存</strong>是更安全合理的。</p>
</blockquote>
</li>
</ul>
<h1 id="四、缓存穿透、缓存雪崩和缓存击穿-（重难点）"><a href="#四、缓存穿透、缓存雪崩和缓存击穿-（重难点）" class="headerlink" title="四、缓存穿透、缓存雪崩和缓存击穿*（重难点）"></a>四、缓存穿透、缓存雪崩和缓存击穿*（重难点）</h1><h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h2><p><strong>缓存穿透</strong>是指客户端请求的数据在<strong>缓存和数据库都不存在</strong>，这样缓存永远不会生效，这些请求都会打到数据库。<br><strong>常见解决方案：</strong></p>
<ul>
<li>缓存空对象：<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：消耗内存，可能会出现短期数据不一致（缓存中保存了null且没过期，数据库中已经插入了对应的数据）。<img src="/2024/06/23/redis-project-note2/img6.png" class="" title="img6"></li>
</ul>
</li>
<li>布隆过滤器<ul>
<li>优点：内存占用较少，没有多余的key</li>
<li>缺点：<ul>
<li>布隆过滤器实现复杂</li>
<li>存在误判的可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>布隆过滤器的基本原理：<a href="https://daisybby.github.io/2024/06/22/Bloom-Filter/#more">布隆过滤器原理及其应用</a></p>
</blockquote>
<img src="/2024/06/23/redis-project-note2/img7.png" class="" title="img7">
<blockquote>
<p>本来想在这里实现布隆过滤器解决缓存穿透问题，但好像牵扯的比较多，需要考虑到项目启动和数据预热，等做到数据预热的时候来解决这部分问题。现在先通过null值方法来解决。<br><strong>通过null值解决缓存穿透问题：</strong><br>如果redis和数据库中都不存在对应的数据，那么在redis中设置一个null，防止请求再打到数据库。<br>但是我们是用hash结构保存的对象（shop为例），那么该怎么表示呢？代码中是获取的hash，我们直接添加一个字段exist，取0表示null，取1表示对象真的存在就行。</p>
</blockquote>
<h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><p><strong>缓存雪崩</strong>是指短时间内有大量缓存key失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。<br><strong>常见解决方案：</strong></p>
<ul>
<li>给不同Key的TTL添加随机值，避免同一时间大量key过期；</li>
<li>利用Redis集群提高服务的可用性；</li>
<li>给缓存业务添加降级限流策略；</li>
<li>给业务添加多级缓存。</li>
</ul>
<h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3.缓存击穿"></a>3.缓存击穿</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>缓存击穿</strong>也被称为热点key问题，一个被<strong>高并发访问</strong>并且<strong>缓存重建业务复杂</strong>（可以理解为缓存更新耗时长）的热点数据突然失效，导致大量的请求直接打到数据库，且大量线程困于缓存重建，造成系统性能下降。</p>
<img src="/2024/06/23/redis-project-note2/img8.png" class="" title="img8">
<p><strong>常见的解决方案：</strong></p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<h3 id="3-1-互斥锁"><a href="#3-1-互斥锁" class="headerlink" title="3.1.互斥锁"></a>3.1.互斥锁</h3><p>&ensp;&ensp;&ensp;&ensp;线程在查询数据库重建缓存之前先<strong>获取互斥锁</strong>。其他线程发现缓存未命中，获取互斥锁失败会<strong>循环重试</strong>查询缓存，直至缓存命中。</p>
<img src="/2024/06/23/redis-project-note2/img9.png" class="" title="img9">
<h3 id="3-2-逻辑过期"><a href="#3-2-逻辑过期" class="headerlink" title="3.2.逻辑过期"></a>3.2.逻辑过期</h3><p>&ensp;&ensp;&ensp;&ensp;缓存数据过期时并不是清除，而是发现逻辑过期，申请互斥锁，成功后开启一个<strong>新线程</strong>，查询数据库并重建缓存，<strong>新线程释放互斥锁</strong>。在查询数据库重建缓存期间，其他线程申请互斥锁失败，<strong>返回缓存中的旧数据</strong>。</p>
<img src="/2024/06/23/redis-project-note2/img10.png" class="" title="img10">
<h3 id="3-3-性能分析与对比"><a href="#3-3-性能分析与对比" class="headerlink" title="3.3.性能分析与对比"></a>3.3.性能分析与对比</h3><img src="/2024/06/23/redis-project-note2/img11.png" class="" title="img11">
<h3 id="3-4-代码实现互斥锁解决缓存击穿"><a href="#3-4-代码实现互斥锁解决缓存击穿" class="headerlink" title="3.4.代码实现互斥锁解决缓存击穿"></a>3.4.代码实现互斥锁解决缓存击穿</h3><img src="/2024/06/23/redis-project-note2/img12.png" class="" title="img12">
<blockquote>
<p>这部分的实现过程，算是一个难点，可以详细记录，作为项目难点。</p>
</blockquote>
<ol>
<li><strong>查询缓存，根据是否命中决定下一步操作</strong><br>需要注意的是，我们这里也要考虑缓存穿透问题，即使从redis获取的hashMap不是空的，也有可能exist字段为0。</li>
<li><strong>缓存未命中，为了避免发生缓存击穿，也就是多个请求访问的是同一个数据，短时间内都未命中，请求打到数据库</strong></li>
</ol>
<ul>
<li>取互斥锁：在redis中通过setIfAbsent添加字段lockKey，如果redis中已经有lockKey就不会再添加成功；</li>
<li>如果获取锁失败，则线程sleep一段时间（埋个坑，sleep时间怎么决定？），然后递归查询。</li>
<li>如果锁获取成功，查询数据库，查询不到则根据缓存穿透的解决策略设置exist字段；更新缓存，记得设置过期时间。</li>
<li>释放互斥锁。</li>
</ul>
<ol start="3">
<li><strong>线程sleep、递归和释放互斥锁三个关键点</strong><br>&ensp;&ensp;&ensp;&ensp;线程sleep是需要处理异常的，我们可以从获取互斥锁到更新完缓存，这段都包含在try catch块中，将unlock放在finally中，避免sleep异常导致互斥锁无法释放。<br>&ensp;&ensp;&ensp;&ensp;递归是在try catch块中的，尽管递归，但只要缓存命中，就会在到达finally之前层层return，因此不会出现没有申请到互斥锁，但是每次递归都unlock的情况。但是finally又保证了只要正常执行，一定会有unlock操作。<blockquote>
<p>这部分内容需要反复理解。</p>
</blockquote>
</li>
</ol>
<p>高并发场景的测试，需要用到JMeter，进行压力测试。</p>
<h3 id="3-5-通过逻辑过期解决缓存击穿"><a href="#3-5-通过逻辑过期解决缓存击穿" class="headerlink" title="3.5.通过逻辑过期解决缓存击穿"></a>3.5.通过逻辑过期解决缓存击穿</h3><img src="/2024/06/23/redis-project-note2/img13.png" class="" title="img13">
<p><strong>代码实现要点：</strong></p>
<ul>
<li>Redis中给shop增加一个属性段：过期时间。但是要保持不修改原有业务逻辑和代码，那么编写一个新的类RedisData，将过期时间和Shop对象打包成一个对象。</li>
<li>为什么缓存未命中，直接返回呢？因为逻辑过期策略里，缓存中没有就是业务涉及不到的数据，因为业务数据不会真的从缓存中消失，所以这里可以不考虑缓存穿透的问题。</li>
<li>线程成功获取到互斥锁时，一定要<strong>再次校验</strong>数据是否过期：因为可能出现如下情况：多线程情况下反复更新缓存。<img src="/2024/06/23/redis-project-note2/img14.png" class="" title="img14"></li>
</ul>
<h1 id="四、Redis工具类封装"><a href="#四、Redis工具类封装" class="headerlink" title="四、Redis工具类封装"></a>四、Redis工具类封装</h1><p>对于Redis解决缓存穿透、缓存击穿等问题的实现代码，不应该和业务逻辑代码混在一起。之前的代码都是针对shop写的，实际上user、product等实体也都需要实现。那么我们可以利用泛型封装这些方法。<br><strong>封装的方法如下：</strong></p>
<ul>
<li>set方法：向redis保存对象<ul>
<li>传入参数：key、Object对象、过期时间、时间单位</li>
<li>返回结果:void</li>
</ul>
</li>
<li>setWithLogicalExpire：向Redis保存对象，但要携带逻辑过期时间<ul>
<li>传入参数：key，Object对象、逻辑过期时间、时间单位</li>
<li>返回结果：void</li>
</ul>
</li>
<li>tryLock：逻辑过期时间线程尝试获取互斥锁<ul>
<li>传入参数：key。是指互斥锁的key</li>
<li>返回结果：boolean</li>
</ul>
</li>
<li>unlock：释放互斥锁<ul>
<li>传入参数：互斥锁的key</li>
<li>返回结果：void</li>
</ul>
</li>
<li>queryWithPassThrough：解决缓存穿透<ul>
<li>传入参数：<ul>
<li>String：keyPrefix，缓存中key前缀，如shop的前缀CACHE_SHOP_KEY。</li>
<li>ID：id，ID是一个泛型，因为实体id不一定都是Long或者都是String，有可能都有。</li>
<li>Class<R>：type，传入一个对象的类型，比如Shop.class。</li>
<li>Function&lt;ID,R&gt;：dbFallBack，通过id向数据库查询实体的函数，因为可能是查shop也可能是User，返回类型是一个R类型的对象，ID是传入查询方法的参数类型。在项目中是getById。</li>
<li>Long：time，设置的缓存过期时间</li>
<li>TimeUnit：unit，时间单位。</li>
</ul>
</li>
<li>返回结果：R类型的一个对象，比如一个shop对象。</li>
</ul>
</li>
<li>queryWithLogicalExpire：逻辑过期时间解决缓存击穿<ul>
<li>传入参数：<ul>
<li>String：keyPrefix，缓存key前缀。</li>
<li>String：lockKeyPrefix，互斥锁的前缀，因为互斥锁是和要查询的具体对象id有关。</li>
<li>ID：id，泛型，表示实体的id。</li>
<li>Class<R>：type，泛型，表示传入一个对象类型。</li>
<li>Function&lt;ID,R&gt;：dbFallBack，传入从数据库查询数据的方法，ID是参数类型，R是返回类型。</li>
<li>Long：time，逻辑过期时间。</li>
<li>TimeUnit：unit，逻辑过期时间的单位。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>查询缓存基本结束。一边写代码，一边查资料解答自己的疑惑，还想要写笔记输出。说实话很累，但感觉自己学习的比较清楚。不过学完觉得缓存穿透、缓存雪崩和缓存击穿的概念以及常见解决方案，还是比较生疏，自己的笔记还是要多看的，不能总结了不看。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类和接口的区别</title>
    <url>/2024/06/25/interface-and-abstract-class/</url>
    <content><![CDATA[<p><strong>方法定义：</strong></p>
<ul>
<li>接口只是定义了一些方法；</li>
<li>抽象类中方法是有具体实现代码的。</li>
</ul>
<p><strong>修饰符：</strong></p>
<ul>
<li>接口中的方法只能被public修饰</li>
<li>抽象类种的方法可以是private、protected和public，也可以是<default>的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    String c;</span><br><span class="line">    <span class="keyword">protected</span> String d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>构造器：</strong></li>
<li>接口不能有构造器；</li>
<li>抽象类可以有构造器。</li>
</ul>
<blockquote>
<p>抽象类不能被实例化，但是构造器还是有意义的。抽象类的构造器可以在<strong>其子类的构造器</strong>中被调用，然后再执行子类自己的构造器代码。</p>
</blockquote>
<p><strong>继承与实现：</strong></p>
<ul>
<li>接口只能被实现；</li>
<li>抽象类可以被继承。</li>
</ul>
<p><strong>单继承，多实现：</strong></p>
<ul>
<li>一个类可以实现多个接口</li>
<li>一个类只能继承一个抽象类</li>
</ul>
<p><strong>职责不同：</strong></p>
<ul>
<li>接口用于制定规范；</li>
<li>抽象类用于代码复用。</li>
</ul>
<p>在实际开发中，如果多个实现类有相同可复用的代码，那么就在接口和实现类之间增加一层抽象类。</p>
]]></content>
      <categories>
        <category>基本概念和原理</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务</title>
    <url>/2024/06/26/Transaction/</url>
    <content><![CDATA[<h1 id="一、事务的四个特性"><a href="#一、事务的四个特性" class="headerlink" title="一、事务的四个特性"></a>一、事务的四个特性</h1><p>ACID：原子性、一致性、隔离性、持久性。</p>
<span id="more"></span>
<h1 id="二、事务的隔离级别"><a href="#二、事务的隔离级别" class="headerlink" title="二、事务的隔离级别"></a>二、事务的隔离级别</h1><p>数据库事务的隔离级别有四种，从低到高分别是:Read uncommitted、Read committed、Repeatable read、Serializable。事务可能会导致一些问题：脏读、幻读、不可重复读、事务丢失。</p>
<ul>
<li><strong>脏读：读取了未提交的事务，然后事务回滚了。</strong><br>  事务A修改了数据库，被事务B读取了，读取之后事务A回滚。</li>
<li><strong>不可重复读：读取了新提交的事务，指更新操作，导致同一个事务中两次读取不一致。</strong><br>事务A先读取数据库得到value1，然后事务B修改数据库为value2，然后事务A又读到了value2，value1与value2是不一致的。</li>
<li><strong>幻读：读取了新提交的事务，指增删操作。</strong><br>也是两次查询数据不一致，不过是新增产生的问题。</li>
<li><strong>第一类事务丢失（回滚丢失）</strong><br>事务A修改value1-num，事务B修改为value1-num+count，但是事务A不知道事务B的修改，直接将数据回滚为value1，这就导致事务B增加的count丢失了。</li>
<li><strong>第二类事务丢失（提交覆盖）</strong><br>  事务A将数据库由value0修改为value1，事务B紧接着提交，覆盖了事务A的修改。</li>
</ul>
<p><strong>Read uncommitted：</strong>可能会导致脏读。<br><strong>Read committed：</strong>可能会导致不可重复读。<br><strong>Repeatable read：</strong>尽管避免了修改，但是没有避免新增和删除，会导致幻读。<br><strong>Serializable：</strong>隔离级别最高，但是性能很差，一般不用。<br>大多数数据库默认事务隔离级别是Read Committed，遇到了不可重复读按照最后一次读取即可，MySQL默认事务隔离级别是<strong>Repeatable read</strong>。</p>
<h1 id="三、事务实现方式"><a href="#三、事务实现方式" class="headerlink" title="三、事务实现方式"></a>三、事务实现方式</h1><p>事务的实现方式分为<strong>声明式事务</strong>和<strong>编程式事务</strong>。</p>
<h2 id="3-1-声明式事务"><a href="#3-1-声明式事务" class="headerlink" title="3.1.声明式事务"></a>3.1.声明式事务</h2><p>&ensp;&ensp;&ensp;&ensp;通过@Transactional注解或者xml配置方式开启声明式事务，可以被用在<strong>类</strong>上和<strong>方法</strong>上，用在类上表明整个类的方法都开启事务。<br><strong>优点：</strong></p>
<ul>
<li><strong>代码简洁，</strong>声明式事务能够自动在方法前开启事务，根据方法执行结果决定是提交事务还是回滚事务。避免手动编写的大量代码。</li>
<li><strong>非侵入性：</strong>声明式事务本质上是通过AOP方式实现的，在目标方法前后添加拦截，在目标方法执行前添加或新建一个事务，在方法执行后根据结果来决定是提交事务（正常结束返回）还是回滚事务（抛出异常）。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>事务粒度：</strong>事务执行的最小粒度是方法，如果想要给某一段代码块添加事务，需要把这部分代码独立出来作为一个方法。</li>
<li><strong>容易被忽视：</strong>声明式事务通过注解即可，有时候还可以通过配置来实现，容易被忽略，进而导致问题。<blockquote>
<p><strong>忽视了事务会导致什么问题？</strong><br>如果开发者忽略了某个方法开启了事务，在方法内部执行了RPC调用、消息发送、缓存更新、文件写入等不可以回滚的操作：<br>1.如果出现了问题，本地事务回滚了，但是RPC远程调用是不可以回滚的，其他操作类似。<br>2.事务中远程调用会拉长事务，导致本事务的数据库连接池一直被占用，进而导致数据库连接池被耗尽。如果是编程式事务，那么大的事务开启代码、事务提交和事务回滚代码，一般不会忽略。</p>
</blockquote>
</li>
<li><strong>事务失效：</strong>某些场景下会导致声明式事务失效，这是一个常见八股。</li>
</ul>
<p><strong>常见的事务失效场景：</strong></p>
<ul>
<li>未指定回滚异常：<ul>
<li>@Transactional开启的事务，回滚异常默认是运行时异常(RuntimeException)，如果是自定义异常，继承了Exception，那么抛出这个异常时，事务不能回滚。<br>○ 需要指定@Trandsactional(rollbackFor&#x3D;Exception.class)</li>
</ul>
</li>
<li>异常被try catch捕获：<ul>
<li>异常被try catch捕获的时候，事务会失效</li>
<li>解决方案是throw异常，或者修改catch中的代码，手动回滚。</li>
</ul>
</li>
<li>同一个类方法中调用：<ul>
<li>和项目中出现的问题一样，开启事务的方法调用了所在类的其他方法，这个时候是this调用，而不是事务通过AOP的代理对象</li>
<li>解决方案是获取代理对象来调用。</li>
</ul>
</li>
<li>异步多线程：这部分不太懂。之后学了JUC可以回来补充。</li>
<li>错误设置事务传播机制：事务传播机制设置不恰当可能会导致事务失效。例如在默认的事务中，调用了@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW）设置的方法，在执行这个方法时，会新建事务，挂起已有事务，新建事务正确执行并提交后，原有事务才会恢复执行，即使原有事务因为异常发生了回滚，也不会影响已经提交的新事务。</li>
<li>方法不是public：因为事务是基于AOP的动态代理机制来实现的，只有public方法能够被代理。</li>
<li>当前类没有被spring容器托管：类没有被Spring容器所托管，那么也不会被Spring AOP所代理。</li>
<li>数据库本身不支持事务。</li>
</ul>
<h2 id="3-2-编程式事务"><a href="#3-2-编程式事务" class="headerlink" title="3.2.编程式事务"></a>3.2.编程式事务</h2><p>Spring框架提供两种编程式事务方式：</p>
<ul>
<li>TransactionTemplate或者TransactionalOperator</li>
<li>直接实现TransactionManager<br>具体如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trans</span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        TransactionDefinition def=<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        TransactionStatus status=transactionManager.getTransaction(def);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (DataAccessExcetption e)&#123;</span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过编程式事务，我们可以缩小事务粒度，但是实现方式比较麻烦。</li>
</ul>
<h1 id="四、事务的七种传播机制"><a href="#四、事务的七种传播机制" class="headerlink" title="四、事务的七种传播机制"></a>四、事务的七种传播机制</h1><h2 id="1-REQUIRED（required）：默认"><a href="#1-REQUIRED（required）：默认" class="headerlink" title="1.REQUIRED（required）：默认"></a>1.REQUIRED（required）：默认</h2><ul>
<li>当前已有事务：加入该事务</li>
<li>没有事务：新建一个事务<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在roleService中有如下代码：</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertRole</span><span class="params">()</span>&#123;</span><br><span class="line">    Role role=<span class="keyword">new</span> <span class="title class_">Role</span>();</span><br><span class="line">    roleMapper.insert(role);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在userService中有如下代码:</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用另一个需要事务的方法</span></span><br><span class="line">    roleService.insertRole();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num=<span class="number">10</span>/<span class="number">0</span>;<span class="comment">//制造一个异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>过程分析：</strong>执行userService的insertUser方法之前开启一个事务-&gt;过程中遇到insertRole，加入当前事务-&gt;事务提交前抛出异常，事务回滚。<br><strong>结果：</strong>本质上是同一个事务，所以所有插入操作都被回滚。</li>
</ul>
<h2 id="2-SUPPORTS（supports"><a href="#2-SUPPORTS（supports" class="headerlink" title="2.SUPPORTS（supports)"></a>2.SUPPORTS（supports)</h2><ul>
<li>当前有事务：加入该事务；</li>
<li>没有事务：以非事务方式继续运行。</li>
</ul>
<h3 id="2-1-当前无事务"><a href="#2-1-当前无事务" class="headerlink" title="2.1.当前无事务"></a>2.1.当前无事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertUser修改为无事务方式，继续上面的代码</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser无事-&gt;遇到insertRole，设置了SUPPORTS的事务传播机制-&gt;以非事务方式执行-&gt;遇到异常，无事务不回滚。<br><strong>结果：</strong>两条数据都成功插入数据库，都没有回滚操作。</p>
<h3 id="2-2-当前有事务"><a href="#2-2-当前有事务" class="headerlink" title="2.2.当前有事务"></a>2.2.当前有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertUser使用默认数据传播机制，insertRole使用SUPPORTS传播机制</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser有事务-&gt;遇到insertRole也需要开启事务，则加入当前事务-&gt;都将数据插入数据库，但事务提交前遇到异常-&gt;事务回滚。<br><strong>结果：</strong>两者属于同一个事务，所以都会被回滚。</p>
<h2 id="3-MANDATORY（mandatory"><a href="#3-MANDATORY（mandatory" class="headerlink" title="3.MANDATORY（mandatory)"></a>3.MANDATORY（mandatory)</h2><ul>
<li>当前有事务：加入该事务</li>
<li>没有事务：抛出异常</li>
</ul>
<h3 id="3-1-当前没有事务"><a href="#3-1-当前没有事务" class="headerlink" title="3.1.当前没有事务"></a>3.1.当前没有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole使用@Transactional注解</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor=Exception.class,propagation=Propagation.MANDATORY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertRole</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser数据正常入库-&gt;但是insertRole会报错，role无法存入数据库。<br><strong>结果：</strong>报错，role无法入库，但是不影响前面user信息入库。</p>
<h3 id="3-2-当前有事务"><a href="#3-2-当前有事务" class="headerlink" title="3.2.当前有事务"></a>3.2.当前有事务</h3><p>和REQUIRED、SUPPORTS的结果相同，因为报错了，所以事务都会回滚。</p>
<h2 id="4-REQUIRES-NEW（requires-new"><a href="#4-REQUIRES-NEW（requires-new" class="headerlink" title="4.REQUIRES_NEW（requires_new)"></a>4.REQUIRES_NEW（requires_new)</h2><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起，新事务结束才会恢复当前事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertUser和insertRole都开启事务，将insertRole的事务传播机制设置为REQUIRES_NEW</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser执行，开启事务-&gt;遇到insertRole，将insertUser的事务挂起，开启新事务，执行insertRole-&gt;Role信息正确进入数据库，新事务提交-&gt;insertUser当前事务恢复-&gt;遇到异常，当前事务回滚，之前提交的事务并不回滚。<br><strong>结果：</strong> insertUser遇到异常回滚，但是insertRole是另外的事务，不会回滚，user不存入数据库，Role存入数据库。</p>
<h2 id="5-NO-SUPPORTED-no-supported"><a href="#5-NO-SUPPORTED-no-supported" class="headerlink" title="5.NO_SUPPORTED(no_supported)"></a>5.NO_SUPPORTED(no_supported)</h2><p>以非事务方式运行，当前存在事务，则挂起当前事务。</p>
<h3 id="5-1-当前没有事务"><a href="#5-1-当前没有事务" class="headerlink" title="5.1.当前没有事务"></a>5.1.当前没有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertUser没有事务</span></span><br><span class="line"><span class="comment">//insertRole设置为NO_SUPPORTED</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>都以非事务方式执行-&gt;尽管有异常，但是user和role都会正常存入数据库。<br><strong>结果：</strong>两者照常入库，抛出异常。</p>
<h3 id="5-2-当前有事务"><a href="#5-2-当前有事务" class="headerlink" title="5.2.当前有事务"></a>5.2.当前有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole设置为NO_SUPPORTED</span></span><br><span class="line"><span class="comment">//insertUser默认事务</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser开启事务，执行-&gt;遇到insertRole，挂起当前事务，以非事务方式insertRole-&gt;insertRole执行完毕，恢复当前事务-&gt;遇到异常，事务回滚，但是insertRole非事务，无法回滚。<br><strong>结果：</strong>因为事务回滚，user不会出现在数据库，但是role正常入库。</p>
<h2 id="6-NEVER"><a href="#6-NEVER" class="headerlink" title="6.NEVER"></a>6.NEVER</h2><p>以非事务方式运行，如果当前存在事务，则抛出异常。（和MANDATORY相反，那个是必须有，没有就异常；这个是必须没有，有就异常）</p>
<h3 id="6-1-当前没有事务"><a href="#6-1-当前没有事务" class="headerlink" title="6.1.当前没有事务"></a>6.1.当前没有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole设置传播机制为NEVER</span></span><br><span class="line"><span class="comment">//insertUser没有事务</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>两者都以非事务方式执行。<br><strong>结果：</strong>user和role都入库，并不会回滚。</p>
<h3 id="6-2-当前存在事务"><a href="#6-2-当前存在事务" class="headerlink" title="6.2.当前存在事务"></a>6.2.当前存在事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole设置传播机制为NEVER</span></span><br><span class="line"><span class="comment">//insertUser默认开启事务</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser方法执行前开启一个事务，insertUser执行-&gt;保存user到数据库-&gt;执行insertRole，因为当前有事务，所以抛出异常-&gt;因为遇到异常，所以insertUser事务回滚-&gt;那么其实int num&#x3D;10&#x2F;0;并没有被执行。<br><strong>结果：</strong>insertUser因为NEVER抛出的异常而回滚。</p>
<h2 id="7-NESTED"><a href="#7-NESTED" class="headerlink" title="7.NESTED"></a>7.NESTED</h2><ul>
<li>当前有事务：创建一个事务作为当前事务的嵌套事务来运行；</li>
<li>没有事务：等价于REQUIRED（新建一个事务，没有算了，我自己干！）</li>
</ul>
<h3 id="7-1-当前没有事务"><a href="#7-1-当前没有事务" class="headerlink" title="7.1.当前没有事务"></a>7.1.当前没有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole设置传播机制为NESTED</span></span><br><span class="line"><span class="comment">//insertUser没有事务</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>执行insertUser-&gt;遇到insertRole，当前没有事务，创建新事务执行-&gt;将role保存到数据库，事务提交-&gt;遇到异常，结束。<br><strong>结果：</strong>两条数据都能成功入库，因为insertUser的异常在insertRole事务提交之后，而insertUser又没有事务，异常不会导致回滚。</p>
<h3 id="7-2-当前有事务"><a href="#7-2-当前有事务" class="headerlink" title="7.2.当前有事务"></a>7.2.当前有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole设置事务，传播机制为NESTED</span></span><br><span class="line"><span class="comment">//insertUser默认事务</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>开启一个事务，执行insertUser-&gt;遇到了insertRole，因为当前有事务，所以开启新事务执行insertRole，新事务作为外部事务的子事务-&gt;执行insertRole,role信息入库-&gt;子事务提交，继续执行外部事务-&gt;外部事务发生异常，外部事务和<strong>所有子事务</strong>都回滚。<br><strong>结果：</strong>因为外部事务抛出异常，两个事务都回滚，user和role都不会保存到数据库。</p>
<blockquote>
<p>需要注意的是，外部事务的回滚会导致所有内部子事务的回滚；但是，嵌套子事务的回滚并<strong>不会</strong>导致外部事务的回滚。<br>如果不指定rollbackFor，那么只有<strong>RuntimeException</strong>和<strong>Error</strong>会导致事务回滚。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础概念和原理</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Redis实战项目笔记三：优惠券秒杀</title>
    <url>/2024/06/27/redis-project-note2/</url>
    <content><![CDATA[<h1 id="一、全局唯一ID"><a href="#一、全局唯一ID" class="headerlink" title="一、全局唯一ID"></a>一、全局唯一ID</h1><span id="more"></span>
<p>&ensp;&ensp;&ensp;&ensp;全局唯一ID方法比较多，包括数据库自增、Redis实现和雪花算法。雪花算法用于分布式全局唯一ID，可以后续做分布式的时候重点解决这部分的问题。<br><strong>怎么通过Redis生成全局唯一id</strong><br>在Redis中设置一个String类型数据，key标识哪一业务的订单，value标识订单序列号。<br><strong>每次生成id就将Redis中的记录自增1.</strong><br><strong>key格式：</strong>icr:+keyPrefix+:+date（年月日）</p>
<h1 id="二、添加优惠券和秒杀下单"><a href="#二、添加优惠券和秒杀下单" class="headerlink" title="二、添加优惠券和秒杀下单"></a>二、添加优惠券和秒杀下单</h1><p>&ensp;&ensp;&ensp;&ensp;优惠券分为普通优惠券和秒杀优惠券。秒杀优惠券是在普通优惠券的基础上增加了：秒杀开始时间、结束时间和库存量。</p>
<h2 id="1-优惠券数据库设计"><a href="#1-优惠券数据库设计" class="headerlink" title="1.优惠券数据库设计"></a>1.优惠券数据库设计</h2><p>&ensp;&ensp;&ensp;&ensp;数据库分为voucher和seckill_voucher两个表，秒杀优惠券多出的信息保存在seckill_voucher表中。<br>&ensp;&ensp;&ensp;&ensp;读取优惠券列表时，根据xml重新配置的mapper联合读取两张表，信息都拼接到voucher对象中。普通优惠券的开始时间、结束时间和库存量为null。</p>
<blockquote>
<p>相当于在存储逻辑上没有分开存储，但是在业务处理逻辑上是分开的。</p>
</blockquote>
<h2 id="2-秒杀下单"><a href="#2-秒杀下单" class="headerlink" title="2.秒杀下单"></a>2.秒杀下单</h2><p><strong>业务需求：</strong><br>根据优惠券id下单，生成优惠券订单。<br><strong>实现流程图：</strong></p>
<img src="/2024/06/27/redis-project-note2/img1.png" class="" title="img1">
<h1 id="三、库存超卖问题"><a href="#三、库存超卖问题" class="headerlink" title="三、库存超卖问题*"></a>三、库存超卖问题*</h1><h2 id="1-问题详情"><a href="#1-问题详情" class="headerlink" title="1.问题详情"></a>1.问题详情</h2><p>在高并发场景下，例如200个线程同时去秒杀100份优惠券，会出现创建了109个订单，库存变成-9.</p>
<img src="/2024/06/27/redis-project-note2/img2.png" class="" title="img2">
<img src="/2024/06/27/redis-project-note2/img3.png" class="" title="img3">
<p><strong>为什么会出现超卖？</strong></p>
<img src="/2024/06/27/redis-project-note2/img4.png" class="" title="img4">
<h2 id="2-怎么解决超卖？"><a href="#2-怎么解决超卖？" class="headerlink" title="2.怎么解决超卖？"></a>2.怎么解决超卖？</h2><h3 id="2-1-悲观锁"><a href="#2-1-悲观锁" class="headerlink" title="2.1.悲观锁"></a>2.1.悲观锁</h3><p>通过互斥锁、Sychronized、lock等方式。悲观锁实现方式简单，但是效率比较低。</p>
<h3 id="2-2-乐观锁"><a href="#2-2-乐观锁" class="headerlink" title="2.2.乐观锁"></a>2.2.乐观锁</h3><p>具体概念看悲观锁和乐观锁的八股。乐观锁的实现方式包括：版本号和CAS方式。<br>乐观锁效率略高于悲观锁，适合多读少写的场景。在解决超卖问题的场景中，CAS方式解决超卖的方案会导致秒杀成功率很低。</p>
<h3 id="2-3-利用数据库的锁"><a href="#2-3-利用数据库的锁" class="headerlink" title="2.3.利用数据库的锁"></a>2.3.利用数据库的锁</h3><p>在扣减库存时，只要库存量&gt;0就可以扣减成功，利用数据库同一时刻只有一个线程能写数据。</p>
<h1 id="四、实现一人一单"><a href="#四、实现一人一单" class="headerlink" title="四、实现一人一单"></a>四、实现一人一单</h1><p><strong>业务需求：</strong><br>一个用户只能购买同一个优惠券一次。<br><strong>实现逻辑：</strong></p>
<img src="/2024/06/27/redis-project-note2/img5.png" class="" title="img5">
<p>关键点就是在扣减库存之前判断是不是已经有订单了。</p>
<h2 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1.问题分析"></a>1.问题分析</h2><p>用JMeter设置了200个请求，用的是同一个用户的token。正常情况下：<strong>只有一个订单，库存只减少1</strong>。<br>实际情况：</p>
<img src="/2024/06/27/redis-project-note2/img6.png" class="" title="img6">
<img src="/2024/06/27/redis-project-note2/img7.png" class="" title="img7">
<p>库存减少了10，同一个用户创建了10个订单。为什么呢？其实这里出现的问题和超卖是一致的。<br><strong>问题分析：</strong><br> 出现一人多单的原因是：在线程1检查订单和创建完成之间，别的线程完成了订单检查，后续就会成功创建订单。</p>
<h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>&ensp;&ensp;&ensp;&ensp;因为是添加订单，而不是修改数据，所以不能用乐观锁，要通过互斥锁来实现。将一人一单的逻辑代码抽象成createVoucherOrder方法。<br><strong>对秒杀的整个Service方法加synchronized：</strong><br>可以实现业务，但是同一时刻只能有一个线程能执行这个方法，这就影响到了其他用户秒杀。本质上一人一单是一个用户id只能秒杀一次。所以可以对用户id添加synchronized。<br><strong>针对用户id添加synchronized：</strong></p>
<ul>
<li>传入方法的userId是一个Long对象，每个线程都是从threadLocal获取用户，不同的请求对应不同的线程，也就是不同的userId，所以直接对userId加锁是不行的。</li>
<li>本质是对userId值进行锁定，所以对Object.intern()的结果加synchronized锁。<blockquote>
<p>intern()方法的作用是去字符串常量池查找是否有等效的字符串。如果有，则返回这个字符串的引用，如果没有，就把这个字符串放入字符串常量池，并返回其引用。</p>
</blockquote>
</li>
</ul>
<p><strong><font color=red>大坑1：释放锁的时机和事务</font></strong><br>这里还有个坑，如果对userId的字符串字面量加锁，实现方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//用户id</span></span><br><span class="line">    UserDTO user= UserHolder.getUser();</span><br><span class="line">    Long userId=user.getId();</span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="type">int</span> count=query().eq(<span class="string">&quot;user_id&quot;</span>,userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;已经购买过该优惠券！不允许重复购买！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        seckillVoucherService.update().setSql(<span class="string">&quot;stock=stock-1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>).update();</span><br><span class="line">        <span class="comment">//生成秒杀订单</span></span><br><span class="line">        VoucherOrder order=<span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//1.订单id</span></span><br><span class="line">        <span class="type">long</span> orderId=redisWorker.nextId(<span class="string">&quot;voucherOrder&quot;</span>);</span><br><span class="line">        order.setId(orderId);</span><br><span class="line">        <span class="comment">//2.优惠券id</span></span><br><span class="line">        order.setVoucherId(voucherId);</span><br><span class="line"></span><br><span class="line">        order.setUserId(user.getId());</span><br><span class="line">        <span class="comment">//订单写入数据库</span></span><br><span class="line">        save(order);</span><br><span class="line">        <span class="comment">//返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可能牵扯到了八股，Spring的事务:<a href="https://daisybby.github.io/2024/06/26/Transaction/">Spring事务</a></p>
<blockquote>
<p>以上代码，执行完synchronized锁上的代码块后，释放互斥锁-&gt;return结果-&gt;事务提交。<br><strong>正常情况下：</strong></p>
</blockquote>
<ul>
<li>加锁的代码块正常执行，遇到了return语句，要退出这个代码块，那么互斥锁会被释放；</li>
<li>或者加锁的代码块正常执行，内部没有return语句，那么执行完退出这个代码块时，互斥锁被释放；</li>
<li>事务修饰的方法正常执行，返回结果后提交事务。<br><strong>异常情况下：</strong></li>
<li>加锁的代码块内部出现了异常，也是要退出这段代码块的，互斥锁被释放；</li>
<li>@Transactional事务，如果抛出的异常满足设置的事务回滚条件，那么事务会回滚。<br>总结：只要退出synchronized加锁的代码块，互斥锁都会被释放。<br>这就导致在<strong>事务提交前互斥锁已经被释放</strong>，如果此时其他线程使用相同的userId，获取到了互斥锁，事务还没有提交，数据库还没有更新，这就又出现了多线程都进入创建订单阶段，导致一人多单。<br><strong><font color=green>正确做法：</font></strong></li>
<li><strong>加锁对象依旧是userId；</strong></li>
<li><strong>加锁时间：事务提交之前-&gt;事务提交之后。</strong></li>
</ul>
<p>实现方法就是在秒杀service方法seckillVoucher中调用createVoucherOrder方法之前就对userId加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long userId=UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">    <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里和对createVoucherOrder函数加锁不同，尽管在方法执行期间都是被加锁状态，但是其他的userId没有被加锁，还是可以执行这段代码。而且是确保实物提交了才会释放互斥锁。</p>
</blockquote>
<p><strong><font color=red>大坑2：事务不生效</font></strong><br>&ensp;&ensp;&ensp;&ensp;在上面的代码块中，return本质是return this.createVoucherOrder，调用的是seckillVoucherOrderServiceImpl对象的属性方法，但是事务生效用的是这个对象的代理对象，this是会导致事务不生效的。</p>
<blockquote>
<p>这里有提到不建议用声明式事务的原因，总结了一些事务失效的原因，原因4就是同一个类中方法调用会导致事务失效。</p>
</blockquote>
<p><strong><font color=green>正确做法：</font></strong></p>
<ul>
<li><strong>设置代理对象可暴露，获取IVoucherOrderService的代理对象</strong></li>
<li><strong>调用代理对象的createVoucherOrder方法</strong></li>
</ul>
<p>以上操作使得事务生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装aspectJ的依赖</span></span><br><span class="line"><span class="comment">//1.在项目启动类中添加注解</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br><span class="line"><span class="comment">//2.在调用createVoucherOrder的地方修改为调用代理类的方法</span></span><br><span class="line">Long userId=UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">    IVoucherOrderService proxy= (IVoucherOrderService) AopContext.currentProxy();<span class="comment">//获取代理对象</span></span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>八股里是不推荐实现<strong>声明式事务</strong>，推荐的是<strong>编程式事务</strong>。先把这部分功能实现，然后回来优化事务。</p>
</blockquote>
<p>需要注意的是，这里的一人一单策略，都是在单机模式下生效的，一旦到了集群模式下就会失效。</p>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战项目笔记四：分布式锁</title>
    <url>/2024/06/30/lock/</url>
    <content><![CDATA[<p><strong>业务背景:</strong></p>
<span id="more"></span>
<p>&ensp;&ensp;&ensp;&ensp;在单机模式下，通过给创建优惠券订单的函数添加synchronized，能够实现一人一单；但是在分布式系统下，<strong>synchronized无法跨服务器生效</strong>，还是会导致一人多单的问题。</p>
<blockquote>
<p>跨服务器场景下，如果要实现线程之间的同步，需要通过<strong>分布式锁</strong>。</p>
</blockquote>
<h1 id="1-Redis分布式锁"><a href="#1-Redis分布式锁" class="headerlink" title="1.Redis分布式锁"></a>1.Redis分布式锁</h1><p><strong>业务逻辑：</strong><br>之前基于互斥锁synchronized实现了一台服务器上的一人一单，现在通过Redis的setnx方法实现分布式锁。</p>
<ul>
<li>锁针对的依然是优惠券秒杀业务下的userId，因此Redis中锁的key是和业务以及userId相关。</li>
<li>value可以设置为申请到分布式锁的线程id。</li>
<li>和单机模式下类似，在创建订单前获取分布式锁，finally释放分布式锁。</li>
</ul>
<h1 id="2-分布式锁误删问题"><a href="#2-分布式锁误删问题" class="headerlink" title="2.分布式锁误删问题"></a>2.分布式锁误删问题</h1><p><strong>问题背景：</strong><br>&ensp;&ensp;&ensp;&ensp;创建秒杀订单前，线程获取分布式锁，成功后才行，在任务执行完释放分布式锁。但是并发场景下，会存在如下问题：</p>
<img src="/2024/06/30/lock/img1.png" class="" title="img1">
<ul>
<li>线程1的业务发生了阻塞，导致持有的分布式锁过期自动释放。</li>
<li>线程2在线程1业务完成之前、分布式锁过期释放后申请获取锁，成功，线程2进入业务。</li>
<li>线程1在线程2业务结束之前释放分布式锁，这个时候锁的key是前缀+userId+业务，是有可能重复的，<strong>错误释放了线程2持有的分布式锁</strong>。</li>
<li>线程3在线程2任务结束前到达，申请获取分布式锁，成功，此时<strong>线程2和线程3</strong>同时执行。</li>
</ul>
<p><strong>解决思路：</strong><br>&ensp;&ensp;&ensp;&ensp;归根结底，出现问题的原因是线程释放分布式锁时，根本没看锁属不属于自己，直接就释放了。正常情况下，如果不是当前线程持有的锁，不释放。释放分布式锁之前检查<strong>锁是否为当前线程所持有</strong>。<br>&ensp;&ensp;&ensp;&ensp;在之前，锁的value值是没有用上的，存储的是获得锁的线程号，但是<strong>不同JVM上线程号</strong>可能相同，因此需要在线程号前面加上能够标识JVM的：</p>
<ul>
<li>赋予当前类一个属性，这台JVM所有执行这部分代码的线程都具有一样的编号UUID，而且要保证这个UUID不能被修改</li>
<li>用static修饰，表示变量属于类</li>
<li>final修饰，表示变量一旦被初始化，就不能修改</li>
</ul>
<h1 id="3-分布式锁原子性问题"><a href="#3-分布式锁原子性问题" class="headerlink" title="3.分布式锁原子性问题"></a>3.分布式锁原子性问题</h1><p><strong>问题背景：</strong><br>释放分布式锁分为两步：一是判断锁标识，二是删除锁。</p>
<img src="/2024/06/30/lock/img2.png" class="" title="img2">
<ul>
<li>线程1判断线程标识后，释放锁之前被阻塞；</li>
<li>分布式锁超时释放，被后来的线程2获得；</li>
<li>线程2执行期间，线程1恢复，此时不需要再次判断锁标识，直接释放，释放错了锁。</li>
</ul>
<blockquote>
<p>线程2和线程1所用锁的key可能会相同吗？<br>锁的key是JVM唯一的前缀+userId+voucherId，并没有线程相关的标识，是可能相同的。</p>
</blockquote>
<p>造成问题的原因是判断锁标识和删除锁的<strong>非原子性</strong>。<br><strong>解决思路：</strong> 利用Lua脚本完成锁标识判断和分布式锁删除。<br><strong>Lua脚本内容：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>])==ARGVS[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="comment">--表示没有删除锁</span></span><br></pre></td></tr></table></figure>
<p>上一节中，Redis实现分布式锁的内容都在simpleRedisLock类中，包括tryLock和unlock，在unlock中调用Lua脚本。<br>首先在类中注入相关工具类和脚本路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<span class="comment">//这里的Long是函数返回类型</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        UNLOCK_SCRIPT=<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPath</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK.SCRIPT.setReturnType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在unlock中调用Lua脚本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        String threadId=VALUE_PREFIX+Thread.currentThread().getId();</span><br><span class="line">        stringRedisTemplate.execute(</span><br><span class="line">                UNLOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(KEY_PREFIX+name),</span><br><span class="line">                threadId</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-setnx分布式锁存在的问题"><a href="#4-setnx分布式锁存在的问题" class="headerlink" title="4.setnx分布式锁存在的问题"></a>4.setnx分布式锁存在的问题</h1><p><strong>不可重入性：</strong><br>线程1持有分布式锁，业务收到了阻塞，在这期间线程1可能还需要获取这个锁，但之前的实现方式是不允许的。<br><strong>不可重试性：</strong><br>线程获取锁失败后就返回，没有重试机制。<br><strong>超时释放：</strong><br>超时释放的问题在于，这个时间为多久？有些线程涉及到的业务流程比较长，有些线程比较短，超时释放存在一定的安全隐患。<br><strong>主从一致性：</strong><br>在集群环境下，如果主数据库宕机，此时从数据库中还没有把获得的分布式锁同步，选择一台从数据库作为新的主数据库时可能会导致问题。</p>
<h1 id="5-Redission"><a href="#5-Redission" class="headerlink" title="5.Redission"></a>5.Redission</h1><h2 id="5-1-Redission实现可重入锁的原理"><a href="#5-1-Redission实现可重入锁的原理" class="headerlink" title="5.1.Redission实现可重入锁的原理"></a>5.1.Redission实现可重入锁的原理</h2><img src="/2024/06/30/lock/img3.png" class="" title="img3">
<p>与setnx不同的是，redission用hash结构来实现分布式锁：fieldKey是线程标识，fieldValue标识锁计数。</p>
<ul>
<li>先检查有没有分布式锁，没有就新建一个；有就计数+1，同时刷新锁有效时间；</li>
<li>删除锁的时候，检查锁是不是自己的，如果不是说明已经过期等原因造成锁已经释放；</li>
<li>删除锁应该先锁计数-1，然后判断是不是计数&#x3D;0，等于0则直接释放锁，不是0要刷新锁有效时间。</li>
</ul>
<p>Redission都解决了setnx方式所存在的：不可重入性，不可重试性、超时释放、主从一致性问题。具体内容涉及到源码，暂时没了解。</p>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
