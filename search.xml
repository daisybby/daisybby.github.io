<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis注册为windows服务</title>
    <url>/2024/06/17/Redis%E6%B3%A8%E5%86%8C%E4%B8%BAwindows%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>安装完Redis需要用命令行启动，而且要保持这个窗口不关闭。</p>
<span id="more"></span>
<p>注册为windows服务后不再受控制台的影响。<br><strong>控制台输入：</strong><br><code>redis-server.exe --service-install redis.windows.conf </code><br><strong>开启Redis服务:</strong><br>控制台输入：<code>redis-server --service-start</code></p>
<blockquote>
<p>注意：在redis安装目录下进入cmd就能打开控制台。</p>
</blockquote>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
  </entry>
  <entry>
    <title>session、cookie和token</title>
    <url>/2024/06/18/session%E3%80%81cookie%E5%92%8Ctoken/</url>
    <content><![CDATA[<h1 id="session、cookie和token"><a href="#session、cookie和token" class="headerlink" title="session、cookie和token"></a>session、cookie和token</h1><ul>
<li>cookie：保存在客户端，用来解决客户端保存信息的问题。</li>
<li>session：保存在服务器端，每个客户端对应一个session。</li>
<li>token：无状态且跨域，能够有效防御CSRF，解决session依赖单个服务器的问题。</li>
</ul>
<span id="more"></span>
<h2 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h2><p>浏览器可以将服务器端发送的信息保存到cookie中，在浏览器之后每次发送请求时，可以将存活的cookie放到请求头一起发送给服务器端。</p>
<img src="/2024/06/18/session%E3%80%81cookie%E5%92%8Ctoken/cookie-and-session.png" class="" title="img1">
<h2 id="2-session"><a href="#2-session" class="headerlink" title="2.session"></a>2.session</h2><p>&ensp;&ensp;客户端向服务端发送请求，服务端为这个请求开辟一块内存空间，即session对象，保存方式为ConcurrentHashMap。<br>&ensp;&ensp;服务器端会为session设置过期时间，避免堆积大量session。（但在高并发场景下还是会有大量session，占据存储空间）<br>session和cookie协作的详细流程：</p>
<ul>
<li>step1:客户端发送http请求</li>
<li>step2:服务端创建session对象，将sessionID通过响应头的set-Cookie命令设置到cookie中。</li>
<li>step3:在浏览器会话期间，cookie都被保存到浏览器，之后每次浏览器发送请求都携带cookie。</li>
<li>step4:服务器通过请求携带的cookie解析出sessionID，找到对应的session。</li>
</ul>
<h2 id="3-token"><a href="#3-token" class="headerlink" title="3.token"></a>3.token</h2><p>出现token是因为cookie不支持跨域访问。<br><strong>token的工作原理：</strong></p>
<ul>
<li>客户端发送登录请求，将用户名和密码传递到服务器。</li>
<li>服务器验证用户信息通过，签发一个token，token中包含用户信息，token发送给客户端。</li>
<li>客户端接收到token保存到cookie或者Local Storage中，之后每次请求都携带token。</li>
<li>服务器受到请求后，解析验证token，验证通过即可放行。</li>
</ul>
<p>token模式下，服务器是不需要保存session的，因为token中包含有用户信息，解析出来利用即可。<br>更多内容等做到项目的权限管理模块，详细记录。</p>
]]></content>
      <categories>
        <category>基础概念和原理</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战项目笔记一：短信登录</title>
    <url>/2024/06/19/redis-1/</url>
    <content><![CDATA[<h1 id="笔记一：短信验证登录"><a href="#笔记一：短信验证登录" class="headerlink" title="笔记一：短信验证登录"></a>笔记一：短信验证登录</h1><p><strong>三个关键功能：</strong></p>
<span id="more"></span>
<p>1.用户提供手机号，获取6位数字验证码；</p>
<!--more-->
<p>2.用户提供手机号和验证码，进行登录；<br>3.对于用户请求，验证用户登录状态。</p>
<h2 id="一、业务逻辑"><a href="#一、业务逻辑" class="headerlink" title="一、业务逻辑"></a>一、业务逻辑</h2><h3 id="1-获取验证码"><a href="#1-获取验证码" class="headerlink" title="1.获取验证码"></a>1.获取验证码</h3><p>参数：用户手机号<br>返回：6位数字验证码<br>关键点就是要<strong>校验手机号格式</strong>、<strong>验证码保存到session</strong>中以备后续验证。</p>
<img src="/2024/06/19/redis-1/img1.png" class="" title="img1">

<h3 id="2-验证码登录"><a href="#2-验证码登录" class="headerlink" title="2.验证码登录"></a>2.验证码登录</h3><ol>
<li>用户提供手机号和验证码</li>
<li>信息校验：验证码匹配</li>
<li>校验手机号格式：虽然生成验证码时已经校验过，但用户在登陆时输入的手机号依然存在错误的可能性。</li>
<li>根据手机号查找用户信息，有则信息保存到session（便于后续登录验证）</li>
<li>用户不存在则创建新用户。</li>
</ol>
<img src="/2024/06/19/redis-1/img2.png" class="" title="img2">

<h3 id="3-登录状态检查"><a href="#3-登录状态检查" class="headerlink" title="3.登录状态检查"></a>3.登录状态检查</h3><p><strong>1.对于用户发来的请求，检查用户是否已经登录。</strong></p>
<ol>
<li>用户发来请求，请求携带cookie</li>
<li>根据cookie中的sessionID查找到对应的session（不需要后端程序员实现）</li>
<li>检查session中是否有用户信息，有则将用户信息保存到threadLocal（关键点）</li>
<li>session中没有用户信息，说明用户没有登录。</li>
</ol>
<img src="/2024/06/19/redis-1/img3.png" class="" title="img3">

<p><strong>2.什么时候验证用户登录状态？</strong><br>在请求到达服务器后，在调用对应的controller处理方法之前。那怎么实现？可以用过滤器和拦截器（详见<a href="https://zhuanlan.zhihu.com/p/697414738">过滤器和拦截器的区别与联系</a>）。<br><strong>3.验证后要做什么？为什么要用ThreadLocal，而不是将用户信息保持在session中？</strong><br>如果session中有用户信息，那这个信息就是登录时保存到session中的，说明已经登录过了。我们在从session中获取信息时，需要将HttpSession对象传递到方法中，如果在之后的service等多处还需要用户信息，会出现频繁传递session对象的问题，而且在高并发场景下，可能会出现session混乱。<br>在服务器端，每个请求对应一个线程，那么我们可以将用户信息保存成线程内部全局可见的，即ThreadLocal的形式。线程可以全局获取用户信息，提高开发效率。<br><strong>4.注意事项</strong><br>ThreadLocal也有缺点：</p>
<ul>
<li><strong>内存泄漏：</strong> ThreadLocal和线程是绑定的，线程一直存在，那么这部分内存一直占用，如果线程数量过多，可能会占据较大内存空间；如果不及时清理这部分空间，可能会导致内存泄漏。<blockquote>
<p>内存泄漏：内存因为一些原因没有释放或者无法释放，就是内存泄漏。</p>
</blockquote>
</li>
<li><strong>上下文切换问题：</strong> 每个线程可能都有自己的本地变量，当需要在线程间共享数据时，可能涉及到线程上下文切换，增加程序的复杂性和开销。</li>
</ul>
<blockquote>
<p><strong>一定要在请求处理完毕之后，将用户信息从threadLocal释放。</strong></p>
</blockquote>
<p><strong>5.拦截器和过滤器的区别是什么？</strong></p>
<img src="/2024/06/19/redis-1/img4.png" class="" title="img4">
<ul>
<li>Filter可以拦截一切请求，通常是筛选掉一些不和要求的请求；</li>
<li>Interceptor可以设置在请求被处理之前、被处理之后，或者是对请求到达controller之后，对返回的结果进行处理。可以调用业务逻辑！</li>
</ul>
<h2 id="二、session存在的问题"><a href="#二、session存在的问题" class="headerlink" title="二、session存在的问题"></a>二、session存在的问题</h2><ul>
<li>登录后用户信息暂存在session中，在高并发场景下需要较大的内存开销；</li>
<li>session是不能被多个tomcat服务器共享的，在分布式场景下session共享比较麻烦。<br><strong>session的作用是什么？</strong></li>
<li>基于内存的，访问速度快。</li>
<li>记录登录后的用户信息，保持登录状态。</li>
<li>需要多服务器都能够访问。<br>因此，可以用<strong>Redis</strong>来满足以上需求。</li>
</ul>
<h2 id="三、使用Redis优化登录验证"><a href="#三、使用Redis优化登录验证" class="headerlink" title="三、使用Redis优化登录验证"></a>三、使用Redis优化登录验证</h2><h3 id="1-生成验证码"><a href="#1-生成验证码" class="headerlink" title="1.生成验证码"></a>1.生成验证码</h3><ul>
<li>session下：验证码保存在session中，用sessionID标识唯一；</li>
<li>Redis下：验证码保存在Redis数据库，用Key标识，一个手机号对应一个验证码，故key用手机号。但是为了开发的便利性和直观性，需要在phone之前添加前缀（这是一种数据保存思想）。</li>
<li>更新后的流程图：<img src="/2024/06/19/redis-1/img5.png" class="" title="img5">
&ensp;&ensp;&ensp;&ensp;校验码需要设置<strong>过期时间</strong>，否则可能出现大量废弃校验码堆积，造成存储空间的浪费。</li>
</ul>
<h3 id="2-用户登录"><a href="#2-用户登录" class="headerlink" title="2.用户登录"></a>2.用户登录</h3><ul>
<li>session下：从session获取验证码-&gt;匹配验证码-&gt;用户信息保存到session；</li>
<li>Redis下：从Redis获取验证码-&gt;匹配验证码-&gt;用户信息保存到Redis<ul>
<li>校验码的Key是前缀+手机号</li>
<li>用户信息保存方式：String或者Hash类型，Hash类型可以修改用户某些信息，更灵活，用hash保存</li>
<li>用户信息的key是前缀+随机的token</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么需要随机的token？<br>答：因为用户发来请求，服务器需要识别这个请求是哪个用户的，sessionID类似的功能，但是我们又不能直接用手机号识别，对用户信息不安全。于是，可以用一个随机的token，登录成功后返回给客户端，之后每次请求都携带这个token即可。</p>
</blockquote>
<ul>
<li>流程图：<img src="/2024/06/19/redis-1/img6.png" class="" title="img6">
<strong>注意事项：</strong><br>&ensp;&ensp;&ensp;&ensp;登录成功后，用户信息保存在Redis中，但是需要设置过期时间，不然每次登录都会产生一个记录，造成存储空间的浪费。</li>
</ul>
<h3 id="3-验证登录状态"><a href="#3-验证登录状态" class="headerlink" title="3.验证登录状态"></a>3.验证登录状态</h3><ul>
<li>session下：用户传递来sessionID-&gt;session中获取用户信息-&gt;保存到ThreadLocal，便于这个请求处理期间使用；</li>
<li>Redis下：用户请求头携带token-&gt;根据token查找用户信息-&gt;保存到ThreadLocal。</li>
<li>流程图变化：<img src="/2024/06/19/redis-1/img7.png" class="" title="img7">
<strong>注意事项：</strong></li>
<li>验证登录状态是通过拦截器Interceptor实现的，这个实现并不属于Spring框架，是我们自己写的工具。</li>
<li>Interceptor中涉及到了StringRedisTemplate，这个不能用Autowire注解自动注入，需要在LoginInterceptor构造函数中手动注入。</li>
<li>但是LoginInterceptor是在MvcConfig中调用的，所以在MvcConfig中可以自动注入一个Redis工具类，然后传递到Interceptor就行。<blockquote>
<p>为什么需要刷新登录信息有效时间呢？<br>答：因为session的情况下，只要有访问，session的有效时间就是刷新的。但是Redis情况下，用expire设置用户信息过期时间，即使一直在访问，到了时间还是会自动过期，我们希望的是如果有访问，那么就不断刷新过期时间，30min完全没有操作再登录失效。</p>
</blockquote>
</li>
</ul>
<h2 id="四、存在的问题以及优化"><a href="#四、存在的问题以及优化" class="headerlink" title="四、存在的问题以及优化"></a>四、存在的问题以及优化</h2><h3 id="1-登录状态刷新优化"><a href="#1-登录状态刷新优化" class="headerlink" title="1.登录状态刷新优化"></a>1.登录状态刷新优化</h3><p><strong>问题：</strong> 用户登录后访问不被拦截的网页，超过了有效时间，然后再看个人信息，发现登录过期了。造成了不便。<br><strong>改进思路：</strong> 设置两个拦截器，第一个拦截器负责拦截所有请求，对于有登录状态的用户请求则刷新有效时间；第二个拦截器负责给第一个拦截器兜底，第一个拦截器放行了所有的请求，其中有些请求没有登录状态，那么有一些涉及到个人信息的请求还是需要拦截下来并拒绝的。<br><strong>实现效果：</strong> 对于任何请求，只要所属用户处于登录状态，就刷新登录信息的有效时间。</p>
<h3 id="2-将用户信息保存到Redis报错"><a href="#2-将用户信息保存到Redis报错" class="headerlink" title="2.将用户信息保存到Redis报错"></a>2.将用户信息保存到Redis报错</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDTO userDTO= BeanUtil.copyProperties(user,UserDTO.class);</span><br><span class="line">String token= UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//将user对象转换成hash</span></span><br><span class="line">Map&lt;String, Object&gt; hashMap=BeanUtil.beanToMap(userDTO);</span><br><span class="line"><span class="comment">//保存信息到Redis</span></span><br><span class="line">stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token,hashMap);</span><br><span class="line">stringRedisTemplate.expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在上面的代码中,直接将userDTO对象转换成HahMap，但是userDTO中部分字段并不是string类型，比如UID是Long类型，那么就会遇到转换成string类型的fieldValue报错。<br>解决方案是通过hutools提供的选择性拷贝工具copyOptions，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDTO userDTO= BeanUtil.copyProperties(user,UserDTO.class);</span><br><span class="line"><span class="comment">//用户信息保存到Redis中</span></span><br><span class="line"><span class="comment">//生成一个随机的token</span></span><br><span class="line">String token= UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//将user对象转换成hash</span></span><br><span class="line">Map&lt;String, Object&gt; hashMap=BeanUtil.beanToMap(userDTO,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create()</span><br><span class="line">        .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">        .setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line"><span class="comment">//保存信息到Redis</span></span><br><span class="line">stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token,hashMap);</span><br><span class="line">stringRedisTemplate.expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<h3 id="3-个人遇到的bug："><a href="#3-个人遇到的bug：" class="headerlink" title="3.个人遇到的bug："></a>3.个人遇到的bug：</h3><p>&ensp;&ensp;&ensp;&ensp;在编写userService实现类时，类有一个private成员变量stringRedisTemplate，但是我没有用@Resource注解修饰这个类，于是在之后使用这个类时出现了空指针异常。<br>&ensp;&ensp;&ensp;&ensp;原因：在类中注入bean有三种方式，一种是构造函数手动注入，一种是使用注解自动注入。<br><strong>1.</strong> 手动注入，我们在RefreshInterceptor中有用到，构造函数注入StringRedisTemplate对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate=stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong> 通过注解@Resource或者@Autowired注入。这里牵扯到一个八股文，Resource和Autowired的关系：<a href="https://daisybby.github.io/2024/06/20/Resource-and-Autowired/">Resource于Autowired的区别与联系</a></p>
<p>在这部分，似乎对Spring IOC容器对Bean管理的思想理解更加深刻了，相关的笔记待补充。</p>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Resource和Autowired之间的区别与联系</title>
    <url>/2024/06/20/Resource-and-Autowired/</url>
    <content><![CDATA[<h1 id="Resource和Autowired之间的关系"><a href="#Resource和Autowired之间的关系" class="headerlink" title="Resource和Autowired之间的关系"></a>Resource和Autowired之间的关系</h1><h2 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1.相同点"></a>1.相同点</h2><span id="more"></span>
<p>Resource和Autowired都是获取IOC容器中的bean对象。<br>在单例模式下，以下代码获取到的对象是相同的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> User user1;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> User user2;</span><br></pre></td></tr></table></figure>
<h2 id="2-不同点"><a href="#2-不同点" class="headerlink" title="2.不同点"></a>2.不同点</h2><h3 id="2-1-支持方不同"><a href="#2-1-支持方不同" class="headerlink" title="2.1.支持方不同"></a>2.1.支持方不同</h3><ul>
<li><strong>Resource:</strong> 属于JDK，支持更多的参数设置，比如可以设置name和type；所有的IOC容器都支持Resource注解，框架迁移时不需要修改。</li>
<li><strong>Autowired:</strong> 属于Spring框架，其他的框架可能不支持。</li>
</ul>
<h3 id="2-2-匹配顺序不同"><a href="#2-2-匹配顺序不同" class="headerlink" title="2.2.匹配顺序不同"></a>2.2.匹配顺序不同</h3><ul>
<li><strong>Resource:</strong> 名称-&gt;类型；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;BeanOne&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanOne</span> <span class="keyword">implements</span> <span class="title class_">Bean</span> &#123;&#125;</span><br><span class="line"><span class="meta">@Component(&quot;BeanTwo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTwo</span> <span class="keyword">implements</span> <span class="title class_">Bean</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">//1.会报错，先按照type同时匹配到BeanOne和BeanTwo，再按照名称匹配bean，没有name为bean的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.按照type同时匹配到BeanOne和BeanTwo，再按照名称匹配到BeanOne</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用type匹配到beanOne和beanTwo，Qualifier指定了要匹配的名称，匹配到beanOne</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;beanOne&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Autowired:</strong> 类型-&gt;名称；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">//1.先按照name匹配，没有，再按照type匹配到两个，无法确定，报错。</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.按照名称，一次匹配成功</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Bean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.指定匹配类型</span></span><br><span class="line">    <span class="meta">@Resource(type=BeanOne.class)</span></span><br><span class="line">    <span class="keyword">private</span> Bean bean;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论是Resource还是Autowired，匹配都是<strong>不区分大小写</strong>的。</p>
</blockquote>
</li>
</ul>
<h3 id="2-3-作用域不同"><a href="#2-3-作用域不同" class="headerlink" title="2.3.作用域不同"></a>2.3.作用域不同</h3><ul>
<li><strong>Autowired:</strong> 用于setter、构造器、属性。<blockquote>
<p>尽管用于setter时，setter函数有参数，但是并不需要我们显示调用这个setter。</p>
</blockquote>
</li>
<li><strong>Resource:</strong> setter和属性。</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>常用注解</tag>
      </tags>
  </entry>
  <entry>
    <title>setFieldValueEditor出现空指针异常</title>
    <url>/2024/06/21/setFieldValueEditor-bug/</url>
    <content><![CDATA[<h1 id="Hutool提供的BeanUtil-beanToMap出现空指针异常"><a href="#Hutool提供的BeanUtil-beanToMap出现空指针异常" class="headerlink" title="Hutool提供的BeanUtil.beanToMap出现空指针异常"></a>Hutool提供的BeanUtil.beanToMap出现空指针异常</h1><p>先看bug出现的位置：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = BeanUtil.beanToMap(shop, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>) <span class="comment">//忽略空值</span></span><br><span class="line">                .setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(CACHE_SHOP_KEY + id, map);</span><br><span class="line">stringRedisTemplate.expire(CACHE_SHOP_KEY + id, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>以上代码将shop对象以hash形式保存到Redis，但是实际运行时出现了空指针异常。<br>如果shop对象里面有属性值为null，就会出现如下空指针异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NullPointerException: <span class="literal">null</span></span><br><span class="line">	at com.hmdp.service.impl.ShopServiceImpl.lambda$queryById$<span class="number">0</span>(ShopServiceImpl.java:<span class="number">56</span>) ~[classes/:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.CopyOptions.editFieldValue(CopyOptions.java:<span class="number">258</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.BeanCopier.lambda$beanToMap$<span class="number">1</span>(BeanCopier.java:<span class="number">233</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at java.util.LinkedHashMap$LinkedValues.forEach(LinkedHashMap.java:<span class="number">608</span>) ~[na:<span class="number">1.8</span><span class="number">.0_401</span>]</span><br><span class="line">	at cn.hutool.core.bean.BeanUtil.descForEach(BeanUtil.java:<span class="number">182</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.BeanCopier.beanToMap(BeanCopier.java:<span class="number">195</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.copier.BeanCopier.copy(BeanCopier.java:<span class="number">106</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br><span class="line">	at cn.hutool.core.bean.BeanUtil.beanToMap(BeanUtil.java:<span class="number">690</span>) ~[hutool-all-<span class="number">5.7</span><span class="number">.17</span>.jar:na]</span><br></pre></td></tr></table></figure>
<p><strong>已经设置了setIgnoreNullValue为true，忽略空值，为什么还会出现这个问题？</strong><br>准确来说，报错的地方时fieldValue.toString()，尽管设置了忽略空值，但是fieldValue.toString()还是会执行的，null当然有空指针异常。<br><strong>具体原因：</strong></p>
<ul>
<li>setFieldValueEditor的触发优先级高于setIgnoreNullValue，我们需要在setFieldValueEditor中进行判空;</li>
<li>可能shop部分属性是允许null的，我们希望给一个默认值，如果先执行setIgnoreNullValue，可能会导致这部分属性被过滤掉，不保存到Redis中去。</li>
</ul>
<p><strong>解决方案：</strong><br>我们在setFieldValueEditor中判空处理就行。</p>
<img src="/2024/06/21/setFieldValueEditor-bug/image.png" class="" title="img">
<p>可以看到distance的值是null，我们用默认属性0来替代就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = BeanUtil.beanToMap(shop, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>) <span class="comment">//忽略空值</span></span><br><span class="line">                .setFieldValueEditor((fieldName,fieldValue)-&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(fieldValue==<span class="literal">null</span>)&#123;</span><br><span class="line">                        fieldValue=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        fieldValue=fieldValue.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> fieldValue;</span><br><span class="line">                &#125;));</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(CACHE_SHOP_KEY + id, map);</span><br><span class="line">stringRedisTemplate.expire(CACHE_SHOP_KEY + id, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Bug实录</category>
      </categories>
      <tags>
        <tag>Hutool</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2024/06/22/Bloom-Filter/</url>
    <content><![CDATA[<h1 id="布隆过滤器的概念和原理"><a href="#布隆过滤器的概念和原理" class="headerlink" title="布隆过滤器的概念和原理"></a>布隆过滤器的概念和原理</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><span id="more"></span>
<p>布隆过滤器是一种数据结构，用于快速检索元素是否可能存在于一个集合中。<br>布隆过滤器的两个重要组成：K个hash函数和一个bit数组。</p>
<h2 id="3-布隆过滤器的工作过程"><a href="#3-布隆过滤器的工作过程" class="headerlink" title="3.布隆过滤器的工作过程"></a>3.布隆过滤器的工作过程</h2><p><strong>存储元素</strong><br>对于一个元素item，通过K个hash函数计算出多个hash索引，然后将这些索引对应的位都设置为1，如果这些位置已经为1，不需要再次设置。<br><strong>查询元素</strong><br>判断元素item是否存在，也是检查K个hash函数计算出来的位置是否都为1：</p>
<ul>
<li>如果有0，那这个元素一定不存在。</li>
<li>如果全为1，元素可能存在，也可能不存在。</li>
</ul>
<p>查询时间效率是O(K)，K表示hash函数个数。（可以，这很ok~)<br><strong>删除元素</strong><br>将item对应的hash位置都设置为0。但是这存在问题，如果发生了hash冲突，会误删其他元素。</p>
<img src="/2024/06/22/Bloom-Filter/img1.png" class="" title="img1">

<h2 id="3-布隆过滤器的误判"><a href="#3-布隆过滤器的误判" class="headerlink" title="3.布隆过滤器的误判"></a>3.布隆过滤器的误判</h2><p>为什么全1是“可能”存在，而不是“肯定”存在？<br>有可能根本就不存在”hello”这个单词，但是bit数组中这个单词对应的hash值位置都是1，已经表达了其他的单词，那按照“hash位置全为1则存在”的规则，得到的是”hello”存在的假象。<br>归根结底，布隆过滤器的误判是由hash冲突造成的。想要降低误判概率，主要的办法就是降低hash冲突发生的概率，增加hash算法个数或者扩大bit数组。</p>
<img src="/2024/06/22/Bloom-Filter/img2.png" class="" title="img2">
<p><strong>可以利用布隆过滤器判断不存在，解决缓存穿透恰好就是利用布隆过滤器判断不存在。</strong></p>
<h2 id="4-常见应用"><a href="#4-常见应用" class="headerlink" title="4.常见应用"></a>4.常见应用</h2><ul>
<li><strong>网页爬虫：</strong> 过滤掉已经爬取的网页，避免重复爬取，浪费资源。</li>
<li><strong>缓存系统：</strong> 判断一个查询是否存在于缓存中，减少缓存查询次数。更重要的是，布隆过滤器经常用来解决缓存穿透的问题（判断不存在）。</li>
<li><strong>分布式系统：</strong> 判断元素是否存在于分布式缓存中，避免在所有节点上进行查询，减少网络负载。</li>
<li><strong>垃圾邮件过滤：</strong> 判断邮件地址是否在垃圾邮件列表中。</li>
<li><strong>黑名单过滤：</strong> 判断IP地址或者手机号是否在黑名单中。</li>
</ul>
<h2 id="4-如何使用布隆过滤器"><a href="#4-如何使用布隆过滤器" class="headerlink" title="4.如何使用布隆过滤器"></a>4.如何使用布隆过滤器</h2><h3 id="1-通过Google-Guava库"><a href="#1-通过Google-Guava库" class="headerlink" title="1.通过Google Guava库"></a>1.通过Google Guava库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilterExample</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建布隆过滤器，预计插入100个元素，误判率为1%</span></span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter=BloomFilter.create(Funnels.stringFunnel(),<span class="number">100</span>,<span class="number">0.01</span>);</span><br><span class="line">        </span><br><span class="line">        bloomFilter.put(<span class="string">&quot;Daisybby&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断元素是否存在</span></span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;Daisybby&quot;</span>));</span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;what&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-通过Apache-Commons"><a href="#2-通过Apache-Commons" class="headerlink" title="2.通过Apache Commons"></a>2.通过Apache Commons</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.HashFunctionIdentity;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilterExample</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter=<span class="keyword">new</span> <span class="title class_">BloomFilter</span>&lt;&gt;(HashFunctionIdentity.hashFunction(StringUtils::hashCode),<span class="number">100</span>,<span class="number">0.01</span>);</span><br><span class="line">        </span><br><span class="line">        bloomFilter.put(<span class="string">&quot;Daisybby&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断元素是否存在</span></span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;Daisybby&quot;</span>));</span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;what&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-在Redis中可以通过Bloom模块来使用，使用Redisssion可以："><a href="#3-在Redis中可以通过Bloom模块来使用，使用Redisssion可以：" class="headerlink" title="3.在Redis中可以通过Bloom模块来使用，使用Redisssion可以："></a>3.在Redis中可以通过Bloom模块来使用，使用Redisssion可以：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Config config=<span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson=Redisson.create(config);</span><br><span class="line">RBloomFilter&lt;String&gt; bloomFilter=redisson.getBloomFilter(<span class="string">&quot;myFilter&quot;</span>);</span><br><span class="line">bloomFilter.tryInit(<span class="number">100</span>,<span class="number">0.01</span>);</span><br><span class="line">bloomFilter.add(<span class="string">&quot;Daisybby&quot;</span>);</span><br><span class="line">bloomFilter.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">bloomFilter.add(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(bloomFilter.contains(<span class="string">&quot;Daisybby&quot;</span>));</span><br><span class="line">System.out.println(bloomFilter.contains(<span class="string">&quot;what&quot;</span>));</span><br><span class="line">redisson.shutdown();</span><br></pre></td></tr></table></figure>
<p>Jedis也可以，不再赘述。</p>
]]></content>
      <categories>
        <category>基础概念和原理</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战项目笔记二：查询缓存</title>
    <url>/2024/06/23/redis-project-note2/</url>
    <content><![CDATA[<h1 id="一、添加商户缓存"><a href="#一、添加商户缓存" class="headerlink" title="一、添加商户缓存"></a>一、添加商户缓存</h1><p><strong>业务需求：</strong></p>
<span id="more"></span>
<p>客户端提供商户id，返回商户信息。<br><strong>技术关键点：</strong></p>
<img src="/2024/06/23/redis-project-note2/img1.png" class="" title="img1">
<p>对于查询业务，为了提高系统的查询性能，使用Redis加快查询。</p>
<blockquote>
<p>遇到了Bug：<br>bug描述：<br>以hash形式将商铺信息保存到Redis，在用Hutool提供的BeanUtil.beanToMap时遇到了空指针异常。<br>bug解决方式可见：<a href="https://daisybby.github.io/2024/06/21/setFieldValueEditor-bug/#more">Hutool提供的BeanUtil.beanToMap出现空指针异常</a></p>
</blockquote>
<h1 id="二、为商铺类型添加缓存"><a href="#二、为商铺类型添加缓存" class="headerlink" title="二、为商铺类型添加缓存"></a>二、为商铺类型添加缓存</h1><p><strong>业务需求：</strong>首页有多个商铺分类，为商铺分类信息的查询添加Redis作为缓存，提高查询效率。<br><strong>流程图：</strong></p>
<img src="/2024/06/23/redis-project-note2/img2.png" class="" title="img2">
<p><strong>用什么类型保存呢？</strong></p>
<ul>
<li>可以用list、set和zset三种数据类型实现。list的元素是可以重复的，但是set和zset要保证元素的唯一性。商铺类型是唯一的，所以我们可以用set和zset来实现。</li>
<li>商铺有自己的sort属性，我们希望按照sort属性升序排序，那么我们可以用zset有序集合来实现。</li>
</ul>
<blockquote>
<p>其实也可以用list和set来实现，因为shopType每次都是全部获取，读取出来再重新排序即可。</p>
</blockquote>
<p>不过我还是选择了比较复杂的zset来练练手，嘿嘿。<br>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryAllType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.从Redis查询所有商铺类型</span></span><br><span class="line">        Set&lt;String&gt; shopTypeList=stringRedisTemplate.opsForZSet().range(CACHE_SHOPTYPE_KEY,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//2.查询成功，返回</span></span><br><span class="line">        <span class="keyword">if</span>(shopTypeList!=<span class="literal">null</span> &amp;&amp; !shopTypeList.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将String字符串转换成对象</span></span><br><span class="line">            List&lt;ShopType&gt; shopTypes=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String shopType: shopTypeList)&#123;</span><br><span class="line">                shopTypes.add(JSONUtil.toBean(shopType,ShopType.class));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shopTypes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.查询失败，从数据库查询</span></span><br><span class="line">        List&lt;ShopType&gt; shopTypes=query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">        <span class="keyword">if</span>(shopTypes==<span class="literal">null</span> || shopTypes.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;没有商铺类型！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将商铺类型数据保存到Redis</span></span><br><span class="line">        <span class="keyword">for</span>(ShopType shopType:shopTypes)&#123;</span><br><span class="line">            stringRedisTemplate.opsForZSet().add(CACHE_SHOPTYPE_KEY,JSONUtil.toJsonStr(shopType),shopType.getSort());</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.expire(CACHE_SHOPTYPE_KEY,CACHE_SHOPTYPE_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//5.返回商铺类型信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shopTypes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将shopType转换为JSON字符串，保存到zset有序集合中。</li>
<li>zset的保存语法add有三个参数，key，value和分数，这里的分数是shopType的sort字段值。zset默认按照分数从小到大排序，如果要倒序读取，可以把第3行的range换成reverseRange。或者保存的时候，sort取负值倒序保存。</li>
</ul>
<h1 id="三、缓存更新策略"><a href="#三、缓存更新策略" class="headerlink" title="三、缓存更新策略"></a>三、缓存更新策略</h1><h2 id="3-1-三种缓存更新策略"><a href="#3-1-三种缓存更新策略" class="headerlink" title="3.1.三种缓存更新策略"></a>3.1.三种缓存更新策略</h2><img src="/2024/06/23/redis-project-note2/img3.png" class="" title="img3">
<blockquote>
<p><strong>怎么选择更新策略呢？</strong></p>
<ul>
<li><strong>低一致性需求：</strong> 使用<strong>内存淘汰机制</strong>。例如商铺类别信息，虽然也有数据修改的可能性，但可能性很低，而且数据就这么多，直接保存到缓存就行，每次登录都会需要读取这部分数据。这也解释了为什么没有给缓存中的shopType数据设置过期时间。</li>
<li><strong>高一致性需求：主动更新+超时删除（兜底）</strong> 。例如商铺详情信息的缓存。</li>
</ul>
</blockquote>
<h2 id="3-2-操作缓存和数据库需要考虑的问题"><a href="#3-2-操作缓存和数据库需要考虑的问题" class="headerlink" title="3.2.操作缓存和数据库需要考虑的问题"></a>3.2.操作缓存和数据库需要考虑的问题</h2><h3 id="1-删除缓存还是更新缓存？"><a href="#1-删除缓存还是更新缓存？" class="headerlink" title="1.删除缓存还是更新缓存？"></a>1.删除缓存还是更新缓存？</h3><p>当数据库中的数据进行了更新，我们有两种策略来保证数据一致性：</p>
<ul>
<li>更新缓存：缓存数据做相应的修改；</li>
<li>删除缓存：直接删除这部分的缓存数据，下次查询时缓存未命中-&gt;查询数据库-&gt;新数据存入缓存。</li>
</ul>
<p><strong>性能分析：</strong></p>
<ul>
<li>更新缓存：一些数据更新操作比较频繁，但是访问频率很低，这就导致了大量无效的写缓存操作，且占用了缓存空间还用不到。</li>
<li>删除缓存：对于访问频率很低数据，本来就不会访问，所以没什么影响；对于访问频繁的数据，首次访问缓存未命中，但是后续加入缓存，不会对访问速度造成太大影响，而且也不会出现大量无效写缓存操作，缓存空间开销都是有用的。<blockquote>
<p>综上，选择<strong>删除缓存</strong>比较合理。</p>
</blockquote>
</li>
</ul>
<h3 id="2-如何保证缓存与数据库操作的原子性？同时成功或失败"><a href="#2-如何保证缓存与数据库操作的原子性？同时成功或失败" class="headerlink" title="2.如何保证缓存与数据库操作的原子性？同时成功或失败"></a>2.如何保证缓存与数据库操作的原子性？同时成功或失败</h3><ul>
<li>单体系统：将数据库和缓存操作放在一个事务中完成。</li>
<li>分布式系统：利用TCC等分布式事务方案。<font color="red">（这部分涉及到了分布式，等后续学习SpringCloud时再补充）</font></li>
</ul>
<h3 id="3-先操作缓存还是先操作数据库？"><a href="#3-先操作缓存还是先操作数据库？" class="headerlink" title="3.先操作缓存还是先操作数据库？"></a>3.先操作缓存还是先操作数据库？</h3><p>在学习多线程时就搞不清楚线程安全发生的场景怎么分析，多线程工作怎么出现冲突，发现了画图法这个妙妙方法。</p>
<img src="/2024/06/23/redis-project-note2/img4.png" class="" title="img4">
<p><strong>先删除缓存，再更新数据库：</strong></p>
<ul>
<li>线程不安全，在线程1更新数据库期间，线程2缓存访问未命中，然后读取数据库中的旧数据，存入缓存，最终出现：数据库-新数据，缓存-旧数据。</li>
<li>异常发生概率分析：在数据库更新期间，发生了三件事（缓存读、数据库读、缓存写），因为更新数据库的时间通常是比这三操作发生时间长，所以异常发生概率是比较高的。</li>
</ul>
<img src="/2024/06/23/redis-project-note2/img5.png" class="" title="img5">
<p><strong>先操作数据库，再删除缓存：</strong></p>
<ul>
<li>也有极端情况。在线程1先读取了数据库旧数据之后，把旧数据写入缓存之间，线程2完成了更新数据库和删除缓存操作。删除缓存操作就不讨论，没太大影响，关键是写缓存操作时间远远短于更新数据库时间，这种情况是<strong>很难发生</strong>的。</li>
<li>异常发生概率很低，所以可以考虑这种方式。<blockquote>
<p>综上：<strong>先更新数据库，再删除缓存</strong>是更安全合理的。</p>
</blockquote>
</li>
</ul>
<h1 id="四、缓存穿透、缓存雪崩和缓存击穿-（重难点）"><a href="#四、缓存穿透、缓存雪崩和缓存击穿-（重难点）" class="headerlink" title="四、缓存穿透、缓存雪崩和缓存击穿*（重难点）"></a>四、缓存穿透、缓存雪崩和缓存击穿*（重难点）</h1><h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h2><p><strong>缓存穿透</strong>是指客户端请求的数据在<strong>缓存和数据库都不存在</strong>，这样缓存永远不会生效，这些请求都会打到数据库。<br><strong>常见解决方案：</strong></p>
<ul>
<li>缓存空对象：<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：消耗内存，可能会出现短期数据不一致（缓存中保存了null且没过期，数据库中已经插入了对应的数据）。<img src="/2024/06/23/redis-project-note2/img6.png" class="" title="img6"></li>
</ul>
</li>
<li>布隆过滤器<ul>
<li>优点：内存占用较少，没有多余的key</li>
<li>缺点：<ul>
<li>布隆过滤器实现复杂</li>
<li>存在误判的可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>布隆过滤器的基本原理：<a href="https://daisybby.github.io/2024/06/22/Bloom-Filter/#more">布隆过滤器原理及其应用</a></p>
</blockquote>
<img src="/2024/06/23/redis-project-note2/img7.png" class="" title="img7">
<blockquote>
<p>本来想在这里实现布隆过滤器解决缓存穿透问题，但好像牵扯的比较多，需要考虑到项目启动和数据预热，等做到数据预热的时候来解决这部分问题。现在先通过null值方法来解决。<br><strong>通过null值解决缓存穿透问题：</strong><br>如果redis和数据库中都不存在对应的数据，那么在redis中设置一个null，防止请求再打到数据库。<br>但是我们是用hash结构保存的对象（shop为例），那么该怎么表示呢？代码中是获取的hash，我们直接添加一个字段exist，取0表示null，取1表示对象真的存在就行。</p>
</blockquote>
<h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><p><strong>缓存雪崩</strong>是指短时间内有大量缓存key失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。<br><strong>常见解决方案：</strong></p>
<ul>
<li>给不同Key的TTL添加随机值，避免同一时间大量key过期；</li>
<li>利用Redis集群提高服务的可用性；</li>
<li>给缓存业务添加降级限流策略；</li>
<li>给业务添加多级缓存。</li>
</ul>
<h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3.缓存击穿"></a>3.缓存击穿</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>缓存击穿</strong>也被称为热点key问题，一个被<strong>高并发访问</strong>并且<strong>缓存重建业务复杂</strong>（可以理解为缓存更新耗时长）的热点数据突然失效，导致大量的请求直接打到数据库，且大量线程困于缓存重建，造成系统性能下降。</p>
<img src="/2024/06/23/redis-project-note2/img8.png" class="" title="img8">
<p><strong>常见的解决方案：</strong></p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<h3 id="3-1-互斥锁"><a href="#3-1-互斥锁" class="headerlink" title="3.1.互斥锁"></a>3.1.互斥锁</h3><p>&ensp;&ensp;&ensp;&ensp;线程在查询数据库重建缓存之前先<strong>获取互斥锁</strong>。其他线程发现缓存未命中，获取互斥锁失败会<strong>循环重试</strong>查询缓存，直至缓存命中。</p>
<img src="/2024/06/23/redis-project-note2/img9.png" class="" title="img9">
<h3 id="3-2-逻辑过期"><a href="#3-2-逻辑过期" class="headerlink" title="3.2.逻辑过期"></a>3.2.逻辑过期</h3><p>&ensp;&ensp;&ensp;&ensp;缓存数据过期时并不是清除，而是发现逻辑过期，申请互斥锁，成功后开启一个<strong>新线程</strong>，查询数据库并重建缓存，<strong>新线程释放互斥锁</strong>。在查询数据库重建缓存期间，其他线程申请互斥锁失败，<strong>返回缓存中的旧数据</strong>。</p>
<img src="/2024/06/23/redis-project-note2/img10.png" class="" title="img10">
<h3 id="3-3-性能分析与对比"><a href="#3-3-性能分析与对比" class="headerlink" title="3.3.性能分析与对比"></a>3.3.性能分析与对比</h3><img src="/2024/06/23/redis-project-note2/img11.png" class="" title="img11">
<h3 id="3-4-代码实现互斥锁解决缓存击穿"><a href="#3-4-代码实现互斥锁解决缓存击穿" class="headerlink" title="3.4.代码实现互斥锁解决缓存击穿"></a>3.4.代码实现互斥锁解决缓存击穿</h3><img src="/2024/06/23/redis-project-note2/img12.png" class="" title="img12">
<blockquote>
<p>这部分的实现过程，算是一个难点，可以详细记录，作为项目难点。</p>
</blockquote>
<ol>
<li><strong>查询缓存，根据是否命中决定下一步操作</strong><br>需要注意的是，我们这里也要考虑缓存穿透问题，即使从redis获取的hashMap不是空的，也有可能exist字段为0。</li>
<li><strong>缓存未命中，为了避免发生缓存击穿，也就是多个请求访问的是同一个数据，短时间内都未命中，请求打到数据库</strong></li>
</ol>
<ul>
<li>取互斥锁：在redis中通过setIfAbsent添加字段lockKey，如果redis中已经有lockKey就不会再添加成功；</li>
<li>如果获取锁失败，则线程sleep一段时间（埋个坑，sleep时间怎么决定？），然后递归查询。</li>
<li>如果锁获取成功，查询数据库，查询不到则根据缓存穿透的解决策略设置exist字段；更新缓存，记得设置过期时间。</li>
<li>释放互斥锁。</li>
</ul>
<ol start="3">
<li><strong>线程sleep、递归和释放互斥锁三个关键点</strong><br>&ensp;&ensp;&ensp;&ensp;线程sleep是需要处理异常的，我们可以从获取互斥锁到更新完缓存，这段都包含在try catch块中，将unlock放在finally中，避免sleep异常导致互斥锁无法释放。<br>&ensp;&ensp;&ensp;&ensp;递归是在try catch块中的，尽管递归，但只要缓存命中，就会在到达finally之前层层return，因此不会出现没有申请到互斥锁，但是每次递归都unlock的情况。但是finally又保证了只要正常执行，一定会有unlock操作。<blockquote>
<p>这部分内容需要反复理解。</p>
</blockquote>
</li>
</ol>
<p>高并发场景的测试，需要用到JMeter，进行压力测试。</p>
<h3 id="3-5-通过逻辑过期解决缓存击穿"><a href="#3-5-通过逻辑过期解决缓存击穿" class="headerlink" title="3.5.通过逻辑过期解决缓存击穿"></a>3.5.通过逻辑过期解决缓存击穿</h3><img src="/2024/06/23/redis-project-note2/img13.png" class="" title="img13">
<p><strong>代码实现要点：</strong></p>
<ul>
<li>Redis中给shop增加一个属性段：过期时间。但是要保持不修改原有业务逻辑和代码，那么编写一个新的类RedisData，将过期时间和Shop对象打包成一个对象。</li>
<li>为什么缓存未命中，直接返回呢？因为逻辑过期策略里，缓存中没有就是业务涉及不到的数据，因为业务数据不会真的从缓存中消失，所以这里可以不考虑缓存穿透的问题。</li>
<li>线程成功获取到互斥锁时，一定要<strong>再次校验</strong>数据是否过期：因为可能出现如下情况：多线程情况下反复更新缓存。<img src="/2024/06/23/redis-project-note2/img14.png" class="" title="img14"></li>
</ul>
<h1 id="四、Redis工具类封装"><a href="#四、Redis工具类封装" class="headerlink" title="四、Redis工具类封装"></a>四、Redis工具类封装</h1><p>对于Redis解决缓存穿透、缓存击穿等问题的实现代码，不应该和业务逻辑代码混在一起。之前的代码都是针对shop写的，实际上user、product等实体也都需要实现。那么我们可以利用泛型封装这些方法。<br><strong>封装的方法如下：</strong></p>
<ul>
<li>set方法：向redis保存对象<ul>
<li>传入参数：key、Object对象、过期时间、时间单位</li>
<li>返回结果:void</li>
</ul>
</li>
<li>setWithLogicalExpire：向Redis保存对象，但要携带逻辑过期时间<ul>
<li>传入参数：key，Object对象、逻辑过期时间、时间单位</li>
<li>返回结果：void</li>
</ul>
</li>
<li>tryLock：逻辑过期时间线程尝试获取互斥锁<ul>
<li>传入参数：key。是指互斥锁的key</li>
<li>返回结果：boolean</li>
</ul>
</li>
<li>unlock：释放互斥锁<ul>
<li>传入参数：互斥锁的key</li>
<li>返回结果：void</li>
</ul>
</li>
<li>queryWithPassThrough：解决缓存穿透<ul>
<li>传入参数：<ul>
<li>String：keyPrefix，缓存中key前缀，如shop的前缀CACHE_SHOP_KEY。</li>
<li>ID：id，ID是一个泛型，因为实体id不一定都是Long或者都是String，有可能都有。</li>
<li>Class<R>：type，传入一个对象的类型，比如Shop.class。</li>
<li>Function&lt;ID,R&gt;：dbFallBack，通过id向数据库查询实体的函数，因为可能是查shop也可能是User，返回类型是一个R类型的对象，ID是传入查询方法的参数类型。在项目中是getById。</li>
<li>Long：time，设置的缓存过期时间</li>
<li>TimeUnit：unit，时间单位。</li>
</ul>
</li>
<li>返回结果：R类型的一个对象，比如一个shop对象。</li>
</ul>
</li>
<li>queryWithLogicalExpire：逻辑过期时间解决缓存击穿<ul>
<li>传入参数：<ul>
<li>String：keyPrefix，缓存key前缀。</li>
<li>String：lockKeyPrefix，互斥锁的前缀，因为互斥锁是和要查询的具体对象id有关。</li>
<li>ID：id，泛型，表示实体的id。</li>
<li>Class<R>：type，泛型，表示传入一个对象类型。</li>
<li>Function&lt;ID,R&gt;：dbFallBack，传入从数据库查询数据的方法，ID是参数类型，R是返回类型。</li>
<li>Long：time，逻辑过期时间。</li>
<li>TimeUnit：unit，逻辑过期时间的单位。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>查询缓存基本结束。一边写代码，一边查资料解答自己的疑惑，还想要写笔记输出。说实话很累，但感觉自己学习的比较清楚。不过学完觉得缓存穿透、缓存雪崩和缓存击穿的概念以及常见解决方案，还是比较生疏，自己的笔记还是要多看的，不能总结了不看。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis保存对象为String还是hash？</title>
    <url>/2024/06/23/save-object-as-string-or-hash/</url>
    <content><![CDATA[<h1 id="1-对象序列化后保存到Redis"><a href="#1-对象序列化后保存到Redis" class="headerlink" title="1.对象序列化后保存到Redis"></a>1.对象序列化后保存到Redis</h1><p>保存的是序列化后的对象，这种方式在Redis中很难看出来对象的含义。</p>
<span id="more"></span>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁性：</strong> 直接序列化整个对象，不需要考虑字段的单独存储。</li>
<li><strong>原子性：</strong> 对整个对象进行存取。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>序列化依赖：</strong> 依赖于特定的序列化库，可能影响性能和跨语言使用。</li>
<li><strong>可读性：</strong> 二进制格式的字符串不易于阅读和调试。</li>
<li><strong>灵活性差：</strong> 如果对象结构发生变化，需要重新序列化。</li>
</ul>
<h1 id="2-将对象转换成Json格式"><a href="#2-将对象转换成Json格式" class="headerlink" title="2.将对象转换成Json格式"></a>2.将对象转换成Json格式</h1><p>Redis中保存的是JSON格式的字符串，可以清晰阅读对象的内容。<br><strong>优点：</strong> </p>
<ul>
<li><strong>跨语言性：</strong> JSON是一种跨语言的格式，易于在不同语言和系统之间交换数据。</li>
<li><strong>可读性：</strong> JSON格式的数据易于阅读。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>灵活性：</strong>不支持对象单个属性的存取，如果要修改对象属性只能整个对象读取修改重建。</li>
<li><strong>复杂结构存储：</strong>不适合存储复杂的对象结构，比如对象存在嵌套。</li>
</ul>
<h1 id="3-用hash存储对象"><a href="#3-用hash存储对象" class="headerlink" title="3.用hash存储对象"></a>3.用hash存储对象</h1><p>Redis的key作为整个hash结构在Redis中的索引；<br>fieldName是对象的属性名称；<br>fieldValue就是属性值。<br><strong>优点：</strong></p>
<ul>
<li><strong>可读性：</strong>hash保存对象结构清晰；</li>
<li><strong>灵活性：</strong>支持对单个属性的操作，只需要根据对应的fieldName来设置fieldValue即可。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>处理嵌套的对象比较麻烦。</li>
</ul>
<h1 id="4-怎么选取呢？"><a href="#4-怎么选取呢？" class="headerlink" title="4.怎么选取呢？"></a>4.怎么选取呢？</h1><p><strong>更新频繁的数据：</strong> 可以通过hash结构存储对象。<br><strong>读频繁的数据：</strong> 对于更新频率比较低，但是读取比较频繁的数据，选择string是比较好的方案。</p>
<blockquote>
<p>实际业务开发中，可以结合string和hash。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础概念和原理</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务</title>
    <url>/2024/06/26/Transaction/</url>
    <content><![CDATA[<h1 id="一、事务的四个特性"><a href="#一、事务的四个特性" class="headerlink" title="一、事务的四个特性"></a>一、事务的四个特性</h1><p>ACID：原子性、一致性、隔离性、持久性。</p>
<span id="more"></span>
<h1 id="二、事务的隔离级别"><a href="#二、事务的隔离级别" class="headerlink" title="二、事务的隔离级别"></a>二、事务的隔离级别</h1><p>数据库事务的隔离级别有四种，从低到高分别是:Read uncommitted、Read committed、Repeatable read、Serializable。事务可能会导致一些问题：脏读、幻读、不可重复读、事务丢失。</p>
<ul>
<li><strong>脏读：读取了未提交的事务，然后事务回滚了。</strong><br>  事务A修改了数据库，被事务B读取了，读取之后事务A回滚。</li>
<li><strong>不可重复读：读取了新提交的事务，指更新操作，导致同一个事务中两次读取不一致。</strong><br>事务A先读取数据库得到value1，然后事务B修改数据库为value2，然后事务A又读到了value2，value1与value2是不一致的。</li>
<li><strong>幻读：读取了新提交的事务，指增删操作。</strong><br>也是两次查询数据不一致，不过是新增产生的问题。</li>
<li><strong>第一类事务丢失（回滚丢失）</strong><br>事务A修改value1-num，事务B修改为value1-num+count，但是事务A不知道事务B的修改，直接将数据回滚为value1，这就导致事务B增加的count丢失了。</li>
<li><strong>第二类事务丢失（提交覆盖）</strong><br>  事务A将数据库由value0修改为value1，事务B紧接着提交，覆盖了事务A的修改。</li>
</ul>
<p><strong>Read uncommitted：</strong>可能会导致脏读。<br><strong>Read committed：</strong>可能会导致不可重复读。<br><strong>Repeatable read：</strong>尽管避免了修改，但是没有避免新增和删除，会导致幻读。<br><strong>Serializable：</strong>隔离级别最高，但是性能很差，一般不用。<br>大多数数据库默认事务隔离级别是Read Committed，遇到了不可重复读按照最后一次读取即可，MySQL默认事务隔离级别是<strong>Repeatable read</strong>。</p>
<h1 id="三、事务实现方式"><a href="#三、事务实现方式" class="headerlink" title="三、事务实现方式"></a>三、事务实现方式</h1><p>事务的实现方式分为<strong>声明式事务</strong>和<strong>编程式事务</strong>。</p>
<h2 id="3-1-声明式事务"><a href="#3-1-声明式事务" class="headerlink" title="3.1.声明式事务"></a>3.1.声明式事务</h2><p>&ensp;&ensp;&ensp;&ensp;通过@Transactional注解或者xml配置方式开启声明式事务，可以被用在<strong>类</strong>上和<strong>方法</strong>上，用在类上表明整个类的方法都开启事务。<br><strong>优点：</strong></p>
<ul>
<li><strong>代码简洁，</strong>声明式事务能够自动在方法前开启事务，根据方法执行结果决定是提交事务还是回滚事务。避免手动编写的大量代码。</li>
<li><strong>非侵入性：</strong>声明式事务本质上是通过AOP方式实现的，在目标方法前后添加拦截，在目标方法执行前添加或新建一个事务，在方法执行后根据结果来决定是提交事务（正常结束返回）还是回滚事务（抛出异常）。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>事务粒度：</strong>事务执行的最小粒度是方法，如果想要给某一段代码块添加事务，需要把这部分代码独立出来作为一个方法。</li>
<li><strong>容易被忽视：</strong>声明式事务通过注解即可，有时候还可以通过配置来实现，容易被忽略，进而导致问题。<blockquote>
<p><strong>忽视了事务会导致什么问题？</strong><br>如果开发者忽略了某个方法开启了事务，在方法内部执行了RPC调用、消息发送、缓存更新、文件写入等不可以回滚的操作：<br>1.如果出现了问题，本地事务回滚了，但是RPC远程调用是不可以回滚的，其他操作类似。<br>2.事务中远程调用会拉长事务，导致本事务的数据库连接池一直被占用，进而导致数据库连接池被耗尽。如果是编程式事务，那么大的事务开启代码、事务提交和事务回滚代码，一般不会忽略。</p>
</blockquote>
</li>
<li><strong>事务失效：</strong>某些场景下会导致声明式事务失效，这是一个常见八股。</li>
</ul>
<p><strong>常见的事务失效场景：</strong></p>
<ul>
<li>未指定回滚异常：<ul>
<li>@Transactional开启的事务，回滚异常默认是运行时异常(RuntimeException)，如果是自定义异常，继承了Exception，那么抛出这个异常时，事务不能回滚。<br>○ 需要指定@Trandsactional(rollbackFor&#x3D;Exception.class)</li>
</ul>
</li>
<li>异常被try catch捕获：<ul>
<li>异常被try catch捕获的时候，事务会失效</li>
<li>解决方案是throw异常，或者修改catch中的代码，手动回滚。</li>
</ul>
</li>
<li>同一个类方法中调用：<ul>
<li>和项目中出现的问题一样，开启事务的方法调用了所在类的其他方法，这个时候是this调用，而不是事务通过AOP的代理对象</li>
<li>解决方案是获取代理对象来调用。</li>
</ul>
</li>
<li>异步多线程：这部分不太懂。之后学了JUC可以回来补充。</li>
<li>错误设置事务传播机制：事务传播机制设置不恰当可能会导致事务失效。例如在默认的事务中，调用了@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW）设置的方法，在执行这个方法时，会新建事务，挂起已有事务，新建事务正确执行并提交后，原有事务才会恢复执行，即使原有事务因为异常发生了回滚，也不会影响已经提交的新事务。</li>
<li>方法不是public：因为事务是基于AOP的动态代理机制来实现的，只有public方法能够被代理。</li>
<li>当前类没有被spring容器托管：类没有被Spring容器所托管，那么也不会被Spring AOP所代理。</li>
<li>数据库本身不支持事务。</li>
</ul>
<h2 id="3-2-编程式事务"><a href="#3-2-编程式事务" class="headerlink" title="3.2.编程式事务"></a>3.2.编程式事务</h2><p>Spring框架提供两种编程式事务方式：</p>
<ul>
<li>TransactionTemplate或者TransactionalOperator</li>
<li>直接实现TransactionManager<br>具体如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trans</span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        TransactionDefinition def=<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        TransactionStatus status=transactionManager.getTransaction(def);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (DataAccessExcetption e)&#123;</span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过编程式事务，我们可以缩小事务粒度，但是实现方式比较麻烦。</li>
</ul>
<h1 id="四、事务的七种传播机制"><a href="#四、事务的七种传播机制" class="headerlink" title="四、事务的七种传播机制"></a>四、事务的七种传播机制</h1><h2 id="1-REQUIRED（required）：默认"><a href="#1-REQUIRED（required）：默认" class="headerlink" title="1.REQUIRED（required）：默认"></a>1.REQUIRED（required）：默认</h2><ul>
<li>当前已有事务：加入该事务</li>
<li>没有事务：新建一个事务<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在roleService中有如下代码：</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertRole</span><span class="params">()</span>&#123;</span><br><span class="line">    Role role=<span class="keyword">new</span> <span class="title class_">Role</span>();</span><br><span class="line">    roleMapper.insert(role);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在userService中有如下代码:</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用另一个需要事务的方法</span></span><br><span class="line">    roleService.insertRole();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num=<span class="number">10</span>/<span class="number">0</span>;<span class="comment">//制造一个异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>过程分析：</strong>执行userService的insertUser方法之前开启一个事务-&gt;过程中遇到insertRole，加入当前事务-&gt;事务提交前抛出异常，事务回滚。<br><strong>结果：</strong>本质上是同一个事务，所以所有插入操作都被回滚。</li>
</ul>
<h2 id="2-SUPPORTS（supports"><a href="#2-SUPPORTS（supports" class="headerlink" title="2.SUPPORTS（supports)"></a>2.SUPPORTS（supports)</h2><ul>
<li>当前有事务：加入该事务；</li>
<li>没有事务：以非事务方式继续运行。</li>
</ul>
<h3 id="2-1-当前无事务"><a href="#2-1-当前无事务" class="headerlink" title="2.1.当前无事务"></a>2.1.当前无事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertUser修改为无事务方式，继续上面的代码</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser无事-&gt;遇到insertRole，设置了SUPPORTS的事务传播机制-&gt;以非事务方式执行-&gt;遇到异常，无事务不回滚。<br><strong>结果：</strong>两条数据都成功插入数据库，都没有回滚操作。</p>
<h3 id="2-2-当前有事务"><a href="#2-2-当前有事务" class="headerlink" title="2.2.当前有事务"></a>2.2.当前有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertUser使用默认数据传播机制，insertRole使用SUPPORTS传播机制</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser有事务-&gt;遇到insertRole也需要开启事务，则加入当前事务-&gt;都将数据插入数据库，但事务提交前遇到异常-&gt;事务回滚。<br><strong>结果：</strong>两者属于同一个事务，所以都会被回滚。</p>
<h2 id="3-MANDATORY（mandatory"><a href="#3-MANDATORY（mandatory" class="headerlink" title="3.MANDATORY（mandatory)"></a>3.MANDATORY（mandatory)</h2><ul>
<li>当前有事务：加入该事务</li>
<li>没有事务：抛出异常</li>
</ul>
<h3 id="3-1-当前没有事务"><a href="#3-1-当前没有事务" class="headerlink" title="3.1.当前没有事务"></a>3.1.当前没有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole使用@Transactional注解</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor=Exception.class,propagation=Propagation.MANDATORY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertRole</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser数据正常入库-&gt;但是insertRole会报错，role无法存入数据库。<br><strong>结果：</strong>报错，role无法入库，但是不影响前面user信息入库。</p>
<h3 id="3-2-当前有事务"><a href="#3-2-当前有事务" class="headerlink" title="3.2.当前有事务"></a>3.2.当前有事务</h3><p>和REQUIRED、SUPPORTS的结果相同，因为报错了，所以事务都会回滚。</p>
<h2 id="4-REQUIRES-NEW（requires-new"><a href="#4-REQUIRES-NEW（requires-new" class="headerlink" title="4.REQUIRES_NEW（requires_new)"></a>4.REQUIRES_NEW（requires_new)</h2><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起，新事务结束才会恢复当前事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertUser和insertRole都开启事务，将insertRole的事务传播机制设置为REQUIRES_NEW</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser执行，开启事务-&gt;遇到insertRole，将insertUser的事务挂起，开启新事务，执行insertRole-&gt;Role信息正确进入数据库，新事务提交-&gt;insertUser当前事务恢复-&gt;遇到异常，当前事务回滚，之前提交的事务并不回滚。<br><strong>结果：</strong> insertUser遇到异常回滚，但是insertRole是另外的事务，不会回滚，user不存入数据库，Role存入数据库。</p>
<h2 id="5-NO-SUPPORTED-no-supported"><a href="#5-NO-SUPPORTED-no-supported" class="headerlink" title="5.NO_SUPPORTED(no_supported)"></a>5.NO_SUPPORTED(no_supported)</h2><p>以非事务方式运行，当前存在事务，则挂起当前事务。</p>
<h3 id="5-1-当前没有事务"><a href="#5-1-当前没有事务" class="headerlink" title="5.1.当前没有事务"></a>5.1.当前没有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertUser没有事务</span></span><br><span class="line"><span class="comment">//insertRole设置为NO_SUPPORTED</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>都以非事务方式执行-&gt;尽管有异常，但是user和role都会正常存入数据库。<br><strong>结果：</strong>两者照常入库，抛出异常。</p>
<h3 id="5-2-当前有事务"><a href="#5-2-当前有事务" class="headerlink" title="5.2.当前有事务"></a>5.2.当前有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole设置为NO_SUPPORTED</span></span><br><span class="line"><span class="comment">//insertUser默认事务</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser开启事务，执行-&gt;遇到insertRole，挂起当前事务，以非事务方式insertRole-&gt;insertRole执行完毕，恢复当前事务-&gt;遇到异常，事务回滚，但是insertRole非事务，无法回滚。<br><strong>结果：</strong>因为事务回滚，user不会出现在数据库，但是role正常入库。</p>
<h2 id="6-NEVER"><a href="#6-NEVER" class="headerlink" title="6.NEVER"></a>6.NEVER</h2><p>以非事务方式运行，如果当前存在事务，则抛出异常。（和MANDATORY相反，那个是必须有，没有就异常；这个是必须没有，有就异常）</p>
<h3 id="6-1-当前没有事务"><a href="#6-1-当前没有事务" class="headerlink" title="6.1.当前没有事务"></a>6.1.当前没有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole设置传播机制为NEVER</span></span><br><span class="line"><span class="comment">//insertUser没有事务</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>两者都以非事务方式执行。<br><strong>结果：</strong>user和role都入库，并不会回滚。</p>
<h3 id="6-2-当前存在事务"><a href="#6-2-当前存在事务" class="headerlink" title="6.2.当前存在事务"></a>6.2.当前存在事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole设置传播机制为NEVER</span></span><br><span class="line"><span class="comment">//insertUser默认开启事务</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>insertUser方法执行前开启一个事务，insertUser执行-&gt;保存user到数据库-&gt;执行insertRole，因为当前有事务，所以抛出异常-&gt;因为遇到异常，所以insertUser事务回滚-&gt;那么其实int num&#x3D;10&#x2F;0;并没有被执行。<br><strong>结果：</strong>insertUser因为NEVER抛出的异常而回滚。</p>
<h2 id="7-NESTED"><a href="#7-NESTED" class="headerlink" title="7.NESTED"></a>7.NESTED</h2><ul>
<li>当前有事务：创建一个事务作为当前事务的嵌套事务来运行；</li>
<li>没有事务：等价于REQUIRED（新建一个事务，没有算了，我自己干！）</li>
</ul>
<h3 id="7-1-当前没有事务"><a href="#7-1-当前没有事务" class="headerlink" title="7.1.当前没有事务"></a>7.1.当前没有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole设置传播机制为NESTED</span></span><br><span class="line"><span class="comment">//insertUser没有事务</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>执行insertUser-&gt;遇到insertRole，当前没有事务，创建新事务执行-&gt;将role保存到数据库，事务提交-&gt;遇到异常，结束。<br><strong>结果：</strong>两条数据都能成功入库，因为insertUser的异常在insertRole事务提交之后，而insertUser又没有事务，异常不会导致回滚。</p>
<h3 id="7-2-当前有事务"><a href="#7-2-当前有事务" class="headerlink" title="7.2.当前有事务"></a>7.2.当前有事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertRole设置事务，传播机制为NESTED</span></span><br><span class="line"><span class="comment">//insertUser默认事务</span></span><br></pre></td></tr></table></figure>
<p><strong>过程分析：</strong>开启一个事务，执行insertUser-&gt;遇到了insertRole，因为当前有事务，所以开启新事务执行insertRole，新事务作为外部事务的子事务-&gt;执行insertRole,role信息入库-&gt;子事务提交，继续执行外部事务-&gt;外部事务发生异常，外部事务和<strong>所有子事务</strong>都回滚。<br><strong>结果：</strong>因为外部事务抛出异常，两个事务都回滚，user和role都不会保存到数据库。</p>
<blockquote>
<p>需要注意的是，外部事务的回滚会导致所有内部子事务的回滚；但是，嵌套子事务的回滚并<strong>不会</strong>导致外部事务的回滚。<br>如果不指定rollbackFor，那么只有<strong>RuntimeException</strong>和<strong>Error</strong>会导致事务回滚。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础概念和原理</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>抽象类和接口的区别</title>
    <url>/2024/06/25/interface-and-abstract-class/</url>
    <content><![CDATA[<p><strong>方法定义：</strong></p>
<ul>
<li>接口只是定义了一些方法；<span id="more"></span></li>
<li>抽象类中方法是有具体实现代码的。</li>
</ul>
<p><strong>修饰符：</strong></p>
<ul>
<li>接口中的方法只能被public修饰</li>
<li>抽象类种的方法可以是private、protected和public，也可以是<default>的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    String c;</span><br><span class="line">    <span class="keyword">protected</span> String d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>构造器：</strong></li>
<li>接口不能有构造器；</li>
<li>抽象类可以有构造器。</li>
</ul>
<blockquote>
<p>抽象类不能被实例化，但是构造器还是有意义的。抽象类的构造器可以在<strong>其子类的构造器</strong>中被调用，然后再执行子类自己的构造器代码。</p>
</blockquote>
<p><strong>继承与实现：</strong></p>
<ul>
<li>接口只能被实现；</li>
<li>抽象类可以被继承。</li>
</ul>
<p><strong>单继承，多实现：</strong></p>
<ul>
<li>一个类可以实现多个接口</li>
<li>一个类只能继承一个抽象类</li>
</ul>
<p><strong>职责不同：</strong></p>
<ul>
<li>接口用于制定规范；</li>
<li>抽象类用于代码复用。</li>
</ul>
<p>在实际开发中，如果多个实现类有相同可复用的代码，那么就在接口和实现类之间增加一层抽象类。</p>
<img src="/2024/06/25/interface-and-abstract-class/img1.png" class="" title="img1">]]></content>
      <categories>
        <category>基础概念和原理</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战项目笔记三：优惠券秒杀</title>
    <url>/2024/06/27/redis-project-note2/</url>
    <content><![CDATA[<h1 id="一、全局唯一ID"><a href="#一、全局唯一ID" class="headerlink" title="一、全局唯一ID"></a>一、全局唯一ID</h1><span id="more"></span>
<p>&ensp;&ensp;&ensp;&ensp;全局唯一ID方法比较多，包括数据库自增、Redis实现和雪花算法。雪花算法用于分布式全局唯一ID，可以后续做分布式的时候重点解决这部分的问题。<br><strong>怎么通过Redis生成全局唯一id</strong><br>在Redis中设置一个String类型数据，key标识哪一业务的订单，value标识订单序列号。<br><strong>每次生成id就将Redis中的记录自增1.</strong><br><strong>key格式：</strong>icr:+keyPrefix+:+date（年月日）</p>
<h1 id="二、添加优惠券和秒杀下单"><a href="#二、添加优惠券和秒杀下单" class="headerlink" title="二、添加优惠券和秒杀下单"></a>二、添加优惠券和秒杀下单</h1><p>&ensp;&ensp;&ensp;&ensp;优惠券分为普通优惠券和秒杀优惠券。秒杀优惠券是在普通优惠券的基础上增加了：秒杀开始时间、结束时间和库存量。</p>
<h2 id="1-优惠券数据库设计"><a href="#1-优惠券数据库设计" class="headerlink" title="1.优惠券数据库设计"></a>1.优惠券数据库设计</h2><p>&ensp;&ensp;&ensp;&ensp;数据库分为voucher和seckill_voucher两个表，秒杀优惠券多出的信息保存在seckill_voucher表中。<br>&ensp;&ensp;&ensp;&ensp;读取优惠券列表时，根据xml重新配置的mapper联合读取两张表，信息都拼接到voucher对象中。普通优惠券的开始时间、结束时间和库存量为null。</p>
<blockquote>
<p>相当于在存储逻辑上没有分开存储，但是在业务处理逻辑上是分开的。</p>
</blockquote>
<h2 id="2-秒杀下单"><a href="#2-秒杀下单" class="headerlink" title="2.秒杀下单"></a>2.秒杀下单</h2><p><strong>业务需求：</strong><br>根据优惠券id下单，生成优惠券订单。<br><strong>实现流程图：</strong></p>
<img src="/2024/06/27/redis-project-note2/img1.png" class="" title="img1">
<h1 id="三、库存超卖问题"><a href="#三、库存超卖问题" class="headerlink" title="三、库存超卖问题*"></a>三、库存超卖问题*</h1><h2 id="1-问题详情"><a href="#1-问题详情" class="headerlink" title="1.问题详情"></a>1.问题详情</h2><p>在高并发场景下，例如200个线程同时去秒杀100份优惠券，会出现创建了109个订单，库存变成-9.</p>
<img src="/2024/06/27/redis-project-note2/img2.png" class="" title="img2">
<img src="/2024/06/27/redis-project-note2/img3.png" class="" title="img3">
<p><strong>为什么会出现超卖？</strong></p>
<img src="/2024/06/27/redis-project-note2/img4.png" class="" title="img4">
<h2 id="2-怎么解决超卖？"><a href="#2-怎么解决超卖？" class="headerlink" title="2.怎么解决超卖？"></a>2.怎么解决超卖？</h2><h3 id="2-1-悲观锁"><a href="#2-1-悲观锁" class="headerlink" title="2.1.悲观锁"></a>2.1.悲观锁</h3><p>通过互斥锁、Sychronized、lock等方式。悲观锁实现方式简单，但是效率比较低。</p>
<h3 id="2-2-乐观锁"><a href="#2-2-乐观锁" class="headerlink" title="2.2.乐观锁"></a>2.2.乐观锁</h3><p>具体概念看悲观锁和乐观锁的八股。乐观锁的实现方式包括：版本号和CAS方式。<br>乐观锁效率略高于悲观锁，适合多读少写的场景。在解决超卖问题的场景中，CAS方式解决超卖的方案会导致秒杀成功率很低。</p>
<h3 id="2-3-利用数据库的锁"><a href="#2-3-利用数据库的锁" class="headerlink" title="2.3.利用数据库的锁"></a>2.3.利用数据库的锁</h3><p>在扣减库存时，只要库存量&gt;0就可以扣减成功，利用数据库同一时刻只有一个线程能写数据。</p>
<h1 id="四、实现一人一单"><a href="#四、实现一人一单" class="headerlink" title="四、实现一人一单"></a>四、实现一人一单</h1><p><strong>业务需求：</strong><br>一个用户只能购买同一个优惠券一次。<br><strong>实现逻辑：</strong></p>
<img src="/2024/06/27/redis-project-note2/img5.png" class="" title="img5">
<p>关键点就是在扣减库存之前判断是不是已经有订单了。</p>
<h2 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1.问题分析"></a>1.问题分析</h2><p>用JMeter设置了200个请求，用的是同一个用户的token。正常情况下：<strong>只有一个订单，库存只减少1</strong>。<br>实际情况：</p>
<img src="/2024/06/27/redis-project-note2/img6.png" class="" title="img6">
<img src="/2024/06/27/redis-project-note2/img7.png" class="" title="img7">
<p>库存减少了10，同一个用户创建了10个订单。为什么呢？其实这里出现的问题和超卖是一致的。<br><strong>问题分析：</strong><br> 出现一人多单的原因是：在线程1检查订单和创建完成之间，别的线程完成了订单检查，后续就会成功创建订单。</p>
<h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>&ensp;&ensp;&ensp;&ensp;因为是添加订单，而不是修改数据，所以不能用乐观锁，要通过互斥锁来实现。将一人一单的逻辑代码抽象成createVoucherOrder方法。<br><strong>对秒杀的整个Service方法加synchronized：</strong><br>可以实现业务，但是同一时刻只能有一个线程能执行这个方法，这就影响到了其他用户秒杀。本质上一人一单是一个用户id只能秒杀一次。所以可以对用户id添加synchronized。<br><strong>针对用户id添加synchronized：</strong></p>
<ul>
<li>传入方法的userId是一个Long对象，每个线程都是从threadLocal获取用户，不同的请求对应不同的线程，也就是不同的userId，所以直接对userId加锁是不行的。</li>
<li>本质是对userId值进行锁定，所以对Object.intern()的结果加synchronized锁。<blockquote>
<p>intern()方法的作用是去字符串常量池查找是否有等效的字符串。如果有，则返回这个字符串的引用，如果没有，就把这个字符串放入字符串常量池，并返回其引用。</p>
</blockquote>
</li>
</ul>
<p><strong><font color=red>大坑1：释放锁的时机和事务</font></strong><br>这里还有个坑，如果对userId的字符串字面量加锁，实现方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//用户id</span></span><br><span class="line">    UserDTO user= UserHolder.getUser();</span><br><span class="line">    Long userId=user.getId();</span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="type">int</span> count=query().eq(<span class="string">&quot;user_id&quot;</span>,userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;已经购买过该优惠券！不允许重复购买！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        seckillVoucherService.update().setSql(<span class="string">&quot;stock=stock-1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>).update();</span><br><span class="line">        <span class="comment">//生成秒杀订单</span></span><br><span class="line">        VoucherOrder order=<span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//1.订单id</span></span><br><span class="line">        <span class="type">long</span> orderId=redisWorker.nextId(<span class="string">&quot;voucherOrder&quot;</span>);</span><br><span class="line">        order.setId(orderId);</span><br><span class="line">        <span class="comment">//2.优惠券id</span></span><br><span class="line">        order.setVoucherId(voucherId);</span><br><span class="line"></span><br><span class="line">        order.setUserId(user.getId());</span><br><span class="line">        <span class="comment">//订单写入数据库</span></span><br><span class="line">        save(order);</span><br><span class="line">        <span class="comment">//返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可能牵扯到了八股，Spring的事务:<a href="https://daisybby.github.io/2024/06/26/Transaction/">Spring事务</a></p>
<blockquote>
<p>以上代码，执行完synchronized锁上的代码块后，释放互斥锁-&gt;return结果-&gt;事务提交。<br><strong>正常情况下：</strong></p>
</blockquote>
<ul>
<li>加锁的代码块正常执行，遇到了return语句，要退出这个代码块，那么互斥锁会被释放；</li>
<li>或者加锁的代码块正常执行，内部没有return语句，那么执行完退出这个代码块时，互斥锁被释放；</li>
<li>事务修饰的方法正常执行，返回结果后提交事务。<br><strong>异常情况下：</strong></li>
<li>加锁的代码块内部出现了异常，也是要退出这段代码块的，互斥锁被释放；</li>
<li>@Transactional事务，如果抛出的异常满足设置的事务回滚条件，那么事务会回滚。<br>总结：只要退出synchronized加锁的代码块，互斥锁都会被释放。<br>这就导致在<strong>事务提交前互斥锁已经被释放</strong>，如果此时其他线程使用相同的userId，获取到了互斥锁，事务还没有提交，数据库还没有更新，这就又出现了多线程都进入创建订单阶段，导致一人多单。<br><strong><font color=green>正确做法：</font></strong></li>
<li><strong>加锁对象依旧是userId；</strong></li>
<li><strong>加锁时间：事务提交之前-&gt;事务提交之后。</strong></li>
</ul>
<p>实现方法就是在秒杀service方法seckillVoucher中调用createVoucherOrder方法之前就对userId加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long userId=UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">    <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里和对createVoucherOrder函数加锁不同，尽管在方法执行期间都是被加锁状态，但是其他的userId没有被加锁，还是可以执行这段代码。而且是确保实物提交了才会释放互斥锁。</p>
</blockquote>
<p><strong><font color=red>大坑2：事务不生效</font></strong><br>&ensp;&ensp;&ensp;&ensp;在上面的代码块中，return本质是return this.createVoucherOrder，调用的是seckillVoucherOrderServiceImpl对象的属性方法，但是事务生效用的是这个对象的代理对象，this是会导致事务不生效的。</p>
<blockquote>
<p>这里有提到不建议用声明式事务的原因，总结了一些事务失效的原因，原因4就是同一个类中方法调用会导致事务失效。</p>
</blockquote>
<p><strong><font color=green>正确做法：</font></strong></p>
<ul>
<li><strong>设置代理对象可暴露，获取IVoucherOrderService的代理对象</strong></li>
<li><strong>调用代理对象的createVoucherOrder方法</strong></li>
</ul>
<p>以上操作使得事务生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装aspectJ的依赖</span></span><br><span class="line"><span class="comment">//1.在项目启动类中添加注解</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br><span class="line"><span class="comment">//2.在调用createVoucherOrder的地方修改为调用代理类的方法</span></span><br><span class="line">Long userId=UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">    IVoucherOrderService proxy= (IVoucherOrderService) AopContext.currentProxy();<span class="comment">//获取代理对象</span></span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>八股里是不推荐实现<strong>声明式事务</strong>，推荐的是<strong>编程式事务</strong>。先把这部分功能实现，然后回来优化事务。</p>
</blockquote>
<p>需要注意的是，这里的一人一单策略，都是在单机模式下生效的，一旦到了集群模式下就会失效。</p>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战项目笔记四：分布式锁</title>
    <url>/2024/06/30/lock/</url>
    <content><![CDATA[<p><strong>业务背景:</strong></p>
<span id="more"></span>
<p>&ensp;&ensp;&ensp;&ensp;在单机模式下，通过给创建优惠券订单的函数添加synchronized，能够实现一人一单；但是在分布式系统下，<strong>synchronized无法跨服务器生效</strong>，还是会导致一人多单的问题。</p>
<blockquote>
<p>跨服务器场景下，如果要实现线程之间的同步，需要通过<strong>分布式锁</strong>。</p>
</blockquote>
<h1 id="1-Redis分布式锁"><a href="#1-Redis分布式锁" class="headerlink" title="1.Redis分布式锁"></a>1.Redis分布式锁</h1><p><strong>业务逻辑：</strong><br>之前基于互斥锁synchronized实现了一台服务器上的一人一单，现在通过Redis的setnx方法实现分布式锁。</p>
<ul>
<li>锁针对的依然是优惠券秒杀业务下的userId，因此Redis中锁的key是和业务以及userId相关。</li>
<li>value可以设置为申请到分布式锁的线程id。</li>
<li>和单机模式下类似，在创建订单前获取分布式锁，finally释放分布式锁。</li>
</ul>
<h1 id="2-分布式锁误删问题"><a href="#2-分布式锁误删问题" class="headerlink" title="2.分布式锁误删问题"></a>2.分布式锁误删问题</h1><p><strong>问题背景：</strong><br>&ensp;&ensp;&ensp;&ensp;创建秒杀订单前，线程获取分布式锁，成功后才行，在任务执行完释放分布式锁。但是并发场景下，会存在如下问题：</p>
<img src="/2024/06/30/lock/img1.png" class="" title="img1">
<ul>
<li>线程1的业务发生了阻塞，导致持有的分布式锁过期自动释放。</li>
<li>线程2在线程1业务完成之前、分布式锁过期释放后申请获取锁，成功，线程2进入业务。</li>
<li>线程1在线程2业务结束之前释放分布式锁，这个时候锁的key是前缀+userId+业务，是有可能重复的，<strong>错误释放了线程2持有的分布式锁</strong>。</li>
<li>线程3在线程2任务结束前到达，申请获取分布式锁，成功，此时<strong>线程2和线程3</strong>同时执行。</li>
</ul>
<p><strong>解决思路：</strong><br>&ensp;&ensp;&ensp;&ensp;归根结底，出现问题的原因是线程释放分布式锁时，根本没看锁属不属于自己，直接就释放了。正常情况下，如果不是当前线程持有的锁，不释放。释放分布式锁之前检查<strong>锁是否为当前线程所持有</strong>。<br>&ensp;&ensp;&ensp;&ensp;在之前，锁的value值是没有用上的，存储的是获得锁的线程号，但是<strong>不同JVM上线程号</strong>可能相同，因此需要在线程号前面加上能够标识JVM的：</p>
<ul>
<li>赋予当前类一个属性，这台JVM所有执行这部分代码的线程都具有一样的编号UUID，而且要保证这个UUID不能被修改</li>
<li>用static修饰，表示变量属于类</li>
<li>final修饰，表示变量一旦被初始化，就不能修改</li>
</ul>
<h1 id="3-分布式锁原子性问题"><a href="#3-分布式锁原子性问题" class="headerlink" title="3.分布式锁原子性问题"></a>3.分布式锁原子性问题</h1><p><strong>问题背景：</strong><br>释放分布式锁分为两步：一是判断锁标识，二是删除锁。</p>
<img src="/2024/06/30/lock/img2.png" class="" title="img2">
<ul>
<li>线程1判断线程标识后，释放锁之前被阻塞；</li>
<li>分布式锁超时释放，被后来的线程2获得；</li>
<li>线程2执行期间，线程1恢复，此时不需要再次判断锁标识，直接释放，释放错了锁。</li>
</ul>
<blockquote>
<p>线程2和线程1所用锁的key可能会相同吗？<br>锁的key是JVM唯一的前缀+userId+voucherId，并没有线程相关的标识，是可能相同的。</p>
</blockquote>
<p>造成问题的原因是判断锁标识和删除锁的<strong>非原子性</strong>。<br><strong>解决思路：</strong> 利用Lua脚本完成锁标识判断和分布式锁删除。<br><strong>Lua脚本内容：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>])==ARGVS[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="comment">--表示没有删除锁</span></span><br></pre></td></tr></table></figure>
<p>上一节中，Redis实现分布式锁的内容都在simpleRedisLock类中，包括tryLock和unlock，在unlock中调用Lua脚本。<br>首先在类中注入相关工具类和脚本路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<span class="comment">//这里的Long是函数返回类型</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        UNLOCK_SCRIPT=<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPath</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK.SCRIPT.setReturnType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在unlock中调用Lua脚本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        String threadId=VALUE_PREFIX+Thread.currentThread().getId();</span><br><span class="line">        stringRedisTemplate.execute(</span><br><span class="line">                UNLOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(KEY_PREFIX+name),</span><br><span class="line">                threadId</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-setnx分布式锁存在的问题"><a href="#4-setnx分布式锁存在的问题" class="headerlink" title="4.setnx分布式锁存在的问题"></a>4.setnx分布式锁存在的问题</h1><p><strong>不可重入性：</strong><br>线程1持有分布式锁，业务收到了阻塞，在这期间线程1可能还需要获取这个锁，但之前的实现方式是不允许的。<br><strong>不可重试性：</strong><br>线程获取锁失败后就返回，没有重试机制。<br><strong>超时释放：</strong><br>超时释放的问题在于，这个时间为多久？有些线程涉及到的业务流程比较长，有些线程比较短，超时释放存在一定的安全隐患。<br><strong>主从一致性：</strong><br>在集群环境下，如果主数据库宕机，此时从数据库中还没有把获得的分布式锁同步，选择一台从数据库作为新的主数据库时可能会导致问题。</p>
<h1 id="5-Redission"><a href="#5-Redission" class="headerlink" title="5.Redission"></a>5.Redission</h1><h2 id="5-1-Redission实现可重入锁的原理"><a href="#5-1-Redission实现可重入锁的原理" class="headerlink" title="5.1.Redission实现可重入锁的原理"></a>5.1.Redission实现可重入锁的原理</h2><img src="/2024/06/30/lock/img3.png" class="" title="img3">
<p>与setnx不同的是，redission用hash结构来实现分布式锁：fieldKey是线程标识，fieldValue标识锁计数。</p>
<ul>
<li>先检查有没有分布式锁，没有就新建一个；有就计数+1，同时刷新锁有效时间；</li>
<li>删除锁的时候，检查锁是不是自己的，如果不是说明已经过期等原因造成锁已经释放；</li>
<li>删除锁应该先锁计数-1，然后判断是不是计数&#x3D;0，等于0则直接释放锁，不是0要刷新锁有效时间。</li>
</ul>
<p>Redission都解决了setnx方式所存在的：不可重入性，不可重试性、超时释放、主从一致性问题。具体内容涉及到源码，暂时没了解。</p>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战项目笔记五：秒杀优化</title>
    <url>/2024/07/01/Redis-project-note4/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在之前的秒杀业务实现逻辑中，主要业务流程是：<span id="more"></span>查询优惠券信息-&gt;校验秒杀时间-&gt;判断库存-&gt;检查是否重复下单-&gt;生成秒杀订单。这些业务都是基本都是利用<strong>数据库</strong>完成，用到Redis的场景是：生成唯一ID、分布式锁实现一人一单。</p>
<h1 id="1-优化思路"><a href="#1-优化思路" class="headerlink" title="1.优化思路"></a>1.优化思路</h1><p><strong>优化思路：</strong></p>
<ul>
<li><strong>校验库存：</strong>每个用户进行秒杀都需要判断库存，访问数据库，可以将<strong>库存</strong>保存到<strong>Redis</strong>，提升效率；</li>
<li><strong>检查是否重复下单：</strong>这部分本质上是检查当前用户是否已有当前优惠券的订单，也不需要修改数据库，把当前优惠券对应的秒杀成功的用户<strong>保存到Redis</strong>。</li>
<li><strong>校验秒杀时间：</strong>为了达到上述两点优化，我们需要将库存和订单用户都保存到Redis，如果优惠券不在秒杀时间内，直接不在Redis中保存就行，而且前端界面也可以不显示过期优惠券。<br><strong>优化后的业务逻辑：</strong><img src="/2024/07/01/Redis-project-note4/img1.png" class="" title="img1">
以上是Redis中实现的业务，为了保证原子性，直接用Lua脚本完成。<img src="/2024/07/01/Redis-project-note4/img2.png" class="" title="img2">
<blockquote>
<p>这里我自己加了一点逻辑，在添加新优惠券到数据库的时候，不仅要保存到数据库，还要使用voucherId和库存量，将库存量保存到Redis。Redis中优惠券数据的有效时间与秒杀活动的结束时间是一致的，我们可以计算endTime和now的时间间隔，设置为Redis中库存信息的有效时间。</p>
</blockquote>
</li>
</ul>
<p>对于后续创建订单，并更新数据库操作，可以开启异步线程完成，从阻塞队列中读取秒杀信息，进行后续操作。用BlockingQueue可以完成，但并不成熟，这部分代码没有动手实现。稍微看看。</p>
<h1 id="2-Redis消息队列"><a href="#2-Redis消息队列" class="headerlink" title="2.Redis消息队列"></a>2.Redis消息队列</h1><p><strong>问题背景：</strong><br>基于阻塞队列实现异步创建并保存订单，虽然也能实现大部分业务，但是存在着一些问题：</p>
<ul>
<li>阻塞队列使用的是JVM内存，在高并发场景下，大量的消息存在阻塞队列中，可能会使得JVM内存空间耗尽；</li>
<li>没有消息持久化机制，当JVM宕机时，会发生消息丢失。<br><strong>解决方案：</strong><br>一是使用专门的消息队列中间件，二是Redis提供了部分简单的消息队列功能。<br>项目中使用的是Redis消息队列，具体内容整理成了另外的笔记：<br><strong><font color=red>待补充：</font></strong><br>可以用简单的消息队列完成这一节，但是后续想试试专业的消息队列工具。</li>
</ul>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis消息队列</title>
    <url>/2024/07/01/redis-message-queue/</url>
    <content><![CDATA[<p>Redis提供了三种方式来实现消息队列：</p>
<span id="more"></span>
<ul>
<li>list结构：基于list来模拟消息队列</li>
<li>PubSub：发布订阅模式，基本的点对点消息模型</li>
<li>Stream：比较完善的消息队列</li>
</ul>
<h1 id="一、List结构"><a href="#一、List结构" class="headerlink" title="一、List结构"></a>一、List结构</h1><p>Redis提供的List可以模拟消息队列。<br>队列的特性是先进先出，可以用LPUSH和RPOP构成消息队列，也可以用RPUSH和LPOP来构成消息队列。<br>队列中没有消息时，会返回null；而阻塞队列是在队列中没有消息时进程被阻塞；使用<strong>BRPOP</strong>和<strong>BLPOP</strong>可以实现阻塞效果。<br><strong>生产者发送消息：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生产者向名称为list1的消息队列中发送两个消息msg1和msg2</span></span><br><span class="line">LPUSH list1 msg1 msg2 </span><br></pre></td></tr></table></figure>
<p><strong>消费者消费消息：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RPOP list1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">返回的结果是msg1，表示获取到了msg1这个消息</span></span><br><span class="line">BRPOP list1 20</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以上表示使用阻塞的方式，等待20秒还没有消息就结束阻塞</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>list结构实现消息队列的优缺点：<br><strong>优点：</strong></p>
<ul>
<li>利用Redis存储，实现消息的持久化</li>
<li>避免了JVM内存空间限制<br><strong>缺点：</strong></li>
<li>无法避免消息丢失，取出的消息还没来得及处理丢失后无法重复获取</li>
<li>只支持单消费者</li>
</ul>
</blockquote>
<h1 id="二、发布订阅模型"><a href="#二、发布订阅模型" class="headerlink" title="二、发布订阅模型"></a>二、发布订阅模型</h1><p>&ensp;&ensp;&ensp;&ensp;消费者可以订阅一个或多个channel(频道)，生产者向对应的channel发送消息后，所有订阅了该频道的消费者都能收到消息。<br><strong>相关命令：</strong></p>
<ul>
<li>SUBSCRIBE channel名：订阅指定的channel</li>
<li>PUBLISH channel名 msg：向指定的channel发送消息</li>
<li>PSUBSCRIBE pattern：订阅所有与pattern匹配的频道。</li>
</ul>
<blockquote>
<p>目前pattern匹配规则就三种：</p>
<ul>
<li>h?llo：?表示任意一个字符。</li>
<li>h<em>llo：</em>表示任意一个或者多个字符。</li>
<li>h[ae]llo：表示只能匹配hello和hallo。</li>
</ul>
</blockquote>
<blockquote>
<p>发布订阅模型的优缺点：<br><strong>优点：</strong></p>
<ul>
<li>支持多个生产者、多个消费者<br><strong>缺点：</strong></li>
<li>不支持消息持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出上限时，最早进入队列的消息会丢失</li>
</ul>
</blockquote>
<h1 id="三、基于Stream的消息队列"><a href="#三、基于Stream的消息队列" class="headerlink" title="三、基于Stream的消息队列"></a>三、基于Stream的消息队列</h1><p>Stream是Redis5.0引入的新数据类型，可以实现功能相对比较完善的消息队列。</p>
<h2 id="3-1-Stream单消费模式"><a href="#3-1-Stream单消费模式" class="headerlink" title="3.1.Stream单消费模式"></a>3.1.Stream单消费模式</h2><p><strong>发送消息：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">发送消息需要指定消息队列名称，消息的唯一<span class="built_in">id</span>，消息是多个k-v键值对</span></span><br><span class="line">XADD users * name jack age 20</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以上命令向<span class="built_in">users</span>消息队列发送了一个消息，其中消息的唯一<span class="built_in">id</span> *表示由redis自行生成</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">消息内容为&#123;name=jack,age=20&#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果想要自行生成消息<span class="built_in">id</span>，最好按照<span class="string">&quot;时间戳-自增ID&quot;</span>的格式，时间戳是毫秒值，同一时刻的消息ID递增，不同时刻则ID都是0</span></span><br></pre></td></tr></table></figure>
<p><strong>读取消息：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XREAD COUNT count STREAMS key ID</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其中count表示一次读取中最大读取消息数，key表示消息队列名称，ID表示读取消息的起始ID，0表示从第一个消息开始</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">$表示读取最新的消息</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取消息的例子如下：</span></span><br><span class="line">XREAD COUNT 1 STREAMS s1 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取s1中的1条消息，从第一条消息开始读取</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阻塞读取消息</span></span><br><span class="line">XREAD COUNT 1 BLOCK 0 STREAMS S1 $</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表示阻塞读取最新消息，阻塞时间0表示一直阻塞</span></span><br></pre></td></tr></table></figure>
<p>消息可以重复读取，但是$是不能读取已经读过的消息。如果读取了最新的一条消息，在处理消息期间消息队列堆积了多个新的消息，$还是只能读取最新的一条消息，<strong>导致漏读消息</strong>。</p>
<blockquote>
<p>STREAM读取消息的特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取（PubSub也有这个特点，不过那边更像是被动通知，而不是主动读取）</li>
<li>可以阻塞读取</li>
<li>有漏读消息的风险。</li>
</ul>
</blockquote>
<h2 id="3-2-Stream的消费者组"><a href="#3-2-Stream的消费者组" class="headerlink" title="3.2.Stream的消费者组"></a>3.2.Stream的消费者组</h2><p><strong>消费者组：</strong>将多个消费者划分成一个组，监听同一个消息队列。</p>
<blockquote>
<p>同一个消息队列的不同消费者组，各自维护自己的消息偏移量，允许以不同的速度处理消息，各自处理消息的逻辑也是独立的，互不影响。可能消费者组1已经把全部的消息都处理完了，消费者组2才处理了一点点。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li><strong>消息分流：</strong> 一个消费者组内部的各个消费者是竞争关系，队列中的消息是分流给消费者们，而不是重复消费，多个消费者加快消息处理速度，避免消息堆积。</li>
<li><strong>消息标示：</strong>消费者组会维护一个标示，标记最后一个被处理的消息，即使消费者宕机，回来后还是可以通过标记恢复进度。</li>
<li><strong>消息确认：</strong>消费者获取消息后，消息处于pending状态，并被存入pending-list。只有被XACK确认的消息才会被标记已处理，且从pending-list中删除。</li>
</ul>
<p><strong>创建消费者组：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP CREATE key groupName ID [MKSTREAM]</span><br></pre></td></tr></table></figure>
<ul>
<li>key：队列名称</li>
<li>groupName：消费者组名称</li>
<li>ID：起始ID标识，$表示队列中最后一个消息，0表示队列中第一个消息</li>
<li>MKSTREAM：队列不存在时自动创建队列，默认就行。</li>
</ul>
<p><strong>其他常见命令：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除指定的消费者组</span></span><br><span class="line">XGROUP DESTROY key groupName</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给指定的消费者组添加消费者</span></span><br><span class="line">XGROUP CREATECONSUMER key groupName consumerName</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除指定消费者组中的消费者</span></span><br><span class="line">XGROUP DELCONSUMER key groupName consumerName</span><br></pre></td></tr></table></figure>
<p><strong>从消费者组中读取消息：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP groupName consumerName [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>
<ul>
<li>groupName：指定消费者组名称</li>
<li>consumerName：指定消费者名称</li>
<li>count：一次读取最大消息数</li>
<li>Block milliseconds：阻塞时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认，默认即可</li>
<li>STREAMS key：指定消息队列名称</li>
<li>ID：获取消息的起始ID：<ul>
<li>&gt;：表示从下一个未消费的消息开始</li>
<li>其他：根据指定id从pending-list中获取已消费但未确认的消息，例如0，从pending-list第一个消息开始处理。</li>
</ul>
</li>
</ul>
<blockquote>
<p>消息消费的逻辑是先设置ID为&gt;，处理完消息队列中的消息，然后设置为0，处理完pending-list中没有确认的消息。</p>
</blockquote>
<p>具体使用命令不再赘述，可以查阅官方文档。</p>
<blockquote>
<p>XREADGROUP命令的特点：</p>
<ul>
<li>消息可回溯</li>
<li>支持多消费者消费消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有漏读消息的风险</li>
<li>通过消息确认机制，确保每个消息至少被消费一次</li>
</ul>
</blockquote>
<h1 id="四、对比"><a href="#四、对比" class="headerlink" title="四、对比"></a>四、对比</h1><img src="/2024/07/01/redis-message-queue/img1.png" class="" title="img1">]]></content>
      <categories>
        <category>基础概念和原理</category>
        <category>Redis</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>点赞、关注、附近商铺</title>
    <url>/2024/07/12/Redis-project-note5/</url>
    <content><![CDATA[<h1 id="一、点赞功能"><a href="#一、点赞功能" class="headerlink" title="一、点赞功能"></a>一、点赞功能</h1><span id="more"></span>
<h2 id="1-1-点赞"><a href="#1-1-点赞" class="headerlink" title="1.1.点赞"></a>1.1.点赞</h2><p><strong>业务需求：</strong></p>
<ul>
<li>用户对发布的笔记点赞，只能赞一次，再次点击是取消点赞；</li>
</ul>
<p><strong>实现逻辑：</strong></p>
<ul>
<li>blog类添加一个字段isLike，表示blog是否被当前用户点赞</li>
<li>Redis中维护一个set，key为笔记id，元素就是已点赞用户id（和优惠券秒杀判断是否已经下单过的逻辑一致）；</li>
<li>用户点击时，判断用户id在不在set里：<ul>
<li><strong>不在：</strong>用户没有点赞过，需要更新blog的点赞次数+1，并将用户id保存到set中；</li>
<li><strong>在：</strong>用户已经点赞，此时需要取消点赞，更新blog点赞次数-1，并将用户id从set中删除。</li>
</ul>
</li>
<li>根据id查询blog的业务代码也要修改，在查询blog时，还要根据当前用户是否点赞过来设置isLike字段</li>
</ul>
<h2 id="1-2-加载点赞列表"><a href="#1-2-加载点赞列表" class="headerlink" title="1.2.加载点赞列表"></a>1.2.加载点赞列表</h2><p><strong>业务需求：</strong></p>
<ul>
<li>在笔记详情中，显示最先点赞的前5个用户的头像；<br><strong>实现逻辑：</strong></li>
<li>点赞列表保存在redis中，利用zset可以实现排序，排序依据是时间，用点赞时刻的毫秒数作为score；</li>
<li>加载笔记详情时，从Redis中加载笔记对应的点赞列表，选出top5从数据库查询用户信息。</li>
</ul>
<blockquote>
<p>这里有一个坑，尽管交给SQL数据库的userId顺序是top5，但是返回的用户信息顺序是会按照数据库的默认设置来排序，需要使用ORDER BY来规定返回顺序。</p>
</blockquote>
<h1 id="二、关注功能"><a href="#二、关注功能" class="headerlink" title="二、关注功能"></a>二、关注功能</h1><h2 id="2-1-关注和取消关注"><a href="#2-1-关注和取消关注" class="headerlink" title="2.1.关注和取消关注"></a>2.1.关注和取消关注</h2><p><strong>业务需求：</strong></p>
<ul>
<li>用户可以关注另一个用户</li>
<li>也可以取关已有的关注。</li>
</ul>
<p><strong>实现逻辑：</strong></p>
<ul>
<li>关注是用户之间的关系，在数据库中维护一个中间表，保存用户id和关注的用户id。</li>
<li>点击关注，传入被关注用户id，获取当前登录用户，将这个关系保存到数据库。</li>
</ul>
<h2 id="2-2-共同关注"><a href="#2-2-共同关注" class="headerlink" title="2.2.共同关注"></a>2.2.共同关注</h2><p><strong>业务需求：</strong><br>&ensp;&ensp;&ensp;&ensp;点开某用户首页，可以看到该用户的基本信息、已发布的笔记，和共同关注选项，这个选项显示了“我”和这个用户共同关注的对象。<br><strong>实现逻辑：</strong><br>&ensp;&ensp;&ensp;&ensp;所谓共同关注，其实就是两个用户关注列表的交集，我们可以将每个用户的关注列表设置为一个Redis的set，然后求两个用户对应set的交集，再根据交集查到的用户id，返回真实的user列表即可。</p>
<h2 id="2-3-笔记推送给粉丝"><a href="#2-3-笔记推送给粉丝" class="headerlink" title="2.3.笔记推送给粉丝"></a>2.3.笔记推送给粉丝</h2><p><strong>业务需求：</strong></p>
<ul>
<li>像B站的动态一样，博主更新了笔记，可以推送给博主的粉丝们。</li>
</ul>
<p><strong>推送流(Feed流)：</strong></p>
<ul>
<li><strong>拉模式（读扩散）：</strong>博主发布笔记到发件箱，粉丝登录后从发件箱拉取到自己的收件箱查看。</li>
<li><strong>推模式（写扩散）：</strong>博主发布笔记后，推送到每一个粉丝的收件箱。</li>
<li><strong>推拉混合模式：</strong>对于大v发布的笔记，推送到活跃粉丝的收件箱，普通粉丝则是从大V发件箱中拉取。</li>
</ul>
<p><strong>优缺点分析：</strong></p>
<img src="/2024/07/12/Redis-project-note5/img1.png" class="" title="img1">
<p>在我们的项目中，并不存在大V，用户量也不是很多，所以采用推送模式。用户获得的关注列表发送的笔记，是要按照时间顺序排列，最新的排在第一个。而且要实现分页查询。</p>
<h2 id="2-4-分页查询"><a href="#2-4-分页查询" class="headerlink" title="2.4.分页查询"></a>2.4.分页查询</h2><p>利用Redis实现，需要满足以下需求：</p>
<ul>
<li>一个用户对应一个收件箱</li>
<li>收件箱中的笔记按照时间排序</li>
<li>收件箱需要支持分页查询</li>
</ul>
<p>List和ZSet都能够实现排序，也能够实现分页查询（List按照下标查询，ZSet也能按照下标查询）。<br><strong>List分页查询的问题：</strong><br>&ensp;&ensp;&ensp;&ensp;收件箱中的笔记数量是会动态变化的，使用List可能会导致查询第二页时，第一页新增了一条笔记，导致原来第一页最后一条笔记成为第二页第一条笔记，查询到的第二页包含重复笔记。<br><strong>怎么解决这个问题？</strong><br>&ensp;&ensp;&ensp;&ensp;ZSet支持按照Score范围来查询，笔记排序的Score就是时间，我们记住第一页最后一条笔记的score，下次查询毫秒数&lt;记录的即可。<br><strong>实现：</strong><br>需要对发布笔记进行改造，不仅要保存到数据库，还要将blogId保存到粉丝的收件箱中。<br><strong>分页查询实现：</strong></p>
<ul>
<li>每一页n个元素相当于每一次从Redis中查询n个元素，上次查询最后一条记录的time，就是下次查询最大的time；</li>
<li>每一页的count是固定的，如果score相同的元素个数超过了count，可能会存在跨页的问题，为了避免跳过数据，或者查询到重复数据，需要记录上一次查询中等于minTime的元素共有多少个，下一次直接用偏移量来开始即可。</li>
<li>查询出来的只有BlogId，具体内容还是需要从数据库中查询，查询时同样需要拼接id，使用ORDER BY来维持正确顺序；</li>
<li>针对查询出来的每个Blog，填充其用户信息和点赞信息。</li>
</ul>
<h1 id="三、附近商户"><a href="#三、附近商户" class="headerlink" title="三、附近商户"></a>三、附近商户</h1><p><strong>业务场景：</strong></p>
<ul>
<li>在首页，用户根据分类查看商铺列表，商铺列表是按照距离由近到远排序的。</li>
<li>从代码角度理解，用户所在位置的经纬度传递给后端，然后分页查询。</li>
</ul>
<p><strong>实现逻辑：</strong><br>&ensp;&ensp;&ensp;&ensp;将商铺信息按照类别分组，一个类别保存到一个key中，value就是一系列的(lon,lat,member)，所谓member就是商铺id。在查询的时候，根据前端传递来的经纬度坐标，以用户坐标为圆心，指定半径查询。<br>&ensp;&ensp;&ensp;&ensp;这部分的分页查询难以实现from，只能实现end，所以比较麻烦。具体代码没有实现，这部分的功能不是重点。</p>
<h1 id="四、用户签到"><a href="#四、用户签到" class="headerlink" title="四、用户签到"></a>四、用户签到</h1><h2 id="4-1-用户签到"><a href="#4-1-用户签到" class="headerlink" title="4.1.用户签到"></a>4.1.用户签到</h2><p>用户签到信息的保存，用BitMap可以用二进制，一个bit位表示某天用户是否签到。<br>在Redis中，底层是通过String数据结构来实现BitMap。<br><strong>实现逻辑：</strong><br>一个BitMap记录一个月的签到记录。将用户id和年月拼接成key。</p>
<h2 id="4-2-签到统计"><a href="#4-2-签到统计" class="headerlink" title="4.2.签到统计"></a>4.2.签到统计</h2><p>统计到今天为止，连续签到了多少天。<br><strong>实现逻辑：</strong><br>从BitMap最后一个bit位往前统计，遇到0则停止统计。</p>
]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>String、StringBuilder和StringBuffer的区别</title>
    <url>/2024/07/12/String-StringBuilder-and-StringBuffer/</url>
    <content><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><span id="more"></span>
<ul>
<li><strong>可变性：</strong> String是不可变的，StringBuilder和StringBuffer是可变的。</li>
<li><strong>安全性：</strong> StringBuffer是线程安全的，而StringBuilder是非线程安全的。</li>
</ul>
<h1 id="二、String是怎么实现不可变的？"><a href="#二、String是怎么实现不可变的？" class="headerlink" title="二、String是怎么实现不可变的？"></a>二、String是怎么实现不可变的？</h1><p>从Java8的源码看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class String is special cased within the Serialization Stream Protocol.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A String instance is written into an ObjectOutputStream according to</span></span><br><span class="line"><span class="comment">     * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../platform/serialization/spec/output.html&quot;&gt;</span></span><br><span class="line"><span class="comment">     * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> endIndex - beginIndex;</span><br><span class="line">        <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="built_in">this</span></span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>String类被final修饰，这意味着String类是不能被继承的，内部的方法无法被覆盖；</li>
<li>String内部用char数组来保存字符串，且char[]也被final修饰，这意味着引用一旦被初始化就不能被修改，只能指向这一块内存区域；</li>
<li>要想改变字符串内容，就只能修改这块内存区域保存的内容，但是String类并没有提供改变数组内容的方法。</li>
</ul>
<p>但是实际开发中，是需要做字符串修改的，比如字符串拼接，子串截取等，这部分怎么做？<br>同样的，阅读源码可以看出来concat和subString返回结果都是new String()新建一个字符串对象。</p>
<h1 id="三、String的”-”是如何实现的？"><a href="#三、String的”-”是如何实现的？" class="headerlink" title="三、String的”+”是如何实现的？"></a>三、String的”+”是如何实现的？</h1><p>使用+拼接字符串是Java提供的语法糖，对于如下字符串拼接的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">&quot;daisybby&quot;</span>;</span><br><span class="line">String introduce=<span class="string">&quot;a student&quot;</span>;</span><br><span class="line">String daisybby=name+<span class="string">&quot;,&quot;</span>+introduce;</span><br></pre></td></tr></table></figure>
<p>对字节码反编译后的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">&quot;daisybby&quot;</span>;</span><br><span class="line">String introduce=<span class="string">&quot;a student&quot;</span>;</span><br><span class="line">String daisybby=(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(name).append(<span class="string">&quot;,&quot;</span>).append(<span class="string">&quot;a student&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>字符串常量的拼接是通过StringBuilder的append来实现的。</p>
<h1 id="四、StringBuffer和StringBuilder"><a href="#四、StringBuffer和StringBuilder" class="headerlink" title="四、StringBuffer和StringBuilder"></a>四、StringBuffer和StringBuilder</h1><p>与String类似，StringBuilder内部也封装了一个char数组，但是这个数组没有用final修饰，是可以修改的；另外，StringBuilder内部有一个成员变量count来标识数组已使用的空间。<br>StringBuilder的append源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);<span class="comment">//调用父类的append</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringBuilder是继承了AbstractStringBuilder类，其append方法源码如下：\</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="type">int</span> len=str.length();</span><br><span class="line">    ensureCapacityInternal(count+len);</span><br><span class="line">    str.getChars(<span class="number">0</span>,len,value,count);<span class="comment">//将str[0,len)的字符复制到value中，从count处开始</span></span><br><span class="line">    count+=len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出StringBuilder内部是直接将字符串复制到字符数组中，如果字符数组长度不够，会进行扩展。<br>StringBuffer和StringBuilder类似，区别就是StringBuffer内部的方法被synchronized修饰，所以是线程安全的方法。</p>
<h1 id="五、为什么不建议在for循环中使用-拼接字符串？"><a href="#五、为什么不建议在for循环中使用-拼接字符串？" class="headerlink" title="五、为什么不建议在for循环中使用+拼接字符串？"></a>五、为什么不建议在for循环中使用+拼接字符串？</h1><p>+本质是将String转换成StringBuilder进行append，对于如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;daisybby&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    String s=String.valueOf(i);</span><br><span class="line">    str+=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其字节码反编译后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;daisybby&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    String s=String.valueOf(i);</span><br><span class="line">    str=(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>()).append(str).append(s).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每执行一次循环就创建一个StringBuilder对象，频繁创建对象不仅耗费时间，更会造成内存资源的浪费。<br><strong>推荐方案：</strong> 在循环外部创建一个StringBuilder，在循环内部直接调用append。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>基础概念和原理</category>
      </categories>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2024/07/13/Java-Generics/</url>
    <content><![CDATA[<h1 id="一、什么是泛型？"><a href="#一、什么是泛型？" class="headerlink" title="一、什么是泛型？"></a>一、什么是泛型？</h1><span id="more"></span>
<p>&ensp;&ensp;&ensp;&ensp;泛型是Java5引入的新特性，我们在开发时，可以自己定义<strong>类</strong>、<strong>接口</strong>或者<strong>方法</strong> 的数据类型。在泛型类实例化或者泛型方法调用时指定具体是什么数据类型。（我感觉和C++的模板功能很像）。<br>比如一个泛型类的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.data=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么要引入泛型类呢？</strong></p>
<ol>
<li><strong>方便：</strong>泛型提高了代码的复用性。在实际项目开发中，我们会定义通用的返回结果类。<a href="https://daisybby.github.io/2024/07/13/why-to-read-common-Result/">为什么要定义通用返回结果类？</a><br>例如，List中保存的数据可能是Integer，也可能是String。如果不用泛型，就只能定义多个List接口，而泛型可以很好的解决这个问题。</li>
<li><strong>安全：</strong>在泛型之前，一些需要通用性的功能可以用Object来实现，毕竟Object是一切类的父类，Object的类型转换是在<strong>运行时</strong>检查的，如果类型转换出错，程序直接崩溃；而泛型是在<strong>编译时</strong>做类型检查，问题提前暴露出来。</li>
</ol>
<h1 id="二、泛型是怎么实现的？"><a href="#二、泛型是怎么实现的？" class="headerlink" title="二、泛型是怎么实现的？"></a>二、泛型是怎么实现的？</h1><p>在底层，泛型是通过<strong>类型擦除</strong>来实现的。</p>
<h2 id="2-1-类型擦除"><a href="#2-1-类型擦除" class="headerlink" title="2.1.类型擦除"></a>2.1.类型擦除</h2><p>先看一个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt;&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.data=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后再反编译，这段代码变成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.data=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;其实泛型这个概念在编译后就不存在了，无论是Box<String>还是Box<Integer>对应的都是同一份字节码。上面的例子中，类型被替换成了Object，其实是替换成界限类型，通常界限类型是Object。<br>&ensp;&ensp;&ensp;&ensp;那么在这里，其实对“语法糖”这个概念的理解就更深刻了，JVM本质上并不能识别语法糖，只是为了方便程序员开发程序的工具，编译阶段的desugar()解语法糖操作就是将JVM无法执行的语法糖转换成基本的语法。这里的泛型也是这样的，所以泛型技术也是一颗语法糖。<br>&ensp;&ensp;&ensp;&ensp;由此，泛型是有一些坑的。</p>
<h1 id="三、泛型的缺点有哪些？"><a href="#三、泛型的缺点有哪些？" class="headerlink" title="三、泛型的缺点有哪些？"></a>三、泛型的缺点有哪些？</h1><ol>
<li>泛型不能重载。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在已经定义了上述T标识的泛型类Box之后，又定义同名泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;U&gt;&#123;</span><br><span class="line">    U data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(U data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.data=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> U <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码编译是无法通过的，因为经过类型擦除后两个类对应的字节码是一摸一样的。</li>
<li>对于泛型异常类，是不能被catch到带有具体类型的异常的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericException</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> T detail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericException</span><span class="params">(T detail)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.detail = detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getDetail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> detail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGenericException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟抛出一个泛型异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GenericException</span>&lt;&gt;(<span class="string">&quot;这是一个异常信息&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GenericException&lt;String&gt; e) &#123; <span class="comment">// 错误：无法捕获带泛型参数的异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;捕获String类型的泛型异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GenericException e) &#123; <span class="comment">// 正确：可以捕获泛型异常本身</span></span><br><span class="line">            System.out.println(<span class="string">&quot;捕获泛型异常&quot;</span>);</span><br><span class="line">            <span class="comment">// 但是无法直接使用e.getDetail()，因为它的返回类型是Object</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">// 正确：可以捕获所有非泛型的Exception</span></span><br><span class="line">            System.out.println(<span class="string">&quot;捕获非泛型的异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于这段代码，第一个catch是错误的。</li>
<li>泛型类中的静态变量只有一份，不会有多份。<br>尽管实例化时类型不同，但是类之间还是共享静态变量的，可以简单地理解为静态变量和类定义是绑定的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericClass</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVariable</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">incrementStaticVariable</span><span class="params">()</span> &#123;</span><br><span class="line">        staticVariable++; <span class="comment">// 递增静态变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getStaticVariable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> staticVariable; <span class="comment">// 返回静态变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGenericClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericClass&lt;Integer&gt; intClass = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        GenericClass&lt;String&gt; stringClass = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递增静态变量</span></span><br><span class="line">        GenericClass.incrementStaticVariable();</span><br><span class="line">        <span class="comment">// 检查静态变量的值</span></span><br><span class="line">        System.out.println(GenericClass.getStaticVariable()); <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次递增静态变量</span></span><br><span class="line">        intClass.incrementStaticVariable();</span><br><span class="line">        <span class="comment">// 检查静态变量的值</span></span><br><span class="line">        System.out.println(GenericClass.getStaticVariable()); <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 即使使用不同的泛型类型参数，静态变量仍然相同</span></span><br><span class="line">        stringClass.incrementStaticVariable();</span><br><span class="line">        <span class="comment">// 检查静态变量的值</span></span><br><span class="line">        System.out.println(GenericClass.getStaticVariable()); <span class="comment">// 输出 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="四、泛型上下界限定符"><a href="#四、泛型上下界限定符" class="headerlink" title="四、泛型上下界限定符"></a>四、泛型上下界限定符</h1><ol>
<li>extends表示类型上界，表示参数化类型可能是T或者是T的子类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以接受Number的任何子类</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">processNumber</span><span class="params">(T number)</span>&#123;</span><br><span class="line">    <span class="type">double</span> value=number.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>super表示类型下界，也就是说能够接受的参数是T或者T的超类型（父类型），直至Object。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addElements</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; list,T element)</span>&#123;</span><br><span class="line">    list.add(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="五、List、List和List三者之间的关系"><a href="#五、List、List和List三者之间的关系" class="headerlink" title="五、List&lt;?&gt;、List&lt;Object&gt;和List三者之间的关系"></a>五、List&lt;?&gt;、List&lt;Object&gt;和List三者之间的关系</h1><ol>
<li>List<?>是一个未知类型的List，而List<Object>是任意类型的List。可以将List<String>赋值给List<?>，但是不能赋值给List<Object>，原因是泛型非协变。</li>
<li>List&lt;?&gt;由于不确定列表中元素的具体类型，所以不允许向列表里添加除了null之外的元素，只能读取数据。但是读取的时候，需要强制类型转换。</li>
</ol>
<h1 id="六、数组协变和泛型非协变"><a href="#六、数组协变和泛型非协变" class="headerlink" title="六、数组协变和泛型非协变"></a>六、数组协变和泛型非协变</h1><h2 id="6-1-数组协变"><a href="#6-1-数组协变" class="headerlink" title="6.1.数组协变"></a>6.1.数组协变</h2><p>Object[]是String[]的父类数组，可以进行赋值。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Object[] superArray=<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">        String[] subArray=<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        superArray=subArray;<span class="comment">//这是可以的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-泛型非协变"><a href="#6-2-泛型非协变" class="headerlink" title="6.2.泛型非协变"></a>6.2.泛型非协变</h2><p>可以简单理解为List<Object>和List<String>并不是一回事。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        List&lt;Object&gt; superList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; subList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        superList=subList;<span class="comment">//编译错误，因为List用的是泛型，泛型非协变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>统一结果返回类</title>
    <url>/2024/07/13/why-to-read-common-Result/</url>
    <content><![CDATA[<h1 id="一、为什么需要统一泛型"><a href="#一、为什么需要统一泛型" class="headerlink" title="一、为什么需要统一泛型"></a>一、为什么需要统一泛型</h1><span id="more"></span>
<p>在实际项目开发时，每个接口返回数据类型都不同，前端解析后端返回的不同类型数据时比较麻烦。为了解决这个问题，我们需要定义一个固定格式的返回结果，例如名为Result的泛型类，通常使用JSON格式返回给前端，包括<strong>状态码、信息、数据</strong>三个属性。</p>
<h1 id="二、枚举类"><a href="#二、枚举类" class="headerlink" title="二、枚举类"></a>二、枚举类</h1><p>在统一返回结果类中，包含状态码，状态码通过枚举类来实现。<br><strong>枚举类：</strong></p>
<ul>
<li>通过关键字<code>enum</code>可以定义枚举类，在枚举类中需要显式定义处一个或多个枚举常量，枚举常量就是枚举类所有的实例对象。枚举类并不能像一般的Java类一样，任意创建对象。</li>
<li>枚举对象是在枚举类定义时就写好的，是唯一的、已命名的对象。<br>比如在统一返回结果类中，我们要用到的状态码，就可以通过枚举类来实现，因为状态码是有限的，且不能随意定义的。</li>
<li>枚举类的构造器默认是用private修饰的，一旦为枚举类显式定义了带有参数的构造器，定义枚举常量时就必须传入参数。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="comment">//第一行显式定义所有的枚举常量-即枚举类的所有实例</span></span><br><span class="line">    SUCCESS(<span class="number">200</span>,<span class="string">&quot;success&quot;</span>),</span><br><span class="line">    FAIL(<span class="number">201</span>,<span class="string">&quot;fail&quot;</span>),</span><br><span class="line">    SERVICE_ERROR(<span class="number">2012</span>,<span class="string">&quot;service error&quot;</span>),</span><br><span class="line">    ILLEGAL_REQUEST(<span class="number">205</span>, <span class="string">&quot;illegal request&quot;</span>),</span><br><span class="line">    REPEAT_SUBMIT(<span class="number">206</span>, <span class="string">&quot;repeat submit&quot;</span>),</span><br><span class="line">    ARGUMENT_VALID_ERROR(<span class="number">210</span>, <span class="string">&quot;argument valid error&quot;</span>),</span><br><span class="line"></span><br><span class="line">    LOGIN_AUTH(<span class="number">208</span>, <span class="string">&quot;未登陆&quot;</span>),</span><br><span class="line">    PERMISSION(<span class="number">209</span>, <span class="string">&quot;没有权限&quot;</span>),</span><br><span class="line">    ACCOUNT_ERROR(<span class="number">214</span>, <span class="string">&quot;账号不正确&quot;</span>),</span><br><span class="line">    PASSWORD_ERROR(<span class="number">215</span>, <span class="string">&quot;密码不正确&quot;</span>),</span><br><span class="line">    LOGIN_MOBLE_ERROR( <span class="number">216</span>, <span class="string">&quot;账号不正确&quot;</span>),</span><br><span class="line">    ACCOUNT_STOP( <span class="number">217</span>, <span class="string">&quot;账号已停用&quot;</span>),</span><br><span class="line">    NODE_ERROR( <span class="number">218</span>, <span class="string">&quot;该节点下有子节点，不可以删除&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ResultCode</span><span class="params">(Integer code,String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code=code;</span><br><span class="line">        <span class="built_in">this</span>.message=messgae;</span><br><span class="line">    &#125;<span class="comment">//其实可以狭隘地理解为，在外部的方法中是直接使用上面定义的枚举常量，这个构造器不会被外部方法调用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、统一返回结果类定义"><a href="#三、统一返回结果类定义" class="headerlink" title="三、统一返回结果类定义"></a>三、统一返回结果类定义</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Result</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        Result result=<span class="keyword">new</span> <span class="title class_">Result</span>&lt;T&gt;();</span><br><span class="line">        <span class="keyword">if</span>(data!=<span class="literal">null</span>)&#123;</span><br><span class="line">            result.data=data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T data,Integer code,String message)</span>&#123;</span><br><span class="line">        Result&lt;T&gt; result=<span class="keyword">new</span> <span class="title class_">Result</span>&lt;T&gt;();</span><br><span class="line">        result.data=data;</span><br><span class="line">        result.setCode(code);</span><br><span class="line">        result.setMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">ok</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(data,ResultCode.SUCCESS.getCode(),ResultCode.SUCCESS.getMessage());</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">fail</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(data,ResultCode.FAIL.getCode(),ResultCode.FAIL.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">fail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下两个方法使得可以return Result.build(data).message(&quot;操作成功!&quot;);这样的链式编程</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;T&gt; <span class="title function_">message</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result&lt;T&gt; <span class="title function_">code</span><span class="params">(Integer code)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setCode(code);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Redis项目笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Java反射机制</title>
    <url>/2024/07/13/Java-Reflection/</url>
    <content><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><span id="more"></span>
<p>反射机制是指程序在<strong>运行时</strong>能够获得自身的信息。<br>Java的反射机制可以实现：</p>
<ul>
<li>在运行时判断任意对象所属类；</li>
<li>在运行时判断一个类所具有的成员变量和方法</li>
<li>在运行时调用对象的方法</li>
<li>在运行时构造任意类的对象</li>
</ul>
<p>反射机制使得程序开发更加灵活，在运行时能够执行更多操作，但是反射机制也带来了一些问题:</p>
<ol>
<li>代码可读性和可维护性降低</li>
<li>反射代码的执行性能低</li>
<li>反射破坏了封装性</li>
</ol>
<h1 id="二、为什么反射速度慢？"><a href="#二、为什么反射速度慢？" class="headerlink" title="二、为什么反射速度慢？"></a>二、为什么反射速度慢？</h1><ol>
<li>反射涉及到动态解析的类型，因此不能执行某些Java虚拟机优化</li>
<li>使用反射时，单数需要包装成Object[]类型，但是方法真正执行时又要解包；打包和解包的操作不仅耗费时间，中间还会产生很多对象，更容易导致GC；</li>
<li>反射调用方法时会从方法数组中遍历查找，检查方法可见性，这些操作都比较耗时；</li>
<li>参数额外检查。</li>
</ol>
<h1 id="三、反射常见的应用场景"><a href="#三、反射常见的应用场景" class="headerlink" title="三、反射常见的应用场景"></a>三、反射常见的应用场景</h1><ol>
<li>动态代理</li>
<li>BeanUtils中的属性拷贝</li>
<li>RPC框架</li>
<li>Spring的IOC&#x2F;DI</li>
</ol>
<h1 id="四、反射和Class的关系"><a href="#四、反射和Class的关系" class="headerlink" title="四、反射和Class的关系"></a>四、反射和Class的关系</h1><p>Java的Class类时反射机制的基础。被装入到JVM中的所有类，都有一个关联的Class对象，通过这个对象，可以实现被装入类的详细信息访问。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java中创建对象有哪些方式？</title>
    <url>/2024/07/15/all-appoaches-to-create-object/</url>
    <content><![CDATA[<h1 id="1-使用new关键字"><a href="#1-使用new关键字" class="headerlink" title="1.使用new关键字"></a>1.使用new关键字</h1><span id="more"></span>
<p>这是我们最常见的、最简单的创建对象方法，通过调用构造函数来创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>
<h1 id="2-使用反射机制"><a href="#2-使用反射机制" class="headerlink" title="2.使用反射机制"></a>2.使用反射机制</h1><h2 id="2-1-使用Java-lang-Class地newInstance-方法"><a href="#2-1-使用Java-lang-Class地newInstance-方法" class="headerlink" title="2.1.使用Java.lang.Class地newInstance()方法"></a>2.1.使用Java.lang.Class地newInstance()方法</h2><p>Java中每个类都有唯一的Class对象，通过Class对象调用newInstance()创建一个对象。通过这种方法我们可以调用<strong>无参</strong>的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过类的路径来获取Class对象</span></span><br><span class="line">User user=(User)Class.forName(<span class="string">&quot;xx.xx.User&quot;</span>).newInstance();</span><br><span class="line"><span class="comment">//或者是通过类直接获取Class对象</span></span><br><span class="line">User user=User.Class.newInstance();</span><br></pre></td></tr></table></figure>
<h2 id="2-2-使用Java-lang-reflect-Constructor类的newInstance-方法"><a href="#2-2-使用Java-lang-reflect-Constructor类的newInstance-方法" class="headerlink" title="2.2.使用Java.lang.reflect.Constructor类的newInstance()方法"></a>2.2.使用Java.lang.reflect.Constructor类的newInstance()方法</h2><p>通过这种方法，我们可以调用<strong>有参或者无参</strong>的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取类的构造器</span></span><br><span class="line">Constructor constructor=User.class.getConstructor();</span><br><span class="line">User user=constructor.newInstance();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，以上两种方法只能调用被public修饰的构造方法，Class类是不能访问的，会抛出IllegalAccessException异常；Contructor虽然可以获取到private或者Protected的构造函数，但是调用时也会抛出IllegalAccessException异常，需要constructor.setAccessible(true)来修改访问权限。<br>例如:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyClass</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Class Main&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Constructor&lt;MyClass&gt; constructor=MyClass.class.getDeclaredContructor();</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            MyClass instance=constructor.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-反序列化时，JVM创建对象"><a href="#3-反序列化时，JVM创建对象" class="headerlink" title="3.反序列化时，JVM创建对象"></a>3.反序列化时，JVM创建对象</h1><p>这里不再用代码演示，例如从文件中读取序列化后的对象，并反序列化还原的时候会创建新的对象。</p>
<h1 id="4-使用clone方法"><a href="#4-使用clone方法" class="headerlink" title="4.使用clone方法"></a>4.使用clone方法</h1><p>无论何时调用一个对象的clone方法，JVM都会将当前对象的所有内容复制到新对象中。使用clone方法创建对象并<strong>不会调用</strong>任何构造函数。<br>要使用clone方法，类需要实现Cloneable接口，并实现clone方法。如果没有重写clone方法，会调用Object类的clone方法，这是一个native方法。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java代理模式</title>
    <url>/2024/07/15/Java-Dynamic-proxy/</url>
    <content><![CDATA[<h1 id="一、Java代理模式"><a href="#一、Java代理模式" class="headerlink" title="一、Java代理模式"></a>一、Java代理模式</h1><span id="more"></span>
<p><strong>1. 是什么？</strong><br>代理模式是设计模式的一种。<br>代理模式允许通过代理独享访问目标对象，而且还能够在不修改被代理的目标对象的前提下，对目标对象进行功能的增强和扩展。<br><strong>2.实现方式</strong><br>Java有静态代理和动态代理两种实现方式。<br>个人理解静态代理就是程序员自己编写的增强代码，并没有涉及到别的库或者框架之类。<br><strong>两种方式的主要区别：</strong></p>
<ul>
<li>静态代理在<strong>编译时</strong>就确定了代理对象和目标对象之间的关系。</li>
<li>动态代理在<strong>运行时</strong>才能确定代理对象和目标对象之间的关系。</li>
</ul>
<h1 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h1><p>关键点：</p>
<ul>
<li>代理类需要程序员手动编写，且代理类必须与目标类实现相同的接口；</li>
<li>代理类内部持有目标类的引用；</li>
<li>先调用代理对象方法，再转而调用目标对象的方法。<br>动态代理的缺点：</li>
<li>需要对每一个被代理的类手动编写代理对象，增加了程序员的代码量；</li>
<li>代理对象和目标对象之间的关系在编译时就已经确定，灵活性比较差；</li>
<li>代理类是必须和目标类实现相同的接口。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现一个具体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A dog is eating!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现静态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogProxy</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Animal animal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DogProxy</span><span class="params">(Animal animal)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.animal=animal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DogProxy start:&quot;</span>);</span><br><span class="line">        animal.eat();</span><br><span class="line">        System.out.println(<span class="string">&quot;DogProxy end:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说实话，感觉就是基于代理模式写的普通代码。</p>
</blockquote>
</li>
</ul>
<h1 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a>三、动态代理</h1><ol>
<li><strong>JDK动态代理：</strong>Java.lang.reflect的Proxy类提供了InvocationHandler接口，能够生成动态代理类。</li>
<li><strong>Cglib动态代理：</strong>Cglib是第三方代码生成类库，运行时能够在内存中动态生成一个子类对象，从而实现对目标对象功能的扩展。</li>
</ol>
<p><strong>两种方式之间的区别：</strong></p>
<ol>
<li>使用JDK动态代理的对象必须实现一个或多个接口；</li>
<li>Cglib可以在运行期扩展Java类，实现Java接口，被Spring AOP等框架广泛使用，不需要类必须实现接口，能够达到代理类无侵入。</li>
</ol>
<h2 id="3-1-JDK动态代理实现"><a href="#3-1-JDK动态代理实现" class="headerlink" title="3.1.JDK动态代理实现"></a>3.1.JDK动态代理实现</h2><ol>
<li>定义一个接口，比如常用的service接口等；</li>
<li>创建InvocationHandler接口的实现类，这个类负责目标对象的方法调用+额外的增强功能；</li>
<li>使用Proxy类的newProxyInstance方法生成一个代理对象，传入目标对象.class的classLoader和接口数组、以及第2步实现的InvocationHandler子类对象</li>
<li>通过代理对象调用目标对象的方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A dog is eating!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object targetObject)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.targetObject=targetObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span> <span class="keyword">throw</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理开始。&quot;</span>);</span><br><span class="line">        Object result=method.invoke(targetObject,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理结束。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        Dog dog=<span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">        MyInvocationHandler handler=<span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(dog);</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        Dog proxy=(Dog)Proxy.newProxyInstance(dog.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;dog.class&#125;,handler);</span><br><span class="line">        proxy.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
个人理解的JDK动态代理：<img src="/2024/07/15/Java-Dynamic-proxy/img1.png" class="" title="img1">
proxy.方法-&gt;转到InvocationHandler对象的invoke方法-&gt;执行增强代码段+method.invoke-&gt;跳转到目标对象的方法执行-&gt;返回到InvocationHandler的invoke，执行剩下的增强代码段。<br><strong>InvocationHandler接口：</strong><br>实现JDK动态代理，需要实现InvocationHandler接口，创建一个调用处理程序，在创建代理对象的时候将调用处理程序handler传入。<br>接口中有一个invoke方法，这是方法调用的核心方法。<br>方法的参数表：</li>
</ol>
<ul>
<li>Object：目标对象</li>
<li>Method：被调用的方法</li>
<li>Object[]：参数列表，被打包成了Object数组<br>方法返回类型是Object。<br>在invoke方法中实现目标方法的增强，也是在这里通过Method.invoke调用目标对象的方法。<br><strong>Proxy类：</strong><br>用Proxy.newProxyInstancce方法来创建代理对象。<br>方法参数：</li>
<li>ClassLoader：目标对象所属类的类加载器；</li>
<li>Class&lt;?&gt;[] interfaces：目标对象所实现接口的数组，以便代理对象实现这些接口，只有实现这些接口才能调用接口中的方法。</li>
<li>InvocationHandler：调用处理器。<blockquote>
<p>关于动态代理灵活性的思考：<br>在实现InvocationHandler接口的时候，targetObject的类型是Object，这意味着可以传入任意类的对象；在invoke方法中，也可以调用对象的任意方法。</p>
</blockquote>
</li>
</ul>
<h2 id="3-2-Cglib动态代理"><a href="#3-2-Cglib动态代理" class="headerlink" title="3.2.Cglib动态代理"></a>3.2.Cglib动态代理</h2><p>Cglib在运行时动态生成被代理类的<strong>子类</strong>，是通过<strong>继承</strong>的方式实现动态代理，所以如果类被声明为final，则无法用CGLIB来实现动态代理。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/2024/07/16/Java-Meta-Annotation/</url>
    <content><![CDATA[<h1 id="一、Java注解的作用是什么？"><a href="#一、Java注解的作用是什么？" class="headerlink" title="一、Java注解的作用是什么？"></a>一、Java注解的作用是什么？</h1><span id="more"></span>
<p>Java注解并不直接影响代码的执行，不过有些注解可以用于这一目的。<br>通俗来讲，注解相当于一种标识，可以用来标识一个<strong>类</strong>、<strong>方法</strong>或者是<strong>字段</strong>。在其他地方的业务代码里，可以判断有某个注解的代码段，进而定制一些处理。<br>例如，@Bean注解，标识了要向IOC容器中注入一个Java Bean。</p>
<h1 id="二、元注解"><a href="#二、元注解" class="headerlink" title="二、元注解"></a>二、元注解</h1><p>元注解就是用来定义其他注解的注解。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码定义了Override注解，其中的@Target和@Retention就是元注解。<br><strong>四个元注解：</strong></p>
<ul>
<li>@Target：表示注解可以用于修饰什么内容</li>
<li>@Retention：表示注解能够保存到什么级别</li>
<li>@Documented：将此注解包含到javadoc中</li>
<li>@Inherited：允许子类继承父类中的注解</li>
</ul>
<h2 id="2-1-Retention"><a href="#2-1-Retention" class="headerlink" title="2.1.@Retention"></a>2.1.@Retention</h2><p>指定被修饰的注解的生命周期，有三个可选值：</p>
<ul>
<li>SOURCE：注解仅在源代码保留，编译后就没了。</li>
<li>CLASS：注解在编译时保存到字节码中，但是在运行时不能被访问，仅用于编译时的检查。这是默认取值。</li>
<li>RUNTIME：注解在编译时保存到字节码中，并且在运行时可以通过反射进行访问，支持运行时检查注解信息。这也是最常用的取值。</li>
</ul>
<h2 id="2-2-Target"><a href="#2-2-Target" class="headerlink" title="2.2.@Target"></a>2.2.@Target</h2><p>指定被修饰的注解可以修饰什么元素类型，例如类、方法和字段等。这样可以限制注解的使用范围。<br>取值范围：</p>
<ul>
<li>ElementType.CONSTRUCTOR: 表示注解可以应用于构造器。</li>
<li>ElementType.FIELD: 表示注解可以应用于字段（包括枚举的常量）。</li>
<li>ElementType.LOCAL_VARIABLE: 表示注解可以应用于局部变量。这个选项从Java 8开始支持。</li>
<li>ElementType.METHOD: 表示注解可以应用于方法。</li>
<li>ElementType.PACKAGE: 表示注解可以应用于包声明。</li>
<li>ElementType.PARAMETER: 表示注解可以应用于参数。</li>
<li>ElementType.TYPE: 表示注解可以应用于类、接口（包括注解类型）或枚举类型。</li>
<li>ElementType.ANNOTATION_TYPE: 表示注解可以应用于另一个注解类型。</li>
<li>ElementType.TYPE_PARAMETER: 表示注解可以应用于类型参数（泛型）。这个选项从Java 8开始支持。</li>
<li>ElementType.TYPE_USE: 表示注解可以应用于任何类型使用的地方，比如实例化对象、类型转换等。这个选项从Java 8开始支持。</li>
</ul>
<h2 id="2-3-Documented"><a href="#2-3-Documented" class="headerlink" title="2.3.@Documented"></a>2.3.@Documented</h2><p>用于指示注解是否会出现在生成的Java文旦中，如果被@Documented元注解修饰，则该注解的信息会出现在API文档中。</p>
<h2 id="2-4-Inherited"><a href="#2-4-Inherited" class="headerlink" title="2.4.@Inherited"></a>2.4.@Inherited</h2><p>指示该注解修饰的注解能不能被继承。默认情况下，注解不能被继承，也就是子类并不能继承父类的注解，但是@Inherited修饰的注解可以被子类继承。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java 序列化</title>
    <url>/2024/07/16/Java-Serialization/</url>
    <content><![CDATA[<h1 id="一、什么是序列化和反序列化？"><a href="#一、什么是序列化和反序列化？" class="headerlink" title="一、什么是序列化和反序列化？"></a>一、什么是序列化和反序列化？</h1><span id="more"></span>
<p>在程序运行时，对象是保存在JVM堆内存的，只要对象没有被回收，我们都可以更方便地使用对象。但是JVM停止运行后，Java对象都丢失了。<br>在一些业务场景中，我们需要持久化保存对象，怎么将动态的对象保存呢？这就需要对象序列化。<br><strong>对象序列化就是将对象的状态保存为字节数组，在需要用到对象时，将字节数组反序列化为对象。</strong><br>实际开发中，需要对象序列化的应用场景很多，对象持久化被广泛应用于网络传输、RPC中。<br>被序列化的类必须属于Enum、Array和Serializable类型其中的任何一种。</p>
<h1 id="二、如何进行序列化和反序列化？"><a href="#二、如何进行序列化和反序列化？" class="headerlink" title="二、如何进行序列化和反序列化？"></a>二、如何进行序列化和反序列化？</h1><p>一个类实现了java.io.Serializable接口才能被序列化。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//......定义类属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> serialVersionUID=XXXXXXXXXXL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对User进行序列化和反序列化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">serializableDemo</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">//填写User各属性信息</span></span><br><span class="line">        User.setName(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将对象序列化到文件中</span></span><br><span class="line">        ObjectOutputStream output=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            output=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;tempObjectFile&quot;</span>));</span><br><span class="line">            output.writeObject(user);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            IOUtils.closeQuietly(output);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从文件反序列化对象</span></span><br><span class="line">        File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;tempObjectFile&quot;</span>);</span><br><span class="line">        ObjectInputStream input=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            input=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">            User newUser=(User)input.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            IOUtils.closeQuietly(input);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                FileUtils.forceDelete(file);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong></p>
<ol>
<li>一个类只要实现了Serializable接口就能被序列化；</li>
<li>Java通过ObjectInputStream和ObjectOutputStream序列化和反序列化；</li>
<li>JVM是否允许反序列化，不仅取决于类路径和功能代码一致，更取决于序列化ID是否一致（就是User中定义的private static final long serialVersionUID）；</li>
<li>序列化的时候并不保存静态变量，因为静态变量是属于类的，而不是对象。</li>
<li>transient关键字修饰的成员变量不会被序列化，这一类变量在反序列化时，以初始化值填充，比如int类型被填充为0，boolean被填充为false。</li>
<li>可序列化类的所有子类都是可序列化的；如果一个类的父类不能序列化，但是想要将父类中定义的变量持久化，那么父类也要修改为可序列化的。</li>
</ol>
<h1 id="三、Externalizable接口是什么？与Serializable有什么区别？"><a href="#三、Externalizable接口是什么？与Serializable有什么区别？" class="headerlink" title="三、Externalizable接口是什么？与Serializable有什么区别？"></a>三、Externalizable接口是什么？与Serializable有什么区别？</h1><p>Externalizable继承自Serializable接口，使得开发者能够更加精细地控制序列化。<br>两者的区别如下：</p>
<ol>
<li>接口类型：<ul>
<li>Serializable是Java提供的默认序列化机制，实现这个接口时，要进行序列化的类并没有什么方法是需要实现的，直接implements Serializable就行；</li>
<li>Externalizable有两个方法必须实现:writeExternal(ObjectOutput out)和readExternal(ObjectInput in)；<blockquote>
<p>如果没有在这两个方法中定义序列化实现细节，序列化之后对象内容是空的。并且实现Externalizable接口的类一定要提供一个public的无参构造函数。</p>
</blockquote>
</li>
</ul>
</li>
<li>序列化范围：<ul>
<li>Serializable：默认机制，对象所有可访问的字段（包括private字段）都会被序列化，除非用transient修饰，阻止部分字段的序列化；</li>
<li>Externalizable：实现writeExternal和readExternal来控制哪些部分进行序列化，以及如何序列化，或者是在序列化、反序列化时执行一些额外的操作（加密）等。提供了更细粒度的序列化控制。</li>
</ul>
</li>
<li>性能：<ul>
<li>Serializable在序列化时，涉及到了反射调用，反射调用的效率是比较低的。</li>
<li>Externalizable允许只序列化必要的字段，可以避免反射调用，提升效率。</li>
</ul>
</li>
<li>使用场景不同：<ul>
<li>如果不需要特殊的处理，或者是没有性能优化的需求，可以用Serializable来实现序列化与反序列化；</li>
<li>如果想要实现更细粒度的序列化，或者是提升序列化的效率，用Externalizable比较合适。</li>
</ul>
</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用Serializable实现序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> transientId;<span class="comment">//这个字段不会被序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long onlyId=XXXXXXL;<span class="comment">//静态变量也不会被序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用Externalizable实现序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Long field;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span>&#123;&#125;<span class="comment">//实现Externalizable接口必须提供无参构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        out.writeInt(field);<span class="comment">//只序列化field字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        field=in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、serialVersionUID的用途"><a href="#四、serialVersionUID的用途" class="headerlink" title="四、serialVersionUID的用途"></a>四、serialVersionUID的用途</h1><p>在反序列化时，虚拟机是否允许某个反序列化操作执行，不仅取决于类路径和功能代码是否一致，还有一点就是代码中的类与序列化后的类，两者之间的serialVersionUID是一致的。</p>
<blockquote>
<p>类路径和功能代码一致，我理解的意思就是class类的文件路径和类的实际逻辑代码。这是为了保证序列化时的类定义和反序列化时加载的类定义是一致的。</p>
</blockquote>
<p>在反序列化的时候，会对比类代码中定义的serialVersionUID和字节流中的serialVersionUID是不是相同，相同则可以序列化，否则抛出InvalidCastException，这样是为了避免字节流的内容被修改。<br>如果定义类的时候，没有显式定义serialVersionUID，那么在序列化的时候会根据编译的Class自动生成一个serialVersionUID，如果Class文件没有发生变化，serialVersionUID也不会发生变化，但是如果Class修改了，那这个Class文件对应的UID也会改变，这样反序列化的时候，就找到不到原来的类了。</p>
<blockquote>
<p>在实际开发中，建议显式定义serialVersionUID。如果不显式定义，系统会自动生成UID，一旦类实现代码有修改，对应的UID也会修改，修改之前序列化的类就再也没办法反序列化回来了。<br>但是，如果显式定义了serialVersionUID，尽管我们修改了类实现代码，比如新增了属性字段，但是serialVersionUID是不变的，所以依然能够反序列化，这就实现了序列化机制的向后兼容。</p>
<ul>
<li>新增属性段：反序列化时这些新字段设置为默认值；</li>
<li>删除属性字段：反序列化时会忽略掉那些多余的字段，并不会报错。</li>
</ul>
</blockquote>
<p>在实际开发中，有一些序列化框架，比如kryo、hessian、gson、fastjson等。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java异常</title>
    <url>/2024/07/16/Java-Exception/</url>
    <content><![CDATA[<h1 id="一、Java异常分类"><a href="#一、Java异常分类" class="headerlink" title="一、Java异常分类"></a>一、Java异常分类</h1><span id="more"></span>
<p>Java的异常可以分为两大类：<strong>受检异常和非受检异常</strong>。<br><strong>受检异常：</strong><br>意味着如果方法声明中写了throws Exception，在程序中调用这个方法的时候，一定要对异常进行处理——进一步向上抛出，或者是catch异常。<br>受检异常强制开发者明确地处理一些特殊情况，比如读取文件的时候，就是必须要考虑找不到文件的情况，这里的FileNotFoundException就是必须要处理。<br>当我们希望我们写的方法被调用时，调用者明确地处理特殊情况，<strong>就可以使用受检异常</strong>。<br><strong>非受检异常：</strong><br>一般是运行时异常，即RuntimeException，在编写代码的时候，并不是显式捕获，但是这类异常发生的时候，程序执行就会停止。<br>非受检异常一般是代码的bug引起的，比如数组越界、空指针异常，只要代码写的没问题，就不会出现这些异常，所以不需要显式处理。而且这类异常要事无巨细地都显式处理，开发压力属实有点大。</p>
<h1 id="二、Throwable、Error和Excetption"><a href="#二、Throwable、Error和Excetption" class="headerlink" title="二、Throwable、Error和Excetption"></a>二、Throwable、Error和Excetption</h1><p>Throwable是Java中最顶级的异常类，继承自Object，实现了Serializable接口，有两个子类：Error和Exception。<br><strong>Error和Exception的区别与联系：</strong><br><strong>Error：</strong><br>Error是Java运行环境内部错误或者是硬件的问题，由Java虚拟机抛出。例如OutOfMemoryError，StackOverflow这两种常见的错误。<br><strong>Exception：</strong><br>Exception是需要catch和处理的异常，是程序不完善导致的，Exception是程序必须处理的问题。分为运行时异常RuntimeException和其他异常。</p>
<h1 id="三、throws、throw、try、catch和finally，异常处理关键字"><a href="#三、throws、throw、try、catch和finally，异常处理关键字" class="headerlink" title="三、throws、throw、try、catch和finally，异常处理关键字"></a>三、throws、throw、try、catch和finally，异常处理关键字</h1><p><strong>try</strong>用来指定一块预防所有异常的程序；<br><strong>catch</strong>紧跟try，用来指定要捕获的异常类型；<br><strong>finally</strong>确保一段代码，无论发生什么异常都要被执行；<br><strong>throw</strong>用来明确地抛出异常；<br><strong>throws</strong>用来声明一个方法可能抛出的各种异常。</p>
<h2 id="3-1-try、catch、finally中return"><a href="#3-1-try、catch、finally中return" class="headerlink" title="3.1.try、catch、finally中return"></a>3.1.try、catch、finally中return</h2><p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终返回的结果是”finally”。因为在finally中有return的情况下，方法最终执行的是finally中的return，覆盖掉try和catch中的return。<br>相似的问题还有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            res=<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            res=<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            res=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终输出的结果是3，和上面的return是一样的，finally中的代码一定会执行。</p>
<h2 id="3-2-finally和return的关系"><a href="#3-2-finally和return的关系" class="headerlink" title="3.2.finally和return的关系"></a>3.2.finally和return的关系</h2><p>在一般情况下，return是独立在try-catch-finally块之外的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            i=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            i=<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            i=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子和之前的例子，区别在于最后一个return是在try-catch-finally之外，执行顺序是try中return i，但是后面还有finally要执行，所以就在这里先把要返回的值保存起来，然后去执行后面的finally，执行完再把暂存的结果return。<br>所以在try中将1保存起来，执行完finally之后，虽然i修改了值为100，但是return缓存还是1，最后的return是2.最后一行的return是不会执行的。<br>另外一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i/<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        i=<span class="number">66</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        i=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，遇到了异常，所以finally一定会执行，最终return的是100；<br>如果没有finally这部分，最终return的是66.<br><strong>如果finally中有return的语句，那么这里的return就是整个try-catch-finally结构的返回值，如果没有，就看try和catch中哪个return执行了。</strong></p>
<h2 id="3-3-finally中的代码一定会执行吗？"><a href="#3-3-finally中的代码一定会执行吗？" class="headerlink" title="3.3.finally中的代码一定会执行吗？"></a>3.3.finally中的代码一定会执行吗？</h2><p>正常情况下，finally中的代码一定会执行，但也有一些“场外因素”：</p>
<ul>
<li>System.out.exit()方法被执行，程序结束了；</li>
<li>Runtime.getRuntime().halt()方法被执行</li>
<li>try或者catch中有死循环</li>
<li>操作系统强制kill掉JVM进程</li>
<li>虚拟机崩溃</li>
<li>虚拟机所运行的环境挂了</li>
<li>如果运行这段代码的是守护线程，如果所有的用户线程都运行完了，守护线程还没运行完，但是JVM要退出，这个时候是不会等守护线程运行完的。<blockquote>
<p>总结而言，只要JVM虚拟机正常运行，线程正常执行，没有这些外界因素干扰的情况下，finally中的代码是会正常执行的。<br>插播：一般执行用户级任务的线程就是用户线程，守护线程即“后台线程”，一般用于执行后台任务。最典型的守护线程应用就是GC。两种线程唯一的区别就是JVM在所有<strong>用户线程</strong>都结束后退出，而不会等<strong>守护线程</strong>执行完。</p>
</blockquote>
</li>
</ul>
<h2 id="3-4-final、finally、finallize有什么区别？"><a href="#3-4-final、finally、finallize有什么区别？" class="headerlink" title="3.4.final、finally、finallize有什么区别？"></a>3.4.final、finally、finallize有什么区别？</h2><p>毫无关系！就是长得像！</p>
<ul>
<li><strong>final：</strong>用来修饰类、方法、成员变量，使其不可继承、不可重写、不可变；</li>
<li><strong>finally：</strong>异常处理的一部分，保证部分代码一定会被执行（通常用于资源清理，比如file.close())</li>
<li><strong>finallize：</strong>是Object类的一个方法，在对象要被垃圾回收时，在回收之前执行一些操作，通常不推荐使用。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java IO方式</title>
    <url>/2024/07/17/Java-IO/</url>
    <content><![CDATA[<h1 id="一、BIO、NIO和AIO"><a href="#一、BIO、NIO和AIO" class="headerlink" title="一、BIO、NIO和AIO"></a>一、BIO、NIO和AIO</h1><span id="more"></span>
<p><strong>BIO(Blocking I&#x2F;O)：同步阻塞I&#x2F;O</strong>JDK1.4之前的传统I&#x2F;O模型，线程发起IO请求后一直阻塞，直到缓冲区数据准备好。<br><strong>NIO(Non-Blocking I&#x2F;O)：同步非阻塞I&#x2F;O</strong>线程发起IO请求后，不需要等待，立即返回。之后定时轮询检查IO缓冲区数据有没有准备好。<br><strong>AIO（Synchronous I&#x2F;O)：异步非阻塞I&#x2F;O</strong>线程发起IO请求后，立即返回，不需要等待也不需要轮询检查，数据缓冲区准备好之后会通知线程。<br><strong>适用场景：</strong><br><strong>BIO：</strong>适合连接比较少且固定的结构，这种方式对服务器资源要求比较高，尽量保证线程不要阻塞太长时间。<br><strong>NIO：</strong>适合连接数量比较多但连接比较短（轻操作）的架构，比如聊天服务器，从JDK1.4开始支持。<br><strong>AIO：</strong>适合连接数量比较多且连接比较长（重操作）的架构，比如相册服务器，从JDK7开始支持。</p>
<h1 id="二、同步-异步，阻塞-非阻塞"><a href="#二、同步-异步，阻塞-非阻塞" class="headerlink" title="二、同步&#x2F;异步，阻塞&#x2F;非阻塞"></a>二、同步&#x2F;异步，阻塞&#x2F;非阻塞</h1><p><strong>同步&#x2F;异步是相对于被调用者而言：</strong><br>A调用B。</p>
<ul>
<li>同步：B收到A的调用后立即就去处理，A此次调用能够获得结果。</li>
<li>异步：B收到A的调用后会记下来，不一定立马就去做，但是一定会去做，执行完之后通知A。在项目中，利用消息队列优化秒杀功能就用到了异步的思想，将秒杀订单保存起来，另开一个线程慢慢保存数据到数据库。<br><strong>阻塞与非阻塞是相对于调用者而言：</strong><br>A调用B。</li>
<li>阻塞：A在发出调用后，一直等待，直到B返回结果。</li>
<li>非阻塞：A发出调用后，返回去做其他的操作，不需要等待。<br>同步不一定阻塞，尽管B立马就去处理，A还是可以利用这个空挡去做别的操作；异步也不一定是非阻塞的，A想等就等，B自己就是没办法立即处理。<br>举个例子：A调用B</li>
</ul>
<ol>
<li>A一直等着，B也立马就去做了。（同步阻塞）</li>
<li>A不等，时不时回来看看好了没，B立马就去做。（同步非阻塞）</li>
<li>A等着，但是B要排队处理。（异步阻塞）</li>
<li>A不等，B也排队处理。（异步非阻塞）</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java值传递还是引用传递？</title>
    <url>/2024/07/17/Java-value-or-incite-pass/</url>
    <content><![CDATA[<h1 id="Java中是值传递还是引用传递？"><a href="#Java中是值传递还是引用传递？" class="headerlink" title="Java中是值传递还是引用传递？"></a>Java中是值传递还是引用传递？</h1><span id="more"></span>
<p>值传递是在传递过程中复制一个副本，传递到方法中，对方法的参数值进行修改，并不会影响到传递之前的变量本身。<br>引用传递，用C++中的地址传递比较好理解，把变量在内存空间中的地址传递过去，把地址中保存的数据修改了，当然所有用到这个变量的值会发生变化。<br>Java的对象传递，本质还是值传递，但是传递过去的是对象的引用，所以如果在方法中修改了对象内部的信息，这个修改是永久的，方法外部也是可见的。<br><strong>但是需要注意的是，对象的传递本质上其实还是值传递，只不过传递的是对象地址的拷贝（对象的引用），尽管和方法外的引用不是同一个，但是指向的还是同一个对象。方法内部借用引用修改对象内容，这就是永久修改。如果我们是把这个引用修改掉了，指向别的对象，那么这对方法外的对象是没有影响的。</strong></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>深拷贝和浅拷贝</title>
    <url>/2024/07/17/Shallow-copy-and-deep-copy/</url>
    <content><![CDATA[<h1 id="一、浅拷贝和深拷贝"><a href="#一、浅拷贝和深拷贝" class="headerlink" title="一、浅拷贝和深拷贝"></a>一、浅拷贝和深拷贝</h1><span id="more"></span>
<p><strong>浅拷贝：</strong>浅拷贝复制出来的是一个新的对象，如果对象中属性是基本类型，则直接复制其值，如果对象属性是对象，那么将对象的地址复制过去。<br><strong>深拷贝：</strong>会创建一个新的对象，将原来的对象所有信息都复制一份。</p>
<blockquote>
<p>深拷贝的好处就是两个对象是完全隔离的，有些时候我们需要完全独立的对象副本，这个时候深拷贝是必须的。</p>
</blockquote>
<p>对于BeanUtils.copyProperties，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;daisybby&quot;</span>,<span class="number">25</span>);</span><br><span class="line">user.setAddress(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;hubei&quot;</span>,<span class="string">&quot;wuhan&quot;</span>,<span class="string">&quot;wuchang&quot;</span>));</span><br><span class="line"></span><br><span class="line">User newUser=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">BeanUtils.copyProperties(user,newUser);</span><br><span class="line"></span><br><span class="line">System.out.println(user==newUser);</span><br><span class="line">System.out.println(user.getAddress()==newUser.getAddress());</span><br></pre></td></tr></table></figure>
<p>最后的输出结果是fasle和true。<br>第一个false是因为浅拷贝也是复制一个新的对象，因此对象是不相同的。<br>第二个true是因为浅拷贝，Address是对象类型，在拷贝的时候直接复制地址，因此两个user对象的Address成员对象是同一个。</p>
<h1 id="二、实现深拷贝"><a href="#二、实现深拷贝" class="headerlink" title="二、实现深拷贝"></a>二、实现深拷贝</h1><h2 id="2-1-重写Cloneable接口的clone-方法"><a href="#2-1-重写Cloneable接口的clone-方法" class="headerlink" title="2.1.重写Cloneable接口的clone()方法"></a>2.1.重写Cloneable接口的clone()方法</h2><p>如果对象实现了Cloneable接口，可以通过重写clone方法来实现深拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> MyOtherClass other;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">        cloned.other = <span class="keyword">new</span> <span class="title class_">MyOtherClass</span>(<span class="built_in">this</span>.other); <span class="comment">// 深拷贝引用类型字段</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-复制构造函数"><a href="#2-2-复制构造函数" class="headerlink" title="2.2.复制构造函数"></a>2.2.复制构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> MyOtherClass other;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(MyClass original)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = original.value;</span><br><span class="line">        <span class="built_in">this</span>.other = <span class="keyword">new</span> <span class="title class_">MyOtherClass</span>(original.other); <span class="comment">// 假设MyOtherClass也有复制构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-序列化和反序列化"><a href="#2-3-序列化和反序列化" class="headerlink" title="2.3.序列化和反序列化"></a>2.3.序列化和反序列化</h2><p>将对象序列化为字节数组之后，再反序列化回来就会创建一个新的对象。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java新版本特性</title>
    <url>/2024/07/17/Java-new-character/</url>
    <content><![CDATA[<h1 id="一、新版本特性总结"><a href="#一、新版本特性总结" class="headerlink" title="一、新版本特性总结"></a>一、新版本特性总结</h1><span id="more"></span>
<p>等待后续补充……</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>char能存储中文吗？</title>
    <url>/2024/07/17/char-and-chinese/</url>
    <content><![CDATA[<p>在Java中，char用来保存16位（2 Byte)的Unicode字符，可以存储任何Unicode字符集中的字符，当然是也包括中文字符。</p>
<span id="more"></span>
<p>因为Unicode字符集的目标就是涵盖所有的字符，所以常见字、生僻字、罕见字以及其他语言的字符，用char都是可以存储的。<br>但是需要注意的是，要确保Java源代码文件本身以及编译器和运行时环境都支持Unicode字符集。也需要注意编码和字符串长度问题。<br>不过Unicode字符集在不断迭代更新，所以十分罕见的字符，可能是暂时、或版本问题，没有保存在Unicode字符集中。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>ClassNotFoundException和NoClassDefFoundError的区别</title>
    <url>/2024/07/17/Difference-of-ClassNotFoundException-and-NoClassDefFoundError/</url>
    <content><![CDATA[<p><strong>ClassNotFoundException</strong>是一个受检异常。通常在类加载阶段尝试加载类时，给定的类路径找不到类定义来触发，比如Class.forName()或者类加载器loadClass或者findSystemClass时，类路径写错了、缺少依赖导致。</p>
<span id="more"></span>
<p><strong>NoClassDefFoundError</strong>是一个Error，在加载类的时候，虽然找到了类文件，但是因为文件损坏等问题导致加载不了。这说明这个类在编译时存在，但是运行时丢失了，就会导致这个问题。</p>
<blockquote>
<p>类似的还有NoSuchMethodError，都是在编译时存在，但是运行时找不到了。通常出现这个Error时，大概率是发生了jar包冲突。<br><a href="">Maven如何解决jar包冲突</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Maven怎么解决jar包冲突</title>
    <url>/2024/07/17/Maven-and-jar-compulsion/</url>
    <content><![CDATA[<h1 id="一、什么是jar包冲突？"><a href="#一、什么是jar包冲突？" class="headerlink" title="一、什么是jar包冲突？"></a>一、什么是jar包冲突？</h1><span id="more"></span>
<p>在应用中，我们同时依赖了A和B两个jar包，而A、B又都依赖了C，但是两者依赖的C版本不同，那么就可能发生jar包冲突。<br>在程序运行期间发生了NoSuchMethodError或者ClassNotFoundException等异常或者错误，需要考虑是不是发生了jar包冲突。<br>当发生jar包冲突的时候，需要手动仲裁究竟使用哪个版本。</p>
<h1 id="二、依赖传递"><a href="#二、依赖传递" class="headerlink" title="二、依赖传递"></a>二、依赖传递</h1><p>几乎所有的jar包冲突都和Maven的依赖传递有关。主要有以下两个主要原则：<br><strong>最短路径优先原则：</strong><br>A-&gt;X-&gt;Y-&gt;Z(2.5)<br>B-&gt;X-&gt;Z(2.0)<br>最终生效的是2.0版本，因为B的依赖路径是最短的。<br><strong>最先声明优先原则：</strong><br>如果依赖路径长度一样，这个时候谁先声明就用谁的版本。<br><strong>依赖树：</strong><br>我们可以通过<code>mvn dependency: tree</code>来查看依赖树，不过idea中有插件maven helper来查看。</p>
<h1 id="三、依赖仲裁"><a href="#三、依赖仲裁" class="headerlink" title="三、依赖仲裁"></a>三、依赖仲裁</h1><p>当发生了jar包冲突的时候，我们需要手动仲裁使用哪个版本。解决方案如下：<br><strong>排除依赖：</strong><br>比如A和B都依赖Z包，我们想只用A依赖的Z包版本，那么就可以通过exclusion排除掉B包的依赖。<br><strong>版本锁定：</strong><br>直接在项目的父级pom中，写死version。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>JDK 9对String的优化</title>
    <url>/2024/07/17/JDK-9-change-String/</url>
    <content><![CDATA[<p>在JDK 9之前，String内部是用char[]来保存字符串的。</p>
<span id="more"></span>
<p>Java内部使用UTF-16，每个char字符16位，占据两个字节，即使有些字符可以用一个字节表示，但依然会占用两个字节。那么JDK 9对这部分做了改进。<br><strong>Latin1：</strong>又称为ISO8859-1，是一种字符编码格式，使用单字节编码方案。<br><strong>Compact String：</strong><br>如果一个字符串<strong>所有字符</strong>都可以用Latin-1来表示，那么String内部就使用byte数组来保存字符串，只要有一个字符需要16位表示，String内部就继续使用char[]来表示。<br>那么在操作String的时候，怎么知道是用byte数组还是char数组呢？<br>答：设置一个byte位，用0来表示Latin-1，用1来表示16位char。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>String intern方法</title>
    <url>/2024/07/17/Java-intern/</url>
    <content><![CDATA[<h1 id="一、String-str-new-String-“daisybby”-创建了几个对象？"><a href="#一、String-str-new-String-“daisybby”-创建了几个对象？" class="headerlink" title="一、String str&#x3D;new String(“daisybby”)创建了几个对象？"></a>一、String str&#x3D;new String(“daisybby”)创建了几个对象？</h1><span id="more"></span>
<p><strong>1个：</strong>在字符串常量池中存在字面量为”daisybby”的字符串，那么因为new String，所以只在堆中创建一个值为”daisybby”的String对象。<br><strong>2个：</strong>字符串常量池中，没有字面量为”daisybby”的字符串，那么先在堆中创建这个字符串对象，这个对象的引用存留在字符串常量池中；然后在堆中创建一个字面量相同的新String字符串对象。</p>
<blockquote>
<p>只要是new String来创建字符串，尽管字符串常量池中已经有相同的字面量了，还是会在堆中新建一个String对象。</p>
</blockquote>
<h1 id="二、String中intern的作用"><a href="#二、String中intern的作用" class="headerlink" title="二、String中intern的作用"></a>二、String中intern的作用</h1><p>当字符串对象调用intern方法时，判断该字符串内容是否在字符串常量池中首次出现：</p>
<ul>
<li>首次出现：在堆中新建一个此字符串内容的实例，并将该实例的引用驻留在字符串常量池中，并返回该引用。</li>
<li>不是首次出现：直接返回字符串常量池中这个实例的引用。通过这种方法可以避免new String新建一个字面量相同的字符串对象。</li>
</ul>
<p>为了深入理解这部分的内容，以下有几个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String a=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String b=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(a==b);<span class="comment">//输出是true</span></span><br><span class="line"></span><br><span class="line">        String one=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">        String two=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">        String three=<span class="string">&quot;hhh&quot;</span>;</span><br><span class="line">        System.out.println(three==one.intern());<span class="comment">//true</span></span><br><span class="line">        System.out.println(one==two);<span class="comment">//false</span></span><br><span class="line">        System.out.println(one==one.intern());<span class="comment">//false</span></span><br><span class="line">        System.out.println(one.intern()==two);<span class="comment">//false</span></span><br><span class="line">        System.out.println(one==two.intern());<span class="comment">//false</span></span><br><span class="line">        System.out.println(one.intern()==two.intern());<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一个true：</strong><br>这里牵扯到一个知识点：</p>
<ul>
<li>直接用字面量创建String字符串对象，如果字符串常量池中已经有这个字面量的实例引用，那不会创建新的对象，变量获得的是字符串常量池中的引用。</li>
<li>上面提到过，new String创建字符串是一定会在堆里创建新对象的。<br>所以a和b都是字符串常量池中”abc”这个字面量对应实例的引用。</li>
</ul>
<p><strong>第二部分：</strong><br>one和two都是用new String的方式创建的，所以是两个不同的对象，one&#x3D;&#x3D;two的结果是false。<br>创建one的过程如下：</p>
<ol>
<li>检查字符串常量池，发现没有字面量为”hhh”的对象引用；</li>
<li>在堆中创建String对象，将这个对象的引用驻留到字符串常量池中；</li>
<li>在堆中创建String对象，并将这个对象的引用返回给one。</li>
</ol>
<p>因为字符串常量池中的引用和one引用的并不是同一个对象，所以one&#x3D;&#x3D;one.intern()的结果是false。</p>
<p>创建two的过程如下：</p>
<ol>
<li>检查字符串常量池，发现已经有字面量为”hhh”的引用了，所以不需要新加入内容到字符串常量池；</li>
<li>因为是new String，所以在堆中创建一个字面量为”hhh”的对象，并将这个对象的引用返回给two；这个时候堆中有三个字面量都是”hhh”的对象。</li>
<li>two.intern()是去字符串常量池中检查，有没有字面量为”hhh”的引用，是有的，所以two.intern()返回的就是字符串常量池中的引用。<br>因此one!&#x3D;two，这是两个对象；one.intern()和two.intern()都是字符串常量池中的引用，所以是相等的。</li>
</ol>
<p>创建three的过程如下：</p>
<ol>
<li>在字符串常量池中检查是否有字面量为”hhh”的引用，有，所以直接将字符串常量池中的引用返回给three；</li>
<li>所以three&#x3D;&#x3D;one.intern()是true，和two.intern()也是true。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java Timer实现定时调度</title>
    <url>/2024/07/18/Java-Timer/</url>
    <content><![CDATA[<p><strong>是什么？</strong></p>
<span id="more"></span>
<p>Java中的Timer是一个定时调度器，用于在指定的时间点执行任务。<br>Timer最重要的两个成员变量：</p>
<ol>
<li>TaskQueue：任务队列，用来存储已计划的定时任务。任务队列按照任务的执行时间排序，最早执行的队伍排在队列前面。</li>
<li>TimerThread：Timer内部的后台线程，负责扫描任务队列中的任务，检查执行时间，在任务的执行时间到达时，执行任务的run方法。TimerThread是一个守护线程。</li>
</ol>
<p><strong>TimerThread执行逻辑：</strong><br>TimerThread内部运行mainLoop()方法，在一个循环中不断检查任务队列，是否已经有任务的执行时间exeTime&lt;&#x3D;currentTime，有则执行。<br>任务队列中的任务可能是一次性的，也可能是重复的，一次性任务执行完就从任务队列中删除；重复性任务需要重新计算下一次的执行时间。</p>
<p><strong>Timer的优缺点：</strong><br>优点：<br>Timer实现十分简单，是Java内置的，十分轻量级，只需要简单的调用就行。<br>缺点：</p>
<ul>
<li>Timer内部是单线程执行的，如果某个任务执行的时间比较长，会影响后面的任务执行；导致很多任务的实际执行时间比预设时间晚。</li>
<li>如果某个任务执行过程中抛出了异常，将会导致整个Timer线程终止，所有的任务都没办法执行。</li>
<li>Timer无法提供高精度的定时任务，因为是串行执行任务，无法预估每个任务具体的执行时间，有些任务执行时间长，后面的任务会“晚点”。</li>
<li>在取消任务时，Timer虽然提供了cancel方法，但并不是真正地将任务从任务队列删除，而是做标记，这部分的空间还是会被消耗，无法释放资源，可能会导致内存泄漏。</li>
<li>Timer每次扫描任务队列都会进行时间比较，当任务队列中有大量任务时，Timer的性能会下降。</li>
<li>Timer是完全基于JVM内存的，一旦应用重启，任务队列中的任务就都没有了。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java中组合和继承</title>
    <url>/2024/07/18/composition-and-inheritance/</url>
    <content><![CDATA[<h1 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h1><span id="more"></span>
<p><strong>继承：</strong><br>子类继承父类的功能，并且可以添加自己的新功能，当然，子类也可以重写从父类继承过来的方法。继承是类与类之间，也是类与接口之间最常见的关系，是一种<code>is-a</code>关系。例如Dog继承自Animal，且Dog is a Animal。<br><strong>组合：</strong><br>组合体现的是整体与部分的关系，拥有的关系，即<code>has-a</code>关系。例如Dog类包含Trail类，Dog has a Trail。</p>
<h1 id="二、继承与组合的区别与联系"><a href="#二、继承与组合的区别与联系" class="headerlink" title="二、继承与组合的区别与联系"></a>二、继承与组合的区别与联系</h1><h2 id="2-1-继承"><a href="#2-1-继承" class="headerlink" title="2.1.继承"></a>2.1.继承</h2><p>父类的内部细节对于子类来说是可见的，所以通过继承方式实现的代码复用是<strong>白盒式代码复用</strong>。如果父类发生了改变，那么子类也会发生改变，这会导致子类行为具有一定的不可预知性。<br>我们在定义类的时候，就要写清楚这个类有没有继承哪个类，所以继承关系在<strong>编译阶段</strong>就已经确定。因此在运行期是不能修改的，降低了应用的灵活性。</p>
<h2 id="2-2-组合"><a href="#2-2-组合" class="headerlink" title="2.2.组合"></a>2.2.组合</h2><p>组合是通过对现有的对象进行组合拼装，来构成新的功能。组合内部的各个对象之间，内部细节是不可见的，所以通过组合实现代码复用是<strong>黑盒式代码复用</strong>，只能在组合内部定义新的方法，来调用组合拥有对象的接口。需要不同的功能，可以调用不同成员对象的接口，更加灵活。<br>组合使得我们可以采用面向接口编程，所以组合关系是在<strong>运行期</strong>确定的。</p>
<h2 id="2-3-两者的优缺点"><a href="#2-3-两者的优缺点" class="headerlink" title="2.3.两者的优缺点"></a>2.3.两者的优缺点</h2><p><strong>继承：</strong><br>缺点：</p>
<ul>
<li>继承是会破坏封装的，父类的内部细节对子类是可见的。</li>
<li>子类无法动态继承，继承关系在编译期就确定，运行期子类无法动态选择继承哪个类。</li>
<li>子类依赖于父类，如果父类的实现发生了改变，子类也会被改变。</li>
</ul>
<p>优点：</p>
<ul>
<li>子类可以自动继承父类的接口，也能够重写父类的方法，或者是新增自己的方法，实现扩展。</li>
<li>创建对象的时候，创建子类的对象就行了，不需要创建父类的对象就能调用父类的方法。</li>
</ul>
<p><strong>组合：</strong><br>缺点：</p>
<ul>
<li>组合不能自动获得内部局部类的接口，需要自己写各种功能的接口。</li>
<li>创建组合对象时，会创建所有内部类的对象。</li>
</ul>
<p>优点：</p>
<ul>
<li>组合并不会破坏封装，局部类的内部细节是不可见的，只能调用局部类提供的接口。</li>
<li>组合能够实现类与类之间的解耦，程序安全性更好。</li>
<li>组合关系是在运行期确定的，在运行时整体对象可以选择不同类型的局部对象；</li>
<li>组合的整体类可以对局部类进行包装，封装局部类的接口，提供新的接口。</li>
</ul>
<h1 id="三、怎么选择继承还是组合？"><a href="#三、怎么选择继承还是组合？" class="headerlink" title="三、怎么选择继承还是组合？"></a>三、怎么选择继承还是组合？</h1><p>通常来说，组合由于继承，多用组合，少用继承。组合更加灵活，也更有助于代码维护。<br>但是，有些特殊场景下，继承是更合适的。比如：<br>类之间是十分明显的<code>is-a</code>关系，且需要从子类向上转型，这个时候继承是必要的。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>为什么建议自定义一个无参构造器？</title>
    <url>/2024/07/18/Java-no-attribute-constructor/</url>
    <content><![CDATA[<p>在定义类的时候，如果没有定义任何构造函数，JDK会自动添加一个午餐构造函数，如果已经定义了构造函数，就不会再默认添加。</p>
<span id="more"></span>
<p>这就出现了问题，如果我们只定义了有参构造函数，那么系统就不会添加默认的无参构造函数，类就没有午餐构造函数，创建对象的时候必须通过有参构造函数才行。<br>但是没有无参构造函数，有些场景下会出问题：</p>
<ol>
<li>反射以及序列化要求<br>在使用反射以及反序列化的时候，通常是调用类的无参构造函数来创建对象。</li>
<li>兼容性和扩展性<br>在一些框架中，比如Spring、Jackson等，在进行对象的创建和初始化的时候，都是依赖于类的无参构造器，缺乏无参构造器可能会导致这些框架无法工作。</li>
<li>JavaBean规范<br>一个标准的JavaBean是必须包含无参构造器，这使得JavaBean可以被实例化，也可以通过反射机制被外部修改。</li>
<li>子类构造器的默认行为<br>子类构造器会默认调用父类的无参构造器，如果子类没有显式调用父类的其他构造器，父类也没有定义无参构造器，这个时候会编译出错。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>为什么不建议使用异常控制业务流程</title>
    <url>/2024/07/18/Java-NOT-use-Exception-to-control/</url>
    <content><![CDATA[<p><strong>什么是异常控制业务流程？</strong></p>
<span id="more"></span>
<p>说直白点，就是catch里面有业务流程代码。<br><strong>为什么不建议这么做？</strong></p>
<ol>
<li><strong>性能问题：</strong>在Java中，异常的生成和处理，涉及到了填充栈和跟踪信息，频繁地抛出和捕获异常会影响系统的性能。</li>
<li><strong>异常的职责：</strong>异常就是用来要求程序员处理异常情况的，把业务逻辑代码和异常绑定，会导致代码逻辑混乱，增加代码维护的难度。</li>
<li><strong>异常的捕获会影响事务的回滚：</strong>既然要异常控制业务逻辑，那么就要catch捕获异常，但是有些情况下，异常的捕获会导致事务失效，无法回滚，造成数据不一致等。</li>
<li><strong>过度依赖底层数据库异常：</strong>如果哪天异常改变了，或者是版本升级了，不会再抛出这个异常，那么这段业务逻辑就失效了。</li>
</ol>
<p>异常本身就不应该和业务逻辑牵扯起来，这违反了我们开发的常规思想。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>解析Java的main方法</title>
    <url>/2024/07/18/main-method/</url>
    <content><![CDATA[<p>main方法是Java应用程序的入口。</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本main函数都长这样，接下来就对每个细节展开讲讲。<br><strong>为什么main方法是public的？</strong><br>java的四种访问控制修饰符：</p>
<ul>
<li>default：默认的，啥也不写，是同一个包内可见。</li>
<li>private：私有的。同一个类内部可见。</li>
<li>public：公开的，对所有类可见。</li>
<li>protected：保护的，同一个包内的类和子类可见，但是不能用来修饰外部类。</li>
</ul>
<p>因为main方法是JVM直接调用的，所以需要是public的，不然没办法调用。</p>
<p><strong>为什么main方法是static的？</strong><br>静态方法属于类，不需要实例化这个类就能调用，只要类被夹在，就能找到这个方法。<br>main方法写成静态方法，可以很方便地被JVM调用，不需要实例化对象。</p>
<p><strong>为什么main方法是void？</strong><br>像C和C++，main方法最后会返回一个int类型的0，因为这个0是程序退出时的exit code，命令解释器或者是其他外部程序调用已确定的流程是否完成。</p>
<p>但是在Java中，程序的推出是JVM控制的，在发生以下两种情况发生时，程序会终止并退出：</p>
<ul>
<li>所有不是后台守护线程的线程都结束了。</li>
<li>某个线程调用了Runtime类或者System类的exit方法，并且安全管理器不限制exit方法执行时。</li>
</ul>
<p>也就是说JVM终止程序是不依赖于main方法的返回值的，所以不需要返回了。</p>
<p><strong>为什么main的参数类型是String数组？</strong><br>因为java程序接受命令行传入参数，这个时候传入的参数是字符串类型，而且有可能有多个参数，所以使用String数组。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java中static的作用</title>
    <url>/2024/07/18/Java-static/</url>
    <content><![CDATA[<p>Java的static可以用于修饰类、方法、变量和代码块。</p>
<span id="more"></span>
<p><strong>修饰变量：</strong><br>在Java中使用static定义静态变量，静态变量属于类。具有以下特性：</p>
<ul>
<li>不需要实例化类，可以通过类名.静态变量名的形式来访问；</li>
<li>所有的实例共享这一个静态变量；</li>
<li>在类加载到内存中的时候就被初始化，而不是创建类实例的时候。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">count</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修饰方法：</strong><br>static修饰的方法属于静态方法，静态方法也是属于类的，可以通过类名.方法名的方式调用。<br>静态方法的特性：</p>
<ul>
<li>静态方法属于类，而不是属于类的实例。</li>
<li>静态方法只能访问类的静态属性，而不能访问类的实例对象的属性。<br>例如main方法就是一个静态方法。</li>
</ul>
<p><strong>修饰代码块：</strong><br>static修饰用来初始化静态变量的代码块。static修饰的代码块有以下特性：</p>
<ul>
<li>当类被JVM加载并初始化的时候执行</li>
<li>通常被用来做静态变量的复杂初始化</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> timeout;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Initializing database setting&quot;</span>);</span><br><span class="line">        timeout=<span class="number">30</span>;</span><br><span class="line">        url=<span class="string">&quot;......&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义静态内部类：</strong><br>在类内部定义一个静态类。<br>静态内部类具有以下特性：</p>
<ul>
<li>只能访问外部类的静态成员</li>
<li>不依赖于外部类的实例而独立存在。</li>
<li>常用于内部类行为独立于外部类的实例时。</li>
</ul>
<blockquote>
<p>使用static来定义静态变量、静态方法、静态代码块和静态内部类，主要目的是为了将这些内容和类的实例对象独立开，提供一个类的所有实例都能方便访问的全局访问点，或者是无需实例化类就能调用类的变量和方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Long和BigDecimal表示金额哪个更合适？</title>
    <url>/2024/07/18/Long-and-BigDecimal/</url>
    <content><![CDATA[<p>在表示金额的时候，是不能用float和double，会丢失精度。</p>
<span id="more"></span>
<p>行业内表示金额的两种做法：</p>
<ul>
<li>单位为分，数据库内用bitint，代码中用Long；</li>
<li>单位为元，数据库内用decimal，代码中用BigDecimal。</li>
</ul>
<p>Long和BigDecimal各有优缺点以及适用的场景。</p>
<p><strong>BigDecimal：</strong><br>适合用于小数，需要高精度数值计算的场景，例如金融、计算和工程等领域。BigDecimal的特点如下：</p>
<ul>
<li><strong>精确度高：</strong>BigDecimal可以表示非常大或者非常精确的小数，不会出现浮点数的舍入误差。</li>
<li><strong>灵活的数学运算：</strong>BigDecimal支持加减乘除和四舍五入等灵活的数学运算。</li>
<li><strong>控制舍入：</strong>BigDecimal允许我们自己控制舍入模式。</li>
</ul>
<p><strong>Long：</strong><br>Long用于整数，是Java基本数据类型中的一种。<br>Long的特点如下：</p>
<ul>
<li><strong>性能高：</strong>作为Java的基本数据类型，Long的处理性能是很高的。</li>
<li><strong>容量限制：</strong>Long的表示范围是2^63-1到-2^63。如果数据非常大，可能会超过表示范围。</li>
</ul>
<p>Long适合用于不涉及到小数，且数值可能非常大的场景。</p>
<p>在实际业务开发时，大部分金融、计算应用，还是用BigDecimal，支持小数运算；但是如果不涉及小数，那可以用Long，处理效率更高。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>怎么修改一个private的String参数值</title>
    <url>/2024/07/18/change-a-private-String/</url>
    <content><![CDATA[<p>一个挖坑的问题。</p>
<span id="more"></span>
<p>首先需要明确的是，String是不可变的，如果说要修改，只能修改这个变量（引用）所指向的对象，如果说指向另一个String对象视为改变，那这个是可以的。</p>
<ol>
<li>常规修改方法<br>我们都知道，setter是常用的修改私有属性方法。</li>
<li>通过反射机制<br>私有成员变量对反射机制是可见的，但是并不能调用。想要调用私有成员变量，需要先修改访问控制规则，然后再修改。这种方式破坏了封装性，增加了代码的复杂性和出错的可能性，而且反射的性能并不好。<br>以下是一个通过反射修改的例子：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;a dog&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog dog=<span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Field field=Dog.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    field.set(dog,<span class="string">&quot;a cute dog&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e)&#123;</span><br><span class="line">    e.pringStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合类和排序方式</title>
    <url>/2024/07/19/Java-collection/</url>
    <content><![CDATA[<h1 id="一、Java集合类"><a href="#一、Java集合类" class="headerlink" title="一、Java集合类"></a>一、Java集合类</h1><span id="more"></span>
<p>常用的集合数据结构：Set、List、Queue、Stack和Map。<br>Set、List和Queue都继承自Collections接口。继承了Map接口的有：hashMap、hashTable和TreeMap。<br><strong>Collection和Collections的联系与区别：</strong></p>
<ul>
<li><strong>Collection：</strong>是集合类接口，提供了对集合类进行基本操作的通用接口。</li>
<li><strong>Collections：</strong>是一个包含各种集合操作的静态方法的类，这个类并不能实例化，毕竟静态方法用类名.方法名就能调用。包装一个工具包。</li>
</ul>
<p><strong>Collection如何迭代？</strong></p>
<ul>
<li><strong>基于计数器的for循环：</strong>最简单的for(int i)循环。</li>
<li><strong>迭代器iterator：</strong>可以定义一个迭代器，基于顺序存储集合的迭代器可以按照位置直接访问，基于链式存储集合的迭代器需要保存当前遍历的位置，然后向前或者向后访问。</li>
<li><strong>foreach循环：</strong>内部本质上也还是用迭代器iterator实现的。</li>
<li><strong>迭代器Enumeration：</strong>是iterator的古老版本。</li>
<li><strong>Stream：</strong>JDK 1.8提供的Stream API也可以实现遍历。</li>
</ul>
<p><strong>List、Set、Queue和Map的区别？</strong></p>
<ul>
<li><strong>List：</strong>存储的元素是有序的，可重复的。</li>
<li><strong>Set：</strong>内部的元素是无序的，不可重复的。</li>
<li><strong>Queue：</strong>保持先进先出的顺序，内部存储的元素是有序的，可重复的。</li>
<li><strong>Map：</strong>存储的元素是KV键值对，key是唯一的，value是任意的。</li>
</ul>
<h1 id="二、集合的排序方式"><a href="#二、集合的排序方式" class="headerlink" title="二、集合的排序方式"></a>二、集合的排序方式</h1><p>说是集合排序，不如说是保存到集合内部的对象排序。有两种方式：<strong>实体类实现comparable接口</strong>和<strong>借助comparator</strong>。<br><strong>实现comparable接口：</strong><br>比如学生类，先按照姓名排序，然后再按照年龄排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student stu)</span>&#123;</span><br><span class="line">        <span class="type">int</span> flag=<span class="built_in">this</span>.name.compareTo(stu.getName());</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">            flag=<span class="built_in">this</span>.age-stu.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>借助Comparator：</strong><br>如果有一些类不是我们定义的，且没有实现Comparable接口，那只能借助Comparator来排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(students,(o1,o2)-&gt;&#123;</span><br><span class="line">    <span class="type">int</span> flag=o1.getName().compareTo(o2.getName());</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">        flag=o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Stream API排序</strong><br>底层还是通过Comparable实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果Student实现了Comparable接口</span></span><br><span class="line">students.stream().sorted().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有实现Comparable接口，需要借助Comparator</span></span><br><span class="line">students.stream().sorted((o1,o2)-&gt;&#123;</span><br><span class="line">    <span class="type">int</span> flag=o1.getName().compareTo(o2.getName());</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">        flag=o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h1 id="三、扩展"><a href="#三、扩展" class="headerlink" title="三、扩展"></a>三、扩展</h1><p><strong>compareTo和equals的使用场景有什么区别？</strong></p>
<ul>
<li><strong>compareTo</strong>通常用于对象的排序，以及BigDecimal数值的比较；</li>
<li><strong>equals</strong>通常用来比较两个对象是否相等。</li>
</ul>
<p><strong>Set是无序的，可以排序吗？</strong><br>Set的无序并不是说必须维持无序的状态，而是说set中的插入顺序是无序的，但是还是可以通过以上方式对内部元素进行排序。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>什么是fail-fast？什么是fail-safe</title>
    <url>/2024/07/19/fail-fast-and-fail-safe/</url>
    <content><![CDATA[<h1 id="一、fail-fast"><a href="#一、fail-fast" class="headerlink" title="一、fail-fast"></a>一、fail-fast</h1><span id="more"></span>
<p>在系统设计中，fail-fase快速失效系统，就是在做系统设计的时候先考虑异常情况，一旦发生异常，就立即停止。<br>有点抽象，个人理解的就是先做异常处理，然后再继续做业务逻辑，而不是把业务逻辑放到前面吧。</p>
<p><strong>集合类中的fail-fast：</strong><br>在集合类中，为了避免并发修改，会维护一个expectedModCount属性，记录迭代器预期的修改次数，以及集合类自己具有的modCount属性，记录集合实际被修改的次数。在集合被修改的时候，会对比expectedModCount和modCount是否一致，不一致就会抛出ConcurrentModificationException。</p>
<p><strong>集合类中的fail-safe：</strong><br>fail-fast是不允许并发修改的，但是有些集合是线程安全的，就是需要并发使用的，不做任何处理的话不断抛出异常就没办法正常工作了。</p>
<h1 id="二、集合类的fail-fast"><a href="#二、集合类的fail-fast" class="headerlink" title="二、集合类的fail-fast"></a>二、集合类的fail-fast</h1><p>如下增强for循环遍历集合的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; userNames=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;daisybby&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;daisy&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;yyy&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;yuan&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(String userName:userNames)&#123;</span><br><span class="line">    <span class="keyword">if</span>(userName.equals(<span class="string">&quot;daisybby&quot;</span>))&#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会抛出ConcurrentModificationException异常，这就是触发了集合类的fail-fast机制。不仅仅是remove，如果是add，也一样会抛出异常。</p>
<p><strong>异常原理</strong><br>以上代码其实是语法糖，在底层解语法糖之后，代码转换成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; userNames=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()&#123;&#123;</span><br><span class="line">        add(<span class="string">&quot;daisybby&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;daisy&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;yyy&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;yuan&quot;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    Iterator iterator=userNames.iterator();</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!iterator.hasNext())&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String userName=(String)iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(userName.equals(<span class="string">&quot;daisybby&quot;</span>))&#123;</span><br><span class="line">            userNames.remove(userName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foreach语法糖是依赖迭代器iterator来实现的，异常是在iterator.next()处抛出，这个方法里面调用了checkForComodification方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(modCount!=expectedModCount)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>modCount是ArrayList的一个成员变量，在初始化ArrayList之后就有了这个变量，初值为0.<br>expectedModCount是ArrayList的内部类Itr中的成员变量，在<code>Iterator iterator=userNames.iterator();</code>代码，会得到一个Itr类，这个类实现了iterator接口。expectedModCount随着Itr的创建被初始化，通过<strong>迭代器对集合操作</strong>的时候，expectedModCount才会发生变化。<br>上面的remove并不是通过迭代器对集合进行的删除，而是通过集合类自己的方法操作的，所以expectedModCount并不会发生变化，但是remove操作会修改modCount的值，最终导致两个变量值不一致，抛出异常。<br>两个变量的变化过程如下：</p>
<ol>
<li>List<String> userNames&#x3D;….：初始化集合类，modCount&#x3D;0</li>
<li>userName.iterator();初始化expectedModCount&#x3D;0；</li>
<li>userNames.remove()，删除元素，modeCount++,modeCount&#x3D;1</li>
<li>iterator.next()，在这里判断expectedModCount&#x3D;&#x3D;modCount？</li>
</ol>
<h1 id="三、fail-safe"><a href="#三、fail-safe" class="headerlink" title="三、fail-safe"></a>三、fail-safe</h1><p>为了避免触发fail-fast机制，我们可以使用Java提供的一些采用了fail-safe机制的集合类。<br>这样的集合类在遍历的时候，恢复至一份原来的集合内容，在复制出来的副本上遍历。<br>java.util.concurrent提供的容器都是fail-safe的，可以在多线程下并发使用，并发修改，也可以在使用了iterator的foreach中add&#x2F;remove。<br>不过这些add&#x2F;remove操作都是通过加锁来控制并发的。</p>
<p>需要注意的是，因为遍历是在副本集合上面进行的，所以在获取到集合副本之后，原集合如果发生了变化，迭代器也是不知道的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        List&lt;String&gt; userNames=<span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;String&gt;()&#123;&#123;</span><br><span class="line">            add(<span class="string">&quot;daisybby&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;daisy&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;yyy&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;yuan&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Iterator iterator=userNames.iterator();</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!iterator.hasNext())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String userName=(String)iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(userName.equals(<span class="string">&quot;daisybby&quot;</span>))&#123;</span><br><span class="line">                userNames.remove(userName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的输出结果还是有daisybby。因为在<code>Iterator iterator=userNames.iterator()</code>之后，就获得了拷贝集合，在循环里面remove调用集合本身的方法进行删除，原来的集合被修改了，但是拷贝集合还是最初的那个状态。</p>
<p><strong>什么是Copy-on-Write？</strong><br>Copy-On-Write简称COW，是一种程序设计的优化策略，最初的数据内容是大家共享的，如果有线程想要修改，那就自己复制一份出去修改，这是一种延时懒惰策略。修改完之后再把原容器的引用指向修改后的新容器。<br>对于CopyOnWriteArrayList的add&#x2F;remove方法是需要加锁来保证并发安全的。但是读操作不需要。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>怎么在遍历的同时修改List?</title>
    <url>/2024/07/19/change-List-during-loop/</url>
    <content><![CDATA[<p>在foreach的同时修改集合，会触发fail-fast机制，抛出异常。但是有时候又确实需要遍历的同时修改List，该怎么实现？</p>
<span id="more"></span>
<ol>
<li>通过普通的for循环来实现。(不推荐，自己实现可能会出错，漏删)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; students=<span class="built_in">this</span>.getStudents();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;students.size();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(students.get(i).getName.equals(<span class="string">&quot;daisybby&quot;</span>))&#123;</span><br><span class="line">        Student student=students.get(i);</span><br><span class="line">        students.remove(student);</span><br><span class="line">        i--;<span class="comment">//删除之后，i指向的已经是下一个元素了，所以一定要i-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>倒序遍历<br>倒序遍历主要是避免了i-1的操作。</li>
<li>使用迭代器的修改方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; students=<span class="built_in">this</span>.getStudents();</span><br><span class="line">Iterator&lt;Student&gt; it=students.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Student student=(Student)it.next();</span><br><span class="line">    <span class="keyword">if</span>(student.getName().equals(<span class="string">&quot;daisybby&quot;</span>))&#123;</span><br><span class="line">        it.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>仿照fail-safe的思想，先复制一份，然后遍历原来的集合，但是在副本对应的位置修改。（不推荐，比较麻烦）</li>
<li>使用并发安全的集合类。（可以用，但是有些场景下没必要）</li>
<li>使用Steam提供的过滤方法filter。（推荐，简单高效）<br>public List<String> streamRemove(){<br> List<String> userNames&#x3D;this.getUserNames();<br> return userNames.stream().filter(this::notNeedDel).collect(Collectors.toList());<br>}</li>
<li>通过内置的removeIf方法，实现元素的过滤删除从Java8开始，List提供了removeIf方法，来删除满足条件的元素。（推荐）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arrayList.removeIf(<span class="built_in">this</span>::needDel)；</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>Set是如何保证元素不重复的？</title>
    <url>/2024/07/19/Java-set-unrepeat/</url>
    <content><![CDATA[<p>Set中的元素是不重复的，根据Set底层实现方式不同，可以分为两类Set：HashSet和TreeSet。</p>
<span id="more"></span>
<h1 id="一、HashSet实现不重复的原理"><a href="#一、HashSet实现不重复的原理" class="headerlink" title="一、HashSet实现不重复的原理"></a>一、HashSet实现不重复的原理</h1><p>HashSet底层是通过hashMap来实现的，内部的元素是无序的，可以放入null，但是只能放入一个。<br>当向hashSet中添加元素时：</p>
<ol>
<li>计算元素的hashCode，通过扰动计算和按位与，计算元素的存储位置</li>
<li>元素的存储位置是空的，那么就加入元素</li>
<li>存储位置不是空的，判断元素是不是相等，是就重复了，加入失败。</li>
<li>如果元素不相等，那就发生hash冲突了，按照解决策略去解决就行。</li>
</ol>
<h1 id="二、TreeSet实现不重复"><a href="#二、TreeSet实现不重复" class="headerlink" title="二、TreeSet实现不重复"></a>二、TreeSet实现不重复</h1><p>TreeSet底层的实现方式是TreeMap，而TreeMap又是基于红黑树实现的，元素是有序的。<br>TreeMap按照key排序，在插入元素的时候，要调用compareTo()方法来比较，判断元素的插入位置，所以TreeSet保存的元素一定要实现Comparable接口。TreeSet内部也是通过compareTo方法来判断重复元素的。</p>
<h1 id="三、HashSet、TreeSet、LinkedHashSet、BitSet的区别"><a href="#三、HashSet、TreeSet、LinkedHashSet、BitSet的区别" class="headerlink" title="三、HashSet、TreeSet、LinkedHashSet、BitSet的区别"></a>三、HashSet、TreeSet、LinkedHashSet、BitSet的区别</h1><p>这里有个新的概念：BitSet<br>BitSet是一个位集合，和Redis的BitMap思想很像，一串二进制字符串，第10位为1，表示10在这个BitSet里面。<br>Java内部是不知道bit的，所以本质上是一个long数组，long有64位，一次就可以读取64位进行检查。如果需要保存所有int型数据，需要4B*(2^32-1)，但是用BitSet就只需要2^32-1个bit位。<br>BitSet用来表达大数比较方便，但是可能会存在内存的严重浪费，比如就保存一个很大的数，空间还是需要这么多，因为BitSet是和数值有关的，而不是和数据个数有关的。</p>
<ol>
<li><strong>功能不同：</strong><ul>
<li>HashSet是最基本的Set，只提供了去重的功能。</li>
<li>TreeSet是基于红黑树实现，不仅去重，元素更是有序的。</li>
<li>LinkedHashSet是链式存储，通过输入元素的插入顺序。</li>
<li>BitSet不仅能提供去重的功能，通常还能节省内存空间。</li>
</ul>
</li>
<li><strong>实现方式不同：</strong><ul>
<li>HashSet是基于HashMap实现的，去重是根据hashCode和equals来实现的。</li>
<li>LinkedHashMap是利用双向链表来记录插入顺序。</li>
<li>TreeSet是基于TreeMap的，去重是根据compareTo方法。</li>
<li>BitSet基于位数组，一般只用于数字的存储和去重。</li>
</ul>
</li>
<li><strong>BitSet</strong>只是名字里面有Set，但是没有实现Collection接口，也和Iterable接口没什么关系。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>ArrayList和LinkedList</title>
    <url>/2024/07/19/ArrayList-and-LinkedList/</url>
    <content><![CDATA[<h1 id="一、ArrayList和LinkedList的区别是什么？"><a href="#一、ArrayList和LinkedList的区别是什么？" class="headerlink" title="一、ArrayList和LinkedList的区别是什么？"></a>一、ArrayList和LinkedList的区别是什么？</h1><span id="more"></span>
<p>两者都实现了List接口，使用方式也很相似，但是因为实现方式不同，所以在不同的场景、对于不同的操作有不同的性能。<br><strong>ArrayList：</strong>本质上是一个可以改变大小的数组。当ArrayList空间不够的时候，会扩容。需要注意的是ArrayList的频繁扩容也是一个比较耗时的操作。</p>
<p><strong>LinkedList：</strong>是一个双向链表，在添加和删除元素的时候，性能比数组更好，但是get和set这类按照下标的操作，性能是比不上ArrayList的。<br>此外，LinkedList还实现了Queue和Deque接口，提供了比List更多的方法，比如peek()、poll()和offer().</p>
<blockquote>
<p>在使用ArrayList的时候，如果事先清楚了数据量，创建ArrayList的时候直接分配差不多的容量比较好，属于最佳实践。</p>
</blockquote>
<h1 id="二、ArrayList的扩容机制"><a href="#二、ArrayList的扩容机制" class="headerlink" title="二、ArrayList的扩容机制"></a>二、ArrayList的扩容机制</h1><ol>
<li>检查新增元素后，是否会超过数组的容量，如果超过，则进行下一步扩容。</li>
<li>创建一个新数组，容量是原来的1.5倍，最多不超过2^32-1,但是Java 8中容量最大是Integer.MAX_VALUE-8，所以是2^32-9，这个8是ArrayList内部做数组复制优化的开销。</li>
<li>将旧数组中的内容复制到新数组中。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>ArrayList的subList方法</title>
    <url>/2024/07/19/subList-of-ArrayList/</url>
    <content><![CDATA[<p>SubList看似返回了List的子数组，其实并不是新的List，而是使用原List的视图，返回了ArrayList的一段。这个视图用ArrayList的内部类SubList表示。</p>
<span id="more"></span>
<p>因为不是真正的List，所以subList是不能强制类型转换的。</p>
<p>因为返回的是一段，内存中还是同样的存储位置，所以subList和原来的List是相互影响的。</p>
<ol>
<li>对两者做的<strong>非结构性修改</strong>，都会影响到彼此。</li>
<li>subList做的<strong>结构性修改</strong>，在原来的List是可见的。</li>
<li>原来的List<strong>不能做结构性修改</strong>，会抛出异常ConcurrentModificationException。</li>
</ol>
<blockquote>
<p>结构性修改：在集合中增加或者删除元素。<br>非结构性修改：在集合中修改某个元素的内容。</p>
</blockquote>
<p>如果想要对subList进行修改，但是又想保持父List不变，那可以创建subList的拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subList=Lists.newArrayList(subList);</span><br><span class="line">list.stream.skip(start).limit(end).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>解决hash冲突的方式</title>
    <url>/2024/07/19/hash-collision/</url>
    <content><![CDATA[<h1 id="一、方法概述"><a href="#一、方法概述" class="headerlink" title="一、方法概述"></a>一、方法概述</h1><span id="more"></span>
<p>常见的5种方法：</p>
<ol>
<li>开放定址法。<ul>
<li>开放定址法就是一旦发生冲突，就重新在数组中找下一个空的散列地址，只要散列表够大，空的地址总能找到。</li>
<li>常见的开放定址法：线性探测法、二次探测法和双重散列。</li>
<li>缺点是可能会导致元素聚集，降低哈希表的性能。</li>
</ul>
</li>
<li>链地址法。<ul>
<li>链地址法是最常用的解决hash冲突的方法之一。</li>
<li>在这个哈希表的位置挂一个链表，遇到了冲突，就把元素插入到链表的尾端。</li>
<li>Java 中，HashMap就是用链地址法来解决hash冲突。在Java 8之前，只用链表，当冲突的元素很多的时候，查询效率很低，接近O(n)。Java 8之后，当链表中的元素超过8之后，链表转换为红黑树；当红黑树中的元素个数少于6之后，红黑树退化成链表。</li>
</ul>
</li>
<li>再哈希法。<ul>
<li>当hash冲突发生的时候，使用其他的散列函数计算，直到冲突不再产生为止。</li>
<li>再哈希需要额外的计算，但是能有效降低冲突的概率。</li>
</ul>
</li>
<li>建立公共溢出区。<ul>
<li>所谓建立公共溢出区，就是哈希表和冲突的部分分开了，冲突的元素都放到溢出表中。</li>
</ul>
</li>
<li>一致性hash。<ul>
<li>一致性哈希主要用在分布式系统中。通过将数据均匀分布到多个节点上来减少冲突。</li>
</ul>
</li>
</ol>
<h1 id="二、链地址法"><a href="#二、链地址法" class="headerlink" title="二、链地址法"></a>二、链地址法</h1><p>结构比较简单，就是一个数组，出现冲突的时候会在对应的位置挂链表。<br>查询的时候，先通过哈希函数确定位置，然后再遍历链表。<br>优点：</p>
<ul>
<li>处理冲突简单</li>
<li>适合经常插入删除的场景</li>
<li>适合无法预算空间的情况</li>
</ul>
<h2 id="缺点：-当冲突的元素很多的时候，查询效率比较低，接近O-n-。"><a href="#缺点：-当冲突的元素很多的时候，查询效率比较低，接近O-n-。" class="headerlink" title="缺点：- 当冲突的元素很多的时候，查询效率比较低，接近O(n)。"></a>缺点：<br>- 当冲突的元素很多的时候，查询效率比较低，接近O(n)。</h2><h1 id="三、开放定址法"><a href="#三、开放定址法" class="headerlink" title="三、开放定址法"></a>三、开放定址法</h1><p>开放定址法不会再创建新的存储空间了，核心思想就是在那一个数组里面找空的位置填上。</p>
<h2 id="3-1-线性探测法"><a href="#3-1-线性探测法" class="headerlink" title="3.1.线性探测法"></a>3.1.线性探测法</h2><p>一句话概括，发生冲突了，下标就不断+1+1+1向后检查有没有空的。有就填上。<br>这个方法的主要问题就是容易发生元素的聚集，影响后续插入和查找的效率。</p>
<h2 id="3-2-二次探测法"><a href="#3-2-二次探测法" class="headerlink" title="3.2.二次探测法"></a>3.2.二次探测法</h2><p>相比于线性探测法，每步都是1，二次探测法每一步是1，4，9，……这样的二次方。比如第一次走1个，还是冲突，那就走4个，还是冲突，那就走9个。其实是(index+9)%len。<br>这种方法可以减少元素聚集的问题，但还是可能存在小范围的聚集。</p>
<h2 id="3-3-双重散列"><a href="#3-3-双重散列" class="headerlink" title="3.3.双重散列"></a>3.3.双重散列</h2><p>有两个不同的哈希函数，如果第一个发生了冲突，那么就用第二个哈希函数来确定探测序列，注意，这里并不是直接用第二个哈希函数来确定下一个位置的下标，而是在第一个哈希计算的位置再走多少的位置。</p>
<p>总结以上三种开放定址法，其优缺点如下：<br><strong>优点：</strong></p>
<ul>
<li>空间效率：不需要额外的数据结构，比链地址法使用更少的存储空间。</li>
<li>缓存友好型：数据存储在连续的内存空间，所以在寻址的时候有更好的缓存性能。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>负载因子比较高（已经占据的槽位比较多）的时候，查询空槽位的时间会显著增加。</li>
<li>删除操作比较复杂，直接删除可能会影响其他元素的查找。</li>
</ul>
<h1 id="四、再哈希法"><a href="#四、再哈希法" class="headerlink" title="四、再哈希法"></a>四、再哈希法</h1><p>所谓再哈希，也是第一个计算冲突，那就第二个，第二个还冲突，那就第三个。不断更换哈希函数直到不冲突为止。<br>注意，这里新的哈希函数计算的就是直接的地址，一步到位。和双重散列计算的是“步数”并不一样。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>hashMap、Hashtable和ConcurrentHashMap的区别</title>
    <url>/2024/07/27/hashMap-Hashtable-ConcurrentHashMap/</url>
    <content><![CDATA[<p><strong>线程安全：</strong></p>
<span id="more"></span>
<p>HashMap是非线程安全的。<br>Hashtable中的方法是同步的，是线程安全的。<br>ConcurrentHashMap是线程安全的，但是在JDK1.8前后是不一样的实现方式：</p>
<ul>
<li>JDK1.8之前：使用分段锁，分成16个桶（分片），每个分片单独加锁，和整个hash表加锁相比，锁的粒度更细，性能更好。</li>
<li>JDK1.8之后：优化为CAS+synchronized，分段锁的变种，也被称为“锁分离”。相比于JDK1.8之前，锁粒度更细，性能进一步优化。</li>
</ul>
<p><a href="https://daisybby.github.io/2024/07/28/ConcurrentHashMap-thread-safe/">ConcurrentHashMap是怎么实现线程安全的？</a><br><strong>继承关系：</strong><br>HashTable基于陈旧的Dictionary类继承来的。<br>HashMap继承自AbstractMap抽象类，实现了Map接口。<br>CocurrentHashMap也继承了AbstractMap，并实现了CocurrentMap接口。<br><strong>是否允许Null值：</strong><br>HashTable和ConcurrentHashMap都不允许null值，key和value都不允许，否则会抛出NullPointerException异常。<br>hashMap中，null作为key或者value都可以。<br><a href="https://daisybby.github.io/2024/07/28/ConcurrentHashMap-not-null/">为什么ConcurrentHashMap不允许Null</a></p>
<p><strong>默认初始容量和扩容机制：</strong><br>HashTable默认初始容量为11，默认加载因子为0.75，扩容容量：2倍+1<br>HashMap默认初始容量16，默认加载因子0.75，扩容容量：2倍<br>ConcurrentHashMap默认初始容量16，默认加载因子0.75，扩容容量：2倍。需要注意的是，扩容的时候采用分段锁机制，每个段单独扩容。</p>
<p>总结：三者的默认负载因子都是0.75。HashMap和ConcurrentHashMap的基本设置是相同的。</p>
<p><strong>遍历方式的实现：</strong><br>HashTable使用Enumeration遍历，即获取所有的key，然后对key集合进行遍历。遍历过程中支持fail-fast，会检查是否发生并发修改。<br>HashMap使用EntrySet遍历，即先获取所有的key-value键值对，然后遍历Entry集合，遍历过程支持fail-fast，也就是遍历过程中如果发生了结构性修改，会抛出异常。如果只需要遍历key，就用keySet遍历，如果只需要遍历value，可以用Values遍历。<br>ConcurrentHashMap采用分段机制，所以在遍历的过程中，某个段的改变不会影响其他段的遍历。和HashMap相同，可以用EntrySet、KeySet和Values进行遍历，在遍历的时候如果发生了结构性改变，也不会抛出异常，遍历的时候可能会出现数据不一致的情况。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>ConcurrentHashMap是如何保证线程安全的？</title>
    <url>/2024/07/28/ConcurrentHashMap-thread-safe/</url>
    <content><![CDATA[<p><strong>JDK1.7中，采用分段锁技术</strong></p>
<span id="more"></span>
<p>哈希表被分为多个段，每个段的锁是独立的。在并发场景下，多个线程访问哈希表的时候，只需要锁住对应的段就行，别的没有上锁的段还是可以被别的线程所使用的。分段锁提高了ConcurrentHashMap的并发性能。<br>虽然分段锁并发性能有所提升，但是分段是有限的，在高并发场景下，还是会出现同一段的锁竞争，降低系统性能。</p>
<p><strong>在JDK1.8，分段锁被优化为节点锁的思想，即使用CAS+Synchronized机制</strong><br>在插入新节点的时候，如果段为空，就通过CAS操作来添加新节点，如果某个段的hash值为MOVED，就说明这个段正在扩容，那么就调用helpTransfer来协助扩容，否则使用Synchronized锁住当前节点，然后进行节点的添加操作。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>为什么ConcurrentHashMap不允许Null</title>
    <url>/2024/07/28/ConcurrentHashMap-not-null/</url>
    <content><![CDATA[<p>本质是并发HashMap不允许二义性，但是非并发HashMap可以。</p>
<span id="more"></span>
<p>如果查询到了一个null，比如map.get(key)，这个时候不知道是没查到返回的Null，还是有key为null。<br>如果是非并发hashMap，可以用map.contains(key)来检查有没有null这个key，但是对于并发的ConcurrentHashMap，无法查询，因为并发检测过程中，可能会被其他线程修改，检查结果是不可靠的。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap的hash方法是如何实现的</title>
    <url>/2024/07/28/hash-method-of-HashMap/</url>
    <content><![CDATA[<p>hash方法的功能是计算key值应该保存到数组哪个位置。</p>
<span id="more"></span>
<p>方法的输入：Object类型的key<br>方法的输出：int类型的数组下标</p>
<p>在JDK1.7中，包含hash方法和indexFor方法：</p>
<ul>
<li>hash方法：将Object类型的key转换成int类型</li>
<li>indexFor方法：将hash方法的输出转换成数组中的下标<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> h=hashSeed;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==h &amp;&amp;k <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^=k.hashCode();</span><br><span class="line">    h ^=(h&gt;&gt;&gt;<span class="number">20</span>)^(h&gt;&gt;&gt;<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h^(h&gt;&gt;&gt;<span class="number">7</span>)^(h&gt;&gt;&gt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h&amp;(length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在JDK1.8中，优化掉了indexFor方法。下标的计算转移到了putVal方法中。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key==<span class="literal">null</span>)?<span class="number">0</span>:(h=key.hashCode())^(h&gt;&gt;&gt;<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>hash方法为了提升效率，有两个主要技术手段：</p>
<ol>
<li>使用位运算替换取模运算：位运算可以直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</li>
<li>对hashCode进行扰动计算，尽量做到hashCode的高位和低位，任何一位的变化都能对最终结果产生影响。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>为什么HashMap的容量是2^n？该怎么保证？</title>
    <url>/2024/07/28/HashMap-cap/</url>
    <content><![CDATA[<h1 id="HashMap的容量"><a href="#HashMap的容量" class="headerlink" title="HashMap的容量"></a>HashMap的容量</h1><p>HashMap的容量必然是2^n。</p>
<span id="more"></span>
<p>在之前分析hashCode计算方法中提到，Java用位运算替换取模运算，来提高计算速度。但是只有数组的长度是2^n才能用位运算。</p>
<p><strong>如何保证HashMap的容量始终是2^n？</strong><br>两个阶段确保：初始化阶段和扩容阶段。</p>
<p><strong>初始化阶段</strong>HashMap默认的长度是16，但是我们也可以自己给出一个初始化长度，可以是任意的正整数。<br>即使我们给出的初始化长度len不是2^n，Java内部也会计算大于len的第一个2^n，然后作为HashMap的初始化长度。</p>
<p><strong>扩容阶段</strong>，扩容的长度是2倍，在初始化长度位2^n的前提下，扩容后的容量依然是2^n。</p>
<h1 id="怎么设置HashMap的初始容量？"><a href="#怎么设置HashMap的初始容量？" class="headerlink" title="怎么设置HashMap的初始容量？"></a>怎么设置HashMap的初始容量？</h1><p>如果我们不设置初始容量，那么Java就会使用默认的初始容量16。当我们的元素不断增加的时候，HashMap可能会发生多次扩容，每次扩容都要重建hash表，非常影响性能。</p>
<p>实际开发中，比较推荐自己初始化容量。那初始容量设置成多少比较合适呢？<br>在设置的时候，不仅要考虑存储多少个元素，还要考虑负载因子。例如：<br>要保存7个元素，直接new HashMap(7)是不行的，首先创建出来的HashMap不可能是7，而是大于7的第一个2^n，即8.这还没结束，另一个问题是，HashMap的负载因子是0.75，当元素数量大于6的时候，就会发生扩容。</p>
<p>在明确知道HashMap中元素个数的时候，把默认容量设置成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">以上算法guava中有实现，开发的时候可以直接通过Maps类创建一个HashMap：</span><br><span class="line">```java</span><br><span class="line">Map&lt;String,String&gt; map=Maps.newHashMapWithExpectedSize(7);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap是如何扩容的？</title>
    <url>/2024/07/28/HashMap-newCap/</url>
    <content><![CDATA[<p><strong>为什么需要扩容？</strong></p>
<span id="more"></span>
<p>散列表中的元素个数很多的时候，链化比较严重，尽管树化来提升效率，时间复杂度还是没有O(1)好，所以需要扩容来降低Hash冲突。<br>扩容的时候，涉及到三个部分的操作：</p>
<ol>
<li>如果某个桶节点没有形成链表，则直接rehash到新的hash表中；</li>
<li>如果桶有链表，那么这个链表中的元素会根据各自新的hash找到合适的位置</li>
<li>如果桶连接的链表长度已经形成红黑树，但是节点数&lt;6，就需要取消树化。</li>
</ol>
<p><strong>桶元素重新映射</strong><br>当桶中只有一个元素，并没有链表的时候，直接rehash到对应的位置。<br><strong>链表重新链接</strong><br>这部分的意思是链表中的元素之后并不一定会在同一个地方。但是有一个规律，hash(k)&amp;oldCap&#x3D;0的元素，在新hash表中的位置还是会和原来的位置一样，所以这部分直接移动就行，但是链表中其他不为0的元素需要rehash。<br><strong>取消树化</strong><br>因为扩容之后，有些原来的红黑树可能需要退化操作，重新转换成链表。<br>除了rehash之外，remove操作也会进行退化的判断。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>为什么JDK8中HashMap要链表转红黑树</title>
    <url>/2024/07/28/why-red-black-tree/</url>
    <content><![CDATA[<p><strong>为什么不继续使用链表？</strong></p>
<span id="more"></span>
<p>当冲突发生过多的时候，桶指向的链表就会过长，之后的put和get操作，复杂度就会无限接近O(N)。</p>
<p><strong>为什么是红黑树？</strong><br>当链表过长的时候，可以用二叉查找树来代替链表，但是二叉查找树在元素基本有序的时候，会退化成链表。<br>那进一步改进，AVL树，二叉平衡树对平衡的要求十分严格，每次插入删除都要做平衡操作，极大的消耗了插入的时间。<br>对于插入和删除比较频繁的场景，AVL树是不合适的，为了保证查询和插入的时间复杂度维持在一个均衡的水平，可以选择红黑树。</p>
<p>红黑树的相邻节点不能是红色，红色节点要被黑色节点分隔开。叶子节点不存在数据，都是黑色节点。每个节点到达其可达的叶子节点的所有路径，都包含相同的黑色节点。</p>
<p>红黑树不像AVL树一样追求绝对的平衡，插入最多两次旋转，删除最多三次旋转，在频繁的插入删除场景中，红黑树的复杂度是优于AVL树的。</p>
<p><strong>双向链表</strong><br>HashMap的红黑树数据结构中，不仅有parent，left和right节点，还有一个next和prev节点，这是便于退化成链表，而且删除链表中间结点的时候，prev便于前后重新衔接。</p>
<p><strong>HashMap的元素没有比较能力的时候，怎么进行红黑树的比较?</strong></p>
<ol>
<li>如果元素实现了Comparable接口，则直接比较；</li>
<li>如果元素无法比较，则使用默认的仲裁方法。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>Java Stream的并行流是如何实现的？</title>
    <url>/2024/07/28/Java-Stream/</url>
    <content><![CDATA[<p><strong>什么是并行流？</strong></p>
<span id="more"></span>
<p>Stream API提供了有效的处理数据工具，特别是处理大型数据集时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list=Array.list(<span class="string">&quot;Wurt&quot;</span>,<span class="string">&quot;Wilson&quot;</span>,<span class="string">&quot;Willow&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个串行流</span></span><br><span class="line">Stream&lt;String&gt; stream=list.stream();</span><br><span class="line"><span class="comment">//创建一个并行流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream=list.parallelStream();</span><br></pre></td></tr></table></figure>
<p>并行流底层使用了Java7引入的Fork&#x2F;Join框架。这个框架旨在帮助开发者利用多核处理器的并行处理能力。<br>一个大任务被分割(Fork)成多个小任务，这些小任务可以并行执行，然后小任务执行的结果被合并(join)成最终结果。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap在并发场景中的问题</title>
    <url>/2024/07/28/HashMap-problem-concurrent/</url>
    <content><![CDATA[<p>需要注意的是，这里的问题只会出现在JDK1.7以及之前的版本，JDK1.8之后被修复。</p>
<span id="more"></span>
<p><strong>扩容过程导致的循环引用：</strong><br>HashMap在扩容的时候，会将元素插入到链表的头部，这是因为开发者认为后插入的数据被使用的概率更高，放到链表头部，可以使得查询效率更高。<br>但是两个线程执行扩容操作，导致循环引用，下次get数据的时候发生死循环。</p>
<p><strong>JDK1.8如何解决循环引用的问题？</strong><br>因为头插法产生的问题，所以改成尾插法，绷不住了。</p>
<p><strong>HashMap并发场景下的其他问题：</strong></p>
<ol>
<li>多线程put的时候，size设置的和真正的个数不一样；</li>
<li>多线程put的时候，把上一个put的值覆盖掉。</li>
<li>HashMap支持的fail-fast操作，多个线程put和get的时候，会抛出并发异常。</li>
<li>既有get又有扩容的时候，可能要get的元素刚好扩容换了桶，导致get不到数据。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>Java Stream能做什么？</title>
    <url>/2024/07/28/Java-Stream-1/</url>
    <content><![CDATA[<h1 id="一、基本概念和特点"><a href="#一、基本概念和特点" class="headerlink" title="一、基本概念和特点"></a>一、基本概念和特点</h1><span id="more"></span>
<p>Stream将要处理的元素集合看作一种流，流在管道上传输，每个节点可以进行处理，比如筛选、排序和聚合等。</p>
<p>Stream的特点：</p>
<ul>
<li>无存储。Stream并不是存储结构，而是数据的一种视图。</li>
<li>不会修改数据源。对Stream进行过滤操作，并不会删除被过滤的元素，只是会产生一个不包含被过滤元素的新Stream。</li>
<li>惰式执行。Stream的操作并不是立即执行，而是用户需要结果的时候才会执行。</li>
<li>可消费性。Stream只能被消费一次，一旦遍历过后就会失效。</li>
</ul>
<h1 id="二、Stream的关键操作"><a href="#二、Stream的关键操作" class="headerlink" title="二、Stream的关键操作"></a>二、Stream的关键操作</h1><h2 id="2-1-Stream的创建"><a href="#2-1-Stream的创建" class="headerlink" title="2.1.Stream的创建"></a>2.1.Stream的创建</h2><ol>
<li>根据已有的集合创建</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream=list.stream();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过Stream创建流<br>可以使用Stream类提供的方法，直接返回一个由指定元素组成的流。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream=Stream.of(<span class="string">&quot;daisybby&quot;</span>,<span class="string">&quot;Java&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-2-Stream中间操作"><a href="#2-2-Stream中间操作" class="headerlink" title="2.2.Stream中间操作"></a>2.2.Stream中间操作</h2><h3 id="2-2-1-filter"><a href="#2-2-1-filter" class="headerlink" title="2.2.1. filter"></a>2.2.1. filter</h3><p>按照设置的条件过滤元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list=Arrays.asList(<span class="string">&quot;daisybby&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.stream().filter(string -&gt; !string.isEmpty()); <span class="comment">//过滤空字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-map"><a href="#2-2-2-map" class="headerlink" title="2.2.2.map"></a>2.2.2.map</h3><p>用于映射每一个元素到对应的结果，以下代码片段用于输出对应元素的的平方数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums=Arrays.asList(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">nums.stream().map(num-&gt;num*num).forEach(System.out.println);</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-limit-skip"><a href="#2-2-3-limit-skip" class="headerlink" title="2.2.3.limit&#x2F;skip"></a>2.2.3.limit&#x2F;skip</h3><p>limit返回Stream前n个元素，skip则是扔掉前n个元素。以下代码片段使用limit方法保留前3个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums=Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">nums.stream().limit(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-2-4-sorted"><a href="#2-2-4-sorted" class="headerlink" title="2.2.4.sorted"></a>2.2.4.sorted</h3><p>用于对流排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums=Arrays.asList(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">nums.stream().sorted();<span class="comment">//升序排序</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-5-distinct"><a href="#2-2-5-distinct" class="headerlink" title="2.2.5.distinct"></a>2.2.5.distinct</h3><p>用来去重。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums=Arrays.asList(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">nusm.stream().distinct();<span class="comment">//(2,3,4,5)</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-Stream最终操作"><a href="#2-3-Stream最终操作" class="headerlink" title="2.3.Stream最终操作"></a>2.3.Stream最终操作</h2><p>Stream中间结果得到的结果还是一个stream，最终需要转换成我们需要的类型，这就是最终操作。<br>最终操作消耗流，执行最终操作后不能再使用这个流。</p>
<h3 id="2-3-1-forEach"><a href="#2-3-1-forEach" class="headerlink" title="2.3.1.forEach"></a>2.3.1.forEach</h3><p>迭代流中的每个数据。</p>
<h3 id="2-3-2-count"><a href="#2-3-2-count" class="headerlink" title="2.3.2.count"></a>2.3.2.count</h3><p>用来统计流中的元素个数。</p>
<h3 id="2-3-3-collect"><a href="#2-3-3-collect" class="headerlink" title="2.3.3.collect"></a>2.3.3.collect</h3><p>将流中的元素积累成一个汇总结果。 </p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>JDK1.8中HashMap做了哪些改变？</title>
    <url>/2024/07/28/JDK1-8-HashMap-change/</url>
    <content><![CDATA[<p><strong>红黑树</strong></p>
<span id="more"></span>
<p>JDK1.8之前都是用链表，在JDK1.8引入了红黑树机制，链表进化阈值是8，红黑树退化阈值是6。</p>
<p><strong>节点定义</strong><br>JDK1.7之前用的是Entry，在JDK1.8之后用的是Node，两者的定义区别在于int型的hash在Node中被定义成final，一旦初始化就不能再修改了。<br>JDK1.7中的Entry：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;()&#123;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK1.8的Node定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了支持红黑树，还引入了TreeNode节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;</span><br><span class="line">    <span class="type">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>尾插法</strong><br>因为头插法在并发场景下可能会发生死循环，JDK1.8中把头插法改成了尾插法。<br><strong>hash方法</strong><br>JDK1.8中hash方法做了改进，我觉得是扰动计算优化了一些，位运算和异或操作更少了。毕竟引入了红黑树，即使冲突发生，也可以有效地解决冲突，而不需要整一大堆扰动计算。<br><strong>扩容机制</strong><br>首先是JDK1.7中扩容是通过resize和transfer两个方法互相配合完成的。在JDK1.8中，transfer的逻辑直接放到了resize里，而且考虑了红黑树相关的操作。<br>其次在JDK1.7中，每个元素都是重新计算位置，而JDK1.8则不一定，要看原来的hash值新增的那个bit位是0还是1，是0则位置不变，是1则重新计算。（这里和之前讲到的，hash(k)%(2^n)&#x3D;0保持原来的位置，是一个意思）</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>集合类</category>
      </categories>
  </entry>
  <entry>
    <title>JDK1.8 ConcurrentHashMap</title>
    <url>/2024/07/28/JDK1-8-ConcurrentHashMap/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>什么是多线程中的上下文切换？</title>
    <url>/2024/07/29/multi-thread-change/</url>
    <content><![CDATA[<h1 id="一、什么是上下文切换？"><a href="#一、什么是上下文切换？" class="headerlink" title="一、什么是上下文切换？"></a>一、什么是上下文切换？</h1><span id="more"></span>
<p>和进程切换一样，当前线程需要让出CPU给另一个线程，需要保存当前进程的运行状态，恢复另一个线程的上下文状态。</p>
<p>在多线程中，上下文切换的开销比直接用单线程大，因为上下文切换需要保存和恢复线程信息。过多的线程切换会降低系统运行效率，所以线程数并不是越多越好，设置合理的线程数量，避免过多的线程上下文切换次数是十分重要的。</p>
<h1 id="二、怎么减少上下文切换？"><a href="#二、怎么减少上下文切换？" class="headerlink" title="二、怎么减少上下文切换？"></a>二、怎么减少上下文切换？</h1><ol>
<li>减少线程数量：线程越多，发生上下文切换的可能性越大，所以在设置线程数量时，要平衡业务需求和性能需求，设置合理的线程数。</li>
<li>使用无锁并发编程：不适用锁，可以避免因为等待锁而被阻塞，阻塞就要让出CPU，进而发生上下文切换。</li>
<li>使用CAS算法：有些业务场景需要考虑到数据一致性问题，所以可以考虑乐观锁，CAS算法，CAS算法也不会发生线程的阻塞和唤醒操作，从而减少上下文切换。</li>
<li>使用协程（JDK21提出的虚拟线程）：协程是一种用户级线程，切换不需要操作系统的参与，避免操作系统级别的线程切换，JVM还是需要一些信息保存和恢复的操作，但是效率已经提升了很多。</li>
<li>合理使用锁：在使用锁过程中，不能什么地方都用锁，频繁使用同步块或者是同步方法，要尽量缩小同步块或者同步方法的范围，从而减少线程的等待时间。</li>
</ol>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>线程安全的理解</title>
    <url>/2024/07/29/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="一、线程安全的理解"><a href="#一、线程安全的理解" class="headerlink" title="一、线程安全的理解"></a>一、线程安全的理解</h1><span id="more"></span>
<p>线程安全就是指在多线程并发环境下，多个线程之间的共享变量被正确处理，使得程序正确完成。<br>四个关键词：并发，多线程，共享变量，正确完成。要满足原子性、有序性和可见性。</p>
<h1 id="二、进程和线程之间的关系"><a href="#二、进程和线程之间的关系" class="headerlink" title="二、进程和线程之间的关系"></a>二、进程和线程之间的关系</h1><p>操作系统中已经学习的基本关系：进程是资源分配的基本单位，线程是执行的基本单位，一个进程的多个线程之间共享资源。</p>
<p>在Java中，Java的线程是运行在JVM上的，所以一个JVM就是一个进程，所有的资源分配都是基于JVM来做的。在这个JVM进程中，又可以创建很多线程，多个线程之间共享JVM资源，这些线程也可以并行执行。<br>在JDK21之前，线程在操作系统层面也是基于轻量级进程来实现的，本质上线程切换还是操作系统级别的上下文切换；JDK21之后的虚拟线程是一种用户态线程，其上下文切换不需要操作系统参与，开销比之前更小，但是JVM依然要做信息的保存和恢复，还是有开销的。</p>
<h1 id="三、线程的特点"><a href="#三、线程的特点" class="headerlink" title="三、线程的特点"></a>三、线程的特点</h1><p><strong>轻型实体</strong><br>线程包含程序、数组和线程控制块（TCB）。<br><strong>独立调度和执行的基本单位</strong><br>线程是操作系统中能够独立运行的基本单位，也是独立调度和分派的基本单位。<br><strong>并发执行</strong><br>一个进程的多个线程之间可以并发执行，不同进程的线程也可以并发执行。<br><strong>共享进程资源</strong></p>
<h1 id="四、共享变量"><a href="#四、共享变量" class="headerlink" title="四、共享变量"></a>四、共享变量</h1><p>共享变量是指多个线程都可以访问操作的变量。多个线程可以共享进程的一部分资源。在JVM中，Java堆和方法区是多个线程共享的区域，保存在堆和方法区的变脸就是共享变量。<br>而在Java中，有三类变量，分别是：<strong>类变量、实例变量</strong>和<strong>局部变量</strong>。<br>保存位置关系如下：<br>类变量-堆；<br>实例变量-方法区；<br>局部变量-栈内存。<br>如下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> d=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>其中a是类变量，保存在堆内存中；b是实例变量，保存在方法区中；c和d是局部变量，保存在栈内存中。<br>所以a和b是共享变量，在多线程背景下，需要考虑a和b的线程安全问题。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>线程状态</title>
    <url>/2024/07/29/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h1 id="一、线程的六种状态"><a href="#一、线程的六种状态" class="headerlink" title="一、线程的六种状态"></a>一、线程的六种状态</h1><span id="more"></span>
<ol>
<li>初始态（NEW）：线程被创建，但是还没有执行start()方法。</li>
<li>运行(RUNNABLE)：Java将就绪态和运行态统称为运行。<br>就绪：线程对象创建后，其他的线程调用了这个对象的start()方法，该状态的线程加入到了可运行线程池中，等待被线程调度选中并分配CPU资源。<br>运行：线程得到了CPU资源，开始执行。</li>
<li>阻塞(BLOCKED)：线程阻塞于锁。</li>
<li>等待（WAITING)：线程等待其他线程的通知或者中断。</li>
<li>超时等待（TIMED_WAITING）：与等待不同的点在于，到了一定的等待事件后还没有结果，那就自行返回。</li>
<li>终止（TIERMINATED）：表示该线程已经执行完毕。</li>
</ol>
<h1 id="二、WAITING和TIMED-WAITING的区别"><a href="#二、WAITING和TIMED-WAITING的区别" class="headerlink" title="二、WAITING和TIMED_WAITING的区别"></a>二、WAITING和TIMED_WAITING的区别</h1><p>调用wait方法，线程会进入WAITING状态；调用sleep方法，线程会进入TIMED_WAITING状态。</p>
<p>锁：线程进入WAITING状态时，会释放锁；线程进入TIMED_WAITING状态时，并不会释放锁。</p>
<p>因为锁是针对对象的，所以和WAITING状态相关的方法，wait、notify和notifyAll都是Object类的对象。而和TIMED_WAITING状态相关的sleep方法则属于Thread类。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>JDK21中的虚拟线程</title>
    <url>/2024/07/29/JDK21%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><span id="more"></span>
<p>先讲之前的进程和线程之间的关系。在之前的JDK版本中，线程都是基于操作系统的轻量级进程来实现的，每一个Java进程对应一个操作系统的轻量级进程。这种线程模型最终的线程创建、析构和同步等，都需要进行系统调用，而系统调用需要操作系统在内核态和用户态之间来回切换，所以系统开销比较大。</p>
<p>JDK21引入了虚拟线程，也是协程，是一种轻量级线程，不同于之前一线程对应一轻量级进程的做法，现在是多个虚拟线程映射到少量的操作系统线程中，减少操作系统级别的上下文切换次数，来降低系统开销。</p>
<h1 id="二、操作系统线程的实现方式"><a href="#二、操作系统线程的实现方式" class="headerlink" title="二、操作系统线程的实现方式"></a>二、操作系统线程的实现方式</h1><p>三种：</p>
<ul>
<li>基于内核线程实现；</li>
<li>基于用户线程实现；</li>
<li>用户线程加轻量级进程混合实现。</li>
</ul>
<h1 id="三、虚拟线程的改进和优点"><a href="#三、虚拟线程的改进和优点" class="headerlink" title="三、虚拟线程的改进和优点"></a>三、虚拟线程的改进和优点</h1><p>多个虚拟线程映射到少量操作系统线程中的做法，使得能够创建的线程数量不用局限于平台，能够创建很多虚拟线程，不用依赖于平台线程的数量。<br>而且虚拟线程是JVM来管理的，并不是操作系统的线程，所以上下文切换开销没有那么大。</p>
<h1 id="四、虚拟线程和平台线程的区别"><a href="#四、虚拟线程和平台线程的区别" class="headerlink" title="四、虚拟线程和平台线程的区别"></a>四、虚拟线程和平台线程的区别</h1><p>虚拟线程是守护线程，JVM的终止并不会等守护线程执行完，当所有的非守护线程执行完之后，JVM就会终止。<br>虚拟线程的优先级始终是normal，且不能修改。<br>虚拟线程不支持stop()、suspend()、resume()等方法。</p>
<h1 id="五、如何使用虚拟线程"><a href="#五、如何使用虚拟线程" class="headerlink" title="五、如何使用虚拟线程"></a>五、如何使用虚拟线程</h1><ol>
<li>Thread.startVirtualThread()运行虚拟线程。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.startVirtualThread()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;虚拟线程执行中...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通过Thread.Builder来创建虚拟线程。Thread类提供了ofPlatform()来创建一个平台线程，ofVirtual()来创建虚拟线程。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.Builder platformBuilder=Thread.ofPlatform().name(<span class="string">&quot;平台线程&quot;</span>);</span><br><span class="line">Thread.Builder virtualBuilder=Thread.ofVirtual().name(<span class="string">&quot;虚拟线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread th1=platformBuilder.start(()-&gt;&#123;...&#125;);</span><br><span class="line">Thread th2=virtualBuilder=virtualBuilder.start(()-&gt;&#123;...&#125;);</span><br></pre></td></tr></table></figure></li>
<li>线程池创建虚拟线程。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="keyword">var</span> executor=Executors.newVirtualThreadTaskExecutor())&#123;</span><br><span class="line">    InStream.range(<span class="number">0</span>,<span class="number">10000</span>).forEach(i-&gt;&#123;</span><br><span class="line">        executor.submit(()-&gt;&#123;</span><br><span class="line">            Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但并不建议线程池和虚拟线程混用。</li>
</ol>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>创建线程的方式</title>
    <url>/2024/07/29/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一、创建线程的方式"><a href="#一、创建线程的方式" class="headerlink" title="一、创建线程的方式"></a>一、创建线程的方式</h1><span id="more"></span>
<p>有四种方式可以创建线程：</p>
<ol>
<li>继承Thread类。</li>
<li>实现Runnable接口。</li>
<li>通过Callable和FutureTask创建线程。</li>
<li>线程池。</li>
</ol>
<blockquote>
<p>归根到底，只有前两种方法，一种是<strong>继承Thread类</strong>，一种是实现<strong>Runnable接口</strong>。后面两种方法还是基于前两种方法实现的。</p>
</blockquote>
<h1 id="二、Runnable和Callable区别"><a href="#二、Runnable和Callable区别" class="headerlink" title="二、Runnable和Callable区别"></a>二、Runnable和Callable区别</h1><p>实现两个接口都可以用来创建新线程，实现Runnable接口的时候需要实现run方法；实现Callable接口的时候需要实现call方法。<br>Runnable的run方法没有返回值，Callable的call方法返回一个Object对象。<br>Runnable不能抛出checked exception，但是Callable可以。<br>两者都可以用于Executors，Thread类只支持Runnable。</p>
<h1 id="三、Future和FutureTask"><a href="#三、Future和FutureTask" class="headerlink" title="三、Future和FutureTask"></a>三、Future和FutureTask</h1><p>Future是一个接口，用来检查执行是否完成、等待执行完成、获得执行的结果。只能通过get方法来获取结果，在结果没有准备好的时候get方法会一直阻塞，如果想要取消，需要调用cancel()方法。</p>
<p>FutureTask是Future接口的一个实现，实现了一个可以提交给Executor执行的任务，可以检查这个任务的执行状态，也可以获取这个任务的执行结果。</p>
<p><strong>FutureTask和Callable的示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskCallable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Callable&lt;String&gt; callable=()-&gt;&#123; <span class="comment">//这里的String表示结果将返回一个String类型的值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Entered callable&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;return from Callable&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//定义FutureTask指定的String是：FutureTask将持有一个由Callable的call方法返回的String类型的值。</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>线程池和Callable创建线程的示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorCallable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Callable&lt;String&gt; call=()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Entered Executor&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;return from callable&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        ExecutorService executor=Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future=executor.submit(callable);<span class="comment">//注意这里，不是新建，而是任务提交到executor后获得的</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>run/start、wait/sleep、notify/notifyAll</title>
    <url>/2024/07/29/run-start%E5%92%8Cwait-sleep%E5%92%8Cnotify-notifyAll/</url>
    <content><![CDATA[<h1 id="一、run-和start-方法区别"><a href="#一、run-和start-方法区别" class="headerlink" title="一、run()和start()方法区别"></a>一、run()和start()方法区别</h1><span id="more"></span>
<p>首先，调用start方法会开启一个新的线程进入就绪态，一旦获取了CPU资源，就自动执行run方法，run方法执行完，线程终止。<br>如果在一个线程中直接调用了run方法，那么就相当于是执行一个普通的方法，并不会开启新线程。<br>默认的方法是把需要并行处理的部分写到run方法里面，通过start方法开启新线程，然后自动调用run方法来并行执行。</p>
<p>在上一节讲到，创建线程的两种方法，一种是通过继承Thread类来实现，一种是实现Runnable接口来实现。通常通过实现Runnable接口来实现，因为Java是单继承，继承了Thread类就不能再继承其他的类了，而且Runnable只有一个run方法。</p>
<h1 id="二、sleep和wait区别"><a href="#二、sleep和wait区别" class="headerlink" title="二、sleep和wait区别"></a>二、sleep和wait区别</h1><p>sleep方法可以在任何地方用，但是wait只能在同步方法或者同步块中使用（和锁有关）。<br>wait会释放锁，sleep并不会。<br>wait方法执行后，线程会进入WAITING状态，直至被唤醒；sleep方法执行之后，线程进入TIMED_WAITING状态，等到指定时间之后再次尝试获取CPU时间片。</p>
<p>sleep是Thread类的方法，wait是Object类的方法。</p>
<h1 id="三、notify和notifyAll区别"><a href="#三、notify和notifyAll区别" class="headerlink" title="三、notify和notifyAll区别"></a>三、notify和notifyAll区别</h1><p>notify和notifyAll都可以唤醒等待队列中的线程。<br>使用notifyAll可以唤醒所有处于WAITING状态的线程，这些被唤醒的线程加入到锁的竞争队列中，可以去竞争对象锁，但是最终还是只有一个线程可以获取到对象锁。<br>notify和notifyAll都和锁有关，所以是Object类的方法。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>什么是线程池？如何实现的？</title>
    <url>/2024/07/29/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><span id="more"></span>
<p>线程池是池化技术的典型实现。所谓池化技术，就是提前准备好大量的资源，需要用的时候直接拿现成的就行。使用池化技术可以大大提高资源的利用率，不用来一个新建一个，提升系统的性能。<br>线程池就是提前创建好一批线程，当任务到来需要执行的时候，从线程池里面选出来一个线程来执行任务。<br>比较典型的池化技术：<br>线程池、连接池、内存池、对象池等。</p>
<h1 id="二、Executors"><a href="#二、Executors" class="headerlink" title="二、Executors"></a>二、Executors</h1><p>Executors创建线程池的方法，创建出来的线程池都实现了ExecutorsService接口。常用的4个线程池如下：</p>
<ul>
<li>FixedThreadPool(int Threads)：线程池中的线程数量是固定的。有新的任务提交时，如果线程池中有空闲的线程，则立即执行这个任务；否则任务进入任务队列，当线程空闲时，从任务队列中取出任务执行。</li>
<li>SingleThreadExecutor：只有一个线程的线程池，多余的任务被提交给该线程池之后，任务会被保留到一个任务队列中，等线程空闲，按先进先出的顺序执行任务。</li>
<li>CacheThreadPool：根据实际情况调整线程数量的线程池。一个任务被提交到线程池，如果有空闲线程可用，那么就直接执行；如果没有空闲线程可用，则会创建新的线程来执行。所有的线程在执行完当前任务后，会返回线程池进行复用。</li>
<li>ScheduledThreadPool：给定的延迟后运行任务或者定期执行任务的线程池。</li>
</ul>
<h1 id="三、线程池核心参数"><a href="#三、线程池核心参数" class="headerlink" title="三、线程池核心参数"></a>三、线程池核心参数</h1><p>首先是3个最重要的参数：</p>
<ul>
<li>corePoolSize：核心线程数，常驻线程数，任务队列没有达到容量的时候，最大可以同时运行的线程数量。</li>
<li>maximumPoolSize：任务队列中存放任务达到最大容量的时候，线程池可以同时运行的线程数量变成最大线程数。</li>
<li>workQueue：任务队列，新的任务到来，线程池中的线程数量已经达到了核心线程数，那么任务就会加入到任务队列中。</li>
</ul>
<p>其次是常见参数：</p>
<ul>
<li>keepAliveTime：线程池中的线程数量超过corePoolSize时，如果这个时候没有新的任务要处理，一些线程空闲下来，那这些超过核心线程数的线程，等待keepAliveTime之后被销毁。</li>
<li>unit：keepAliveTime的单位。</li>
<li>threadFactory：创建线程的工厂，在这个地方可以统一处理创建的线程属性。</li>
<li>handler：线程池拒绝策略。</li>
</ul>
<h1 id="四、线程池处理任务的流程是什么？"><a href="#四、线程池处理任务的流程是什么？" class="headerlink" title="四、线程池处理任务的流程是什么？"></a>四、线程池处理任务的流程是什么？</h1><img src="/2024/07/29/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0/img1.png" class="" title="img1">
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
  </entry>
</search>
